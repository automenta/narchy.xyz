<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TermIndex.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.term</a> &gt; <span class="el_source">TermIndex.java</span></div><h1>TermIndex.java</h1><pre class="source lang-java linenums">package nars.term;

import nars.Op;
import nars.budget.Budget;
import nars.task.MutableTask;
import nars.task.Task;
import nars.term.compound.Compound;
import nars.term.compound.GenericCompound;
import nars.term.index.MapIndex;
import nars.truth.Truth;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.function.Consumer;
import java.util.function.Function;

import static nars.Op.*;

/**
 *
 */
public interface TermIndex extends TermBuilder {



    /** universal zero-length product */
<span class="fc" id="L29">    Compound Empty = new GenericCompound(Op.PRODUCT, -1, TermVector.Empty);</span>
<span class="fc" id="L30">    TermVector EmptyList = new TermVector();</span>
<span class="fc" id="L31">    TermSet EmptySet = TermSet.the();</span>

    void clear();

    void forEach(Consumer&lt;? super Termed&gt; c);

    //Termed get(Object t);

    @Nullable
    Termed getTermIfPresent(Termed t);

    /** # of contained terms */
    int size();

    /**
     * implications, equivalences, and interval
     */
<span class="fc" id="L48">    int InvalidEquivalenceTerm = or(IMPLICATION, EQUIV);</span>
    /**
     * equivalences and intervals (not implications, they are allowed
     */
<span class="fc" id="L52">    int InvalidImplicationPredicate = or(EQUIV);</span>




    @NotNull
    static Task spawn(Task parent, Compound content, char punctuation, Truth truth, long occ, @NotNull Budget budget) {
<span class="nc" id="L59">        return spawn(parent, content, punctuation, truth, occ, budget.getPriority(), budget.getDurability(), budget.getQuality());</span>
    }

    @NotNull
    static Task spawn(Task parent, Compound content, char punctuation, Truth truth, long occ, float p, float d, float q) {
<span class="nc" id="L64">        return new MutableTask(content, punctuation)</span>
<span class="nc" id="L65">                .truth(truth)</span>
<span class="nc" id="L66">                .budget(p, d, q)</span>
<span class="nc" id="L67">                .parent(parent)</span>
<span class="nc" id="L68">                .occurr(occ);</span>
    }


    /** gets an existing item or applies the builder to produce something to return */
    @Nullable
    default &lt;K extends Term&gt; Termed&lt;K&gt; apply(K key, @NotNull Function&lt;K,Termed&gt; builder) {
<span class="fc" id="L75">        Termed existing = getTermIfPresent(key);</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (existing == null) {</span>
<span class="fc" id="L77">            putTerm(existing = builder.apply(key));</span>
        }
<span class="fc" id="L79">        return existing;</span>
    }

    @Nullable
    TermContainer internSub(TermContainer s);



    void putTerm(Termed termed);

    default TermContainer unifySubterms(TermContainer s) {
<span class="fc" id="L90">        TermVector t = (TermVector)s;</span>
<span class="fc" id="L91">        Term[] x = t.terms();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="fc" id="L93">            Term u = theTerm(x[i]); //since they are equal this will not need re-hashed</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">            if (u.equals(x[i]))</span>
<span class="fc" id="L95">                x[i] = u; //HACK use unified, otherwise keep original</span>
        }
<span class="fc" id="L97">        return s;</span>
    }


    default Termed makeAtomic(Term t) {
<span class="fc" id="L102">        return t; /* as-is */</span>
    }

    default Termed makeTerm(Term t) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">        return t instanceof Compound ?</span>
<span class="fc" id="L107">                makeCompound((Compound) t)</span>
<span class="fc" id="L108">                : makeAtomic(t);</span>
    }


    int subtermsCount();

//    default TermContainer internSubterms(Term[] t) {
//        return new TermVector&lt;&gt;(t, this::the);
//    }


    default Termed makeCompound(@NotNull Compound t) {
<span class="fc" id="L120">        return make(t.op(), t.relation(), t.subterms(), t.t());</span>
    }









//    class ImmediateTermIndex implements TermIndex {
//
//        @Override
//        public Termed get(Object key) {
//            return (Termed)key;
//        }
//
//        @Override
//        public TermContainer getIfAbsentIntern(TermContainer s) {
//            return s;
//        }
//
//        @Override
//        public Termed internAtomic(Term t) {
//            return t;
//        }
//
//        @Override
//        public void forEach(Consumer&lt;? super Termed&gt; c) {
//
//        }
//
//        @Override
//        public Termed getTermIfPresent(Termed t) {
//            return t;
//        }
//
//        @Override
//        public Termed intern(Term tt) {
//            return tt;
//        }
//
//        @Override
//        public int subtermsCount() {
//            return 0;
//        }
//
//
//        @Override
//        public void clear() {
//
//        }
//
//
//        @Override
//        public void putTerm(Termed termed) {
//
//        }
//
//        @Override
//        public int size() {
//            return 0;
//        }
//
//
//    }

//    class GuavaIndex extends GuavaCacheBag&lt;Term,Termed&gt; implements TermIndex {
//
//
//        public GuavaIndex(CacheBuilder&lt;Term, Termed&gt; data) {
//            super(data);
//        }
//
//        @Override
//        public void forEachTerm(Consumer&lt;Termed&gt; c) {
//            data.asMap().forEach((k,v) -&gt; {
//                c.accept(v);
//            });
//        }
//
//
//
//    }

    /** default memory-based (Guava) cache */
    @NotNull
    static TermIndex memory(int capacity) {
//        CacheBuilder builder = CacheBuilder.newBuilder()
//            .maximumSize(capacity);
<span class="fc" id="L211">        return new MapIndex(</span>
            new HashMap(capacity),new HashMap(capacity*2)
            //new UnifriedMap()
        );
//        return new MapIndex2(
//                new HashMap(capacity)
//                //new UnifriedMap()
//        );
    }

//    static GuavaIndex memoryGuava(Clock c, int expirationCycles) {
//        return new GuavaIndex(c, expirationCycles);
////        return new MapIndex(
////
////                new WeakValueHashMap(capacity),
////                new WeakValueHashMap(capacity*2)
////        );
//    }

    default void print(@NotNull PrintStream out) {
<span class="fc" id="L231">        forEach(out::println);</span>
<span class="fc" id="L232">    }</span>

//    /** for long-running processes, this uses
//     * a weak-value policy */
//    static TermIndex memoryAdaptive(int capacity) {
//        CacheBuilder builder = CacheBuilder.newBuilder()
//            .maximumSize(capacity)
//            .recordStats()
//            .weakValues();
//        return new GuavaIndex(builder);
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>