<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TermContainer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.term</a> &gt; <span class="el_source">TermContainer.java</span></div><h1>TermContainer.java</h1><pre class="source lang-java linenums">package nars.term;

import com.gs.collections.api.block.predicate.primitive.IntObjectPredicate;
import com.gs.collections.api.set.MutableSet;
import com.gs.collections.impl.factory.Sets;
import nars.Global;
import nars.Op;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.List;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Predicate;


/**
 * Methods common to both Term and Subterms
 * T = subterm type
 */
public interface TermContainer&lt;T extends Term&gt; extends Termlike, Comparable, Iterable&lt;T&gt; {

    int varDep();

    int varIndep();

    int varQuery();

    int vars();

    /** gets subterm at index i */
    T term(int i);

    default MutableSet&lt;Term&gt; toSet() {
<span class="fc" id="L36">        return Sets.mutable.of(terms());</span>
    }

    static MutableSet&lt;Term&gt; intersect(@NotNull TermContainer a, @NotNull TermContainer b) {
<span class="fc" id="L40">        return Sets.intersect(a.toSet(),b.toSet());</span>
    }



//    static TermSet differ(TermSet a, TermSet b) {
//        if (a.size() == 1 &amp;&amp; b.size() == 1) {
//            //special case
//            return a.term(0).equals(b.term(0)) ?
//                    TermIndex.EmptySet :
//                    a;
//        } else {
//            MutableSet dd = Sets.difference(a.toSet(), b.toSet());
//            if (dd.isEmpty()) return TermIndex.EmptySet;
//            return TermSet.the(dd);
//        }
//    }


    /** returns null if empty set; not sorted */
    @Deprecated static TermSet difference(@NotNull TermContainer a, @NotNull TermContainer b) {

<span class="fc" id="L62">        TreeSet&lt;Term&gt; terms = new TreeSet();</span>

<span class="fc" id="L64">        Term[] aa = a.terms();</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        for(Term x: aa) { //set difference</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            if (!b.containsTerm(x))</span>
<span class="fc" id="L67">                terms.add(x);</span>
        }

<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (terms.isEmpty()) return null;</span>
<span class="fc" id="L71">        return TermSet.the(terms);</span>

//        if (a.size() == 1 &amp;&amp; b.size() == 1) {
//            //special case
//            return a.term(0).equals(b.term(0)) ?
//                    Terms.Empty :
//                    a.terms();
//        } else {
//            MutableSet dd = Sets.difference(a.toSet(), b.toSet());
//            if (dd.isEmpty()) return Terms.Empty;
//            return Terms.toArray(dd);
//        }
    }



    void addAllTo(Collection&lt;Term&gt; set);



    /** expected to provide a non-copy reference to an internal array,
     *  if it exists. otherwise it should create such array.
     *  if this creates a new array, consider using .term(i) to access
     *  subterms iteratively.
     */
    T[] terms();


    @NotNull
    default Term[] terms(@NotNull IntObjectPredicate&lt;T&gt; filter) {
<span class="nc" id="L101">        List&lt;T&gt; l = Global.newArrayList(size());</span>
<span class="nc" id="L102">        int s = size();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (int i = 0; i &lt; s; i++) {</span>
<span class="nc" id="L104">            T t = term(i);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (filter.accept(i, t))</span>
<span class="nc" id="L106">                l.add(t);</span>
        }
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (l.isEmpty()) return Terms.Empty;</span>
<span class="nc" id="L109">        return l.toArray(new Term[l.size()]);</span>
    }


    void forEach(Consumer&lt;? super T&gt; action, int start, int stop);


//    static Term[] copyByIndex(TermContainer c) {
//        int s = c.size();
//        Term[] x = new Term[s];
//        for (int i = 0; i &lt; s; i++) {
//            x[i] = c.term(i);
//        }
//        return x;
//    }


    static String toString(@NotNull TermContainer t) {
<span class="nc" id="L127">        StringBuilder sb = new StringBuilder(&quot;{[(&quot;);</span>
<span class="nc" id="L128">        int s = t.size();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        for (int i = 0; i &lt; s; i++) {</span>
<span class="nc" id="L130">            sb.append(t.term(i));</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if (i &lt; s-1)</span>
<span class="nc" id="L132">                sb.append(&quot;, &quot;);</span>
        }
<span class="nc" id="L134">        sb.append(&quot;)]}&quot;);</span>
<span class="nc" id="L135">        return sb.toString();</span>

    }

    /** extract a sublist of terms as an array */
    @NotNull
    default Term[] terms(int start, int end) {
<span class="nc" id="L142">        Term[] t = new Term[end-start];</span>
<span class="nc" id="L143">        int j = 0;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++)</span>
<span class="nc" id="L145">            t[j++] = term(i);</span>
<span class="nc" id="L146">        return t;</span>
    }

    /** follows normal indexOf() semantics; -1 if not found */
    default int indexOf(@Nullable Term t) {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (t == null)</span>
<span class="nc" id="L152">            throw new RuntimeException(&quot;not found&quot;);</span>
            //return -1;

<span class="fc" id="L155">        int s = size();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (int i = 0; i &lt; s; i++) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (t.equals(term(i)))</span>
<span class="fc" id="L158">                return i;</span>
        }
<span class="fc" id="L160">        return -1;</span>
    }




//    /** writes subterm bytes, including any attached metadata preceding or following it */
//    default void appendSubtermBytes(ByteBuf b) {
//
//        int n = size();
//
//        for (int i = 0; i &lt; n; i++) {
//            Term t = term(i);
//
//            if (i != 0) {
//                b.add(ARGUMENT_SEPARATORbyte);
//            }
//
//            try {
//                byte[] bb = t.bytes();
//                if (bb.length!=t.bytesLength())
//                    System.err.println(&quot;wtf&quot;);
//                b.add(bb);
//            }
//            catch (ArrayIndexOutOfBoundsException a) {
//                System.err.println(&quot;Wtf&quot;);
//            }
//        }
//
//    }

//    @Override
//    default boolean containsTermRecursively(Term target) {
//        if (impossibleSubterm(target))
//            return false;
//
//        for (Term x : terms()) {
//            if (x.equals(target)) return true;
//            if (x instanceof Compound) {
//                if (x.containsTermRecursively(target)) {
//                    return true;
//                }
//            }
//        }
//        return false;
//
//    }

    default boolean equivalent(@NotNull List&lt;Term&gt; sub) {
<span class="nc" id="L209">        int s = size();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (s!=sub.size()) return false;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (int i = 0; i &lt; size(); i++) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (!term(i).equals(sub.get(i))) return false;</span>
        }
<span class="nc" id="L214">        return true;</span>
    }


    /** returns true if evaluates true for any terms
     * @param p*/
    @Override
    default boolean or(Predicate&lt;? super Term&gt; p) {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (Term t : terms()) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (t.or(p))</span>
<span class="fc" id="L224">                return true;</span>
        }
<span class="fc" id="L226">        return false;</span>
    }

    /** returns true if evaluates true for all terms
     * @param p*/
    @Override
    default boolean and(@NotNull Predicate&lt;? super Term&gt; p) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (Term t : terms()) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (!p.test(t)) {</span>
<span class="nc" id="L235">                return false;</span>
            }
        }
<span class="nc" id="L238">        return true;</span>
    }


    static boolean requiresTermSet(@NotNull Op op, int num) {
<span class="fc bfc" id="L243" title="All 4 branches covered.">        return op.isCommutative() &amp;&amp; (num &gt; 1);</span>
    }


    /** produces the correct TermContainer for the given Op,
     * according to the existing type
     */
    @NotNull
    static TermContainer the(@NotNull Op op, @NotNull TermContainer tt) {
<span class="pc bpc" id="L252" title="1 of 4 branches missed.">        return (!requiresTermSet(op, tt.size()) || tt.isSorted()) ? tt :</span>
<span class="nc" id="L253">            TermSet.the(tt.terms());</span>
    }
    @NotNull
    static TermContainer the(@NotNull Op op, @NotNull Collection&lt;? extends Term&gt; tt) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        return requiresTermSet(op, tt.size()) ?</span>
<span class="fc" id="L258">                TermSet.the(tt) : new TermVector(tt);</span>
    }

    @NotNull
    static TermContainer the(@NotNull Op op, @NotNull Term... tt) {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        return requiresTermSet(op, tt.length) ? TermSet.the(tt) :</span>
<span class="fc" id="L264">                new TermVector(tt);</span>
    }

    default boolean isSorted() {
<span class="fc" id="L268">        int s = size();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (s &lt; 2) return true;</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">        for (int i = 1; i &lt; s; i++) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (term(i-1).compareTo(term(i))!=-1)</span>
<span class="fc" id="L273">                return false;</span>
        }
<span class="fc" id="L275">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>