<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ArrayListTaskTable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.concept.util</a> &gt; <span class="el_source">ArrayListTaskTable.java</span></div><h1>ArrayListTaskTable.java</h1><pre class="source lang-java linenums">package nars.concept.util;

import nars.Global;
import nars.Memory;
import nars.budget.BudgetMerge;
import nars.task.Task;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Iterator;
import java.util.List;
import java.util.function.BiPredicate;
import java.util.function.Consumer;

/**
 * implements a Task table suitable for Questions and Quests using an ArrayList.
 * uses a List and assumes that it is an ArrayList that can be
 * accessed by index.
 *
 */
public class ArrayListTaskTable implements QuestionTaskTable {

<span class="fc" id="L23">    protected int capacity = 0;</span>

    @NotNull
    private final List&lt;Task&gt; list;

    public ArrayListTaskTable(int capacity) {
<span class="fc" id="L29">        super();</span>
<span class="fc" id="L30">        this.list = Global.newArrayList(capacity);</span>
<span class="fc" id="L31">        setCapacity(capacity);</span>
<span class="fc" id="L32">    }</span>

    @Override
    public int getCapacity() {
<span class="nc" id="L36">        return capacity;</span>
    }

    //TODO not tested yet
    @Override public void setCapacity(int newCapacity) {
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">        if (this.capacity==newCapacity) return;</span>

<span class="fc" id="L43">        capacity = newCapacity;</span>

<span class="fc" id="L45">        int s = list.size();</span>

<span class="fc" id="L47">        int toRemove = s - capacity;</span>
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">        while (toRemove-- &gt; 0)</span>
<span class="nc" id="L49">            list.remove( --s ); //last element</span>

<span class="fc" id="L51">    }</span>

    @Override
    public int size() {
<span class="fc" id="L55">        return list.size();</span>
    }

    @Override
    public void clear() {
<span class="nc" id="L60">        list.clear();</span>
<span class="nc" id="L61">    }</span>

    @Override
    public boolean isEmpty() {
<span class="fc" id="L65">        return list.isEmpty();</span>
    }


    /**
     * iterator-less implementation
     */
    @Nullable
    @Override
    public Task getFirstEquivalent(Task t, @NotNull BiPredicate&lt;Task,Task&gt; e) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (isEmpty()) return null;</span>

<span class="fc" id="L77">        List&lt;Task&gt; ll = this.list;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (int i = 0; i &lt; ll.size(); i++) {</span>
<span class="fc" id="L79">            Task a = ll.get(i);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">            if (e.test(a, t))</span>
<span class="fc" id="L81">                return a;</span>
        }
<span class="fc" id="L83">        return null;</span>
    }


    @Nullable
    @Override
    public Task add(@NotNull Task t, @NotNull BiPredicate&lt;Task,Task&gt; equality, @NotNull BudgetMerge duplicateMerge, @NotNull Memory m) {

<span class="fc" id="L91">        Task existing = getFirstEquivalent(t, equality);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (existing != null) {</span>

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">            if (existing != t) {</span>
<span class="fc" id="L95">                duplicateMerge.merge(existing.getBudget(), t.getBudget(), 1f);</span>
<span class="fc" id="L96">                m.remove(t, &quot;PreExisting TaskTable Duplicate&quot;);</span>
            }

<span class="fc" id="L99">            return existing;</span>
        }

        //Memory m = c.getMemory();
<span class="fc" id="L103">        int siz = size();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (siz + 1 &gt; capacity) {</span>
            // FIFO, remove oldest question (last)
<span class="fc" id="L106">            /*Task removed = */list.remove(siz - 1);</span>

            //m.remove(removed, &quot;TaskTable FIFO Out&quot;);

            //m.emit(Events.ConceptQuestionRemove.class, c, removed /*, t*/);
        }

<span class="fc" id="L113">        list.add(0, t);</span>

        //m.emit(Events.ConceptQuestionAdd.class, c, t);

<span class="fc" id="L117">        return t;</span>
    }

    @NotNull
    @Override
    public Iterator&lt;Task&gt; iterator() {
<span class="nc" id="L123">        return list.iterator();</span>
    }

    @Override
    public void forEach(@NotNull Consumer&lt;? super Task&gt; action) {
<span class="fc" id="L128">        list.forEach(action);</span>
<span class="fc" id="L129">    }</span>

    //    @Override
//    public final boolean contains(Task t) {
//        //        //equality:
////        //  1. term (given because it is looking up in concept)
////        //  2. truth
////        //  3. occurrence time
////        //  4. evidential set
//
//        if (isEmpty()) return false;
//
//        Truth taskTruth = t.getTruth();
//        long taskOccurrrence = t.getOccurrenceTime();
//        long[] taskEvidence = t.getEvidence();
//
//        Task[] aa = getCachedNullTerminatedArray();
//        for (Task x : aa) {
//
//            if (x == null) return false;
//
//            if (
//
//                //different truth value
//                (x.getTruth().equals(taskTruth)) &amp;&amp;
//
//                //differnt occurence time
//                (x.getOccurrenceTime() == taskOccurrrence) &amp;&amp;
//
//                //differnt evidence
//                (Arrays.equals(x.getEvidence(), taskEvidence))
//            )
//                return true;
//        }
//
//        return false;
//
//    }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>