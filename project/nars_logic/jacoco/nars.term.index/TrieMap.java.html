<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TrieMap.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.term.index</a> &gt; <span class="el_source">TrieMap.java</span></div><h1>TrieMap.java</h1><pre class="source lang-java linenums">package nars.term.index;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * Implements very fast dictionary storage and retrieval. Only depends upon the
 * core String class.
 * 
 * @author Melinda Green - Â© 2010 Superliminal Software. Free for all uses with
 *         attribution.
 */
<span class="nc bnc" id="L13" title="All 2 branches missed.">public class TrieMap {</span>
	/*
	 * Implementation of a trie tree. (see http://en.wikipedia.org/wiki/Trie)
	 * though I made it faster and more compact for long key strings by building
	 * tree nodes only as needed to resolve collisions. Each letter of a key is
	 * the index into the following array. Values stored in the array are either
	 * a Leaf containing the user's value or another TrieMap node if more than
	 * one key shares the key prefix up to that point. Null elements indicate
	 * unused, I.E. available slots.
	 */
<span class="nc" id="L23">	private final Object[] mChars = new Object[256];</span>
	private Object mPrefixVal; // Used only for values of prefix keys.

	// Simple container for a string-value pair.
	private static class Leaf {
		public final String mStr;
		public final Object mVal;
<span class="nc" id="L30">		public Leaf(String str, Object val) {</span>
<span class="nc" id="L31">			mStr = str;</span>
<span class="nc" id="L32">			mVal = val;</span>
<span class="nc" id="L33">		}</span>
	}

	public boolean isEmpty() {
<span class="nc bnc" id="L37" title="All 2 branches missed.">        if(mPrefixVal != null) {</span>
<span class="nc" id="L38">            return false;</span>
        }
<span class="nc bnc" id="L40" title="All 2 branches missed.">        for(Object o : mChars) {</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">            if(o != null) {</span>
<span class="nc" id="L42">                return false;</span>
            }
        }
<span class="nc" id="L45">        return true;</span>
    }
	/**
	 * Inserts a key/value pair.
	 * 
	 * @param key
	 *            may be empty or contain low-order chars 0..255 but must not be
	 *            null.
	 * @param val
	 *            Your data. Any data class except another TrieMap. Null values
	 *            erase entries.
	 */
	public void put(@NotNull String key, Object val) {
<span class="nc bnc" id="L58" title="All 4 branches missed.">        assert key != null;</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">        assert !(val instanceof TrieMap); // Only we get to store TrieMap nodes. TODO: Allow it.</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        if(key.isEmpty()) {</span>
            // All of the original key's chars have been nibbled away 
            // which means this node will store this key as a prefix of other keys.
<span class="nc" id="L63">            mPrefixVal = val; // Note: possibly removes or updates an item.</span>
<span class="nc" id="L64">            return;</span>
        }
<span class="nc" id="L66">        char c = key.charAt(0);</span>
<span class="nc" id="L67">        Object cObj = mChars[c];</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if(cObj == null) { // Unused slot means no collision so just store and return;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if(val == null) {</span>
<span class="nc" id="L70">                return; // Don't create a leaf to store a null value.</span>
            }
<span class="nc" id="L72">            mChars[c] = new Leaf(key, val);</span>
<span class="nc" id="L73">            return;</span>
        }
<span class="nc bnc" id="L75" title="All 2 branches missed.">        if(cObj instanceof TrieMap) {</span>
            // Collided with an existing sub-branch so nibble a char and recurse.
<span class="nc" id="L77">            TrieMap childTrie = (TrieMap)cObj;</span>
<span class="nc" id="L78">            childTrie.put(key.substring(1), val);</span>
<span class="nc bnc" id="L79" title="All 4 branches missed.">            if(val == null &amp;&amp; childTrie.isEmpty()) {</span>
<span class="nc" id="L80">                mChars[c] = null; // put() must have erased final entry so prune branch.</span>
            }
<span class="nc" id="L82">            return;</span>
        }
        // Collided with a leaf 
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if(val == null) {</span>
<span class="nc" id="L86">            mChars[c] = null; // Null value means to remove any previously stored value.</span>
<span class="nc" id="L87">            return;</span>
        }
<span class="nc bnc" id="L89" title="All 4 branches missed.">        assert cObj instanceof Leaf;</span>
        // Sprout a new branch to hold the colliding items.
<span class="nc" id="L91">        Leaf cLeaf = (Leaf)cObj;</span>
<span class="nc" id="L92">        TrieMap branch = new TrieMap();</span>
<span class="nc" id="L93">        branch.put(key.substring(1), val); // Store new value in new subtree.</span>
<span class="nc" id="L94">        branch.put(cLeaf.mStr.substring(1), cLeaf.mVal); // Plus the one we collided with.</span>
<span class="nc" id="L95">        mChars[c] = branch;</span>
<span class="nc" id="L96">    }</span>
	/**
	 * Retrieve a value for a given key or null if not found.
	 */
	@Nullable
    public Object get(@NotNull String key) {
<span class="nc" id="L102">        TrieMap other = this;</span>
        while (true) {
<span class="nc bnc" id="L104" title="All 4 branches missed.">            assert key != null;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (key.isEmpty()) {</span>
                // All of the original key's chars have been nibbled away
                // which means this key is a prefix of another.
<span class="nc" id="L108">                return other.mPrefixVal;</span>
            }
<span class="nc" id="L110">            char c = key.charAt(0);</span>
<span class="nc" id="L111">            Object cVal = other.mChars[c];</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (cVal == null) {</span>
<span class="nc" id="L113">                return null; // Not found.</span>
            }
<span class="nc bnc" id="L115" title="All 6 branches missed.">            assert cVal instanceof Leaf || cVal instanceof TrieMap;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            if (cVal instanceof TrieMap) { // Hash collision. Nibble first char, and recurse.</span>
<span class="nc" id="L117">                key = key.substring(1);</span>
<span class="nc" id="L118">                other = ((TrieMap) cVal);</span>
<span class="nc" id="L119">                continue;</span>
            }
<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (cVal instanceof Leaf) {</span>
                // cVal contains a user datum, but does the key match its substring?
<span class="nc" id="L123">                Leaf cPair = (Leaf) cVal;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                if (key.equals(cPair.mStr)) {</span>
<span class="nc" id="L125">                    return cPair.mVal; // Return user's data value.</span>
                }
            }
<span class="nc" id="L128">            return null; // Not found.</span>
        }
    }
	/**
	 * Simple example test program.
	 */
	public static void main(String[] args) {
		// Insert a bunch of key/value pairs.
<span class="nc" id="L136">		TrieMap trieMap = new TrieMap();</span>
<span class="nc" id="L137">		trieMap.put(&quot;123&quot;, &quot;456&quot;);</span>
<span class="nc" id="L138">		trieMap.put(&quot;Java&quot;, &quot;rocks&quot;);</span>
<span class="nc" id="L139">		trieMap.put(&quot;Melinda&quot;, &quot;too&quot;);</span>
<span class="nc" id="L140">		trieMap.put(&quot;Moo&quot;, &quot;cow&quot;); // Will collide with &quot;Melinda&quot;.</span>
<span class="nc" id="L141">		trieMap.put(&quot;Moon&quot;, &quot;walk&quot;); // Collides with &quot;Melinda&quot; and turns &quot;Moo&quot;</span>
										// into a prefix.
<span class="nc" id="L143">		trieMap.put(&quot;&quot;, &quot;Root&quot;); // You can store one value at the empty key if</span>
									// you like.

		// Test for inserted, nonexistent, and deleted keys.
<span class="nc" id="L147">		System.out.println(&quot;123 = &quot; + trieMap.get(&quot;123&quot;));</span>
<span class="nc" id="L148">		System.out.println(&quot;Java = &quot; + trieMap.get(&quot;Java&quot;));</span>
<span class="nc" id="L149">		System.out.println(&quot;Melinda = &quot; + trieMap.get(&quot;Melinda&quot;));</span>
<span class="nc" id="L150">		System.out.println(&quot;Moo = &quot; + trieMap.get(&quot;Moo&quot;));</span>
<span class="nc" id="L151">		System.out.println(&quot;Moon = &quot; + trieMap.get(&quot;Moon&quot;));</span>
<span class="nc" id="L152">		System.out.println(&quot;Mo = &quot; + trieMap.get(&quot;Mo&quot;)); // Should return null.</span>
<span class="nc" id="L153">		System.out.println(&quot;Empty key = &quot; + trieMap.get(&quot;&quot;)); // Should return</span>
																// &quot;Root&quot;.
<span class="nc" id="L155">		System.out.println(&quot;Moose = &quot; + trieMap.get(&quot;Moose&quot;)); // Never added so</span>
																// should return
																// null.
<span class="nc" id="L158">		System.out.println(&quot;Nothing = &quot; + trieMap.get(&quot;Nothing&quot;)); // Ditto.</span>
<span class="nc" id="L159">		trieMap.put(&quot;123&quot;, null); // Removes this leaf entry.</span>
<span class="nc" id="L160">		System.out.println(&quot;After removal, 123 = &quot; + trieMap.get(&quot;123&quot;)); // Should</span>
																			// now
																			// return
																			// null.
<span class="nc" id="L164">		trieMap.put(&quot;Moo&quot;, null); // Removes this prefix entry. (Special case to</span>
									// test internal logic).
<span class="nc" id="L166">		System.out.println(&quot;After removal, Moo = &quot; + trieMap.get(&quot;Moo&quot;)); // Should</span>
																			// now
																			// return
																			// null.
<span class="nc" id="L170">		trieMap.put(&quot;Moon&quot;, null); // Internal test of branch pruning.</span>
<span class="nc" id="L171">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>