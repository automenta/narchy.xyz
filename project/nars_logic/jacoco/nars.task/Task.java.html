<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Task.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.task</a> &gt; <span class="el_source">Task.java</span></div><h1>Task.java</h1><pre class="source lang-java linenums">/*
 * Task.java
 *
 * Copyright (C) 2008  Pei Wang
 *
 * This file is part of Open-NARS.
 *
 * Open-NARS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Open-NARS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Open-NARS.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package nars.task;

import nars.*;
import nars.budget.Budgeted;
import nars.concept.Concept;
import nars.nal.Tense;
import nars.term.Statement;
import nars.term.Term;
import nars.term.Termed;
import nars.term.compound.Compound;
import nars.truth.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.Serializable;
import java.lang.ref.Reference;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static nars.Global.dereference;

/**
 * A task to be processed, consists of a Sentence and a BudgetValue.
 * A task references its parent and an optional causal factor (usually an Operation instance).  These are implemented as WeakReference to allow forgetting via the
 * garbage collection process.  Otherwise, Task ancestry would grow unbounded,
 * violating the assumption of insufficient resources (AIKR).
 * &lt;p&gt;
 * TODO decide if the Sentence fields need to be Reference&lt;&gt; also
 */
public interface Task extends Budgeted, Truthed, Comparable, Stamp, Termed, Tasked, Supplier&lt;Task&gt; {

    static void getExplanation(@NotNull Task task, int indent, @NotNull StringBuilder sb) {
        //TODO StringBuilder

<span class="fc bfc" id="L58" title="All 2 branches covered.">        for (int i = 0; i &lt; indent; i++)</span>
<span class="fc" id="L59">            sb.append(&quot;  &quot;);</span>


<span class="fc" id="L62">        task.appendTo(sb, null, true);</span>

//        List l = task.getLog();
//        if (l!=null)
//            sb.append(&quot; log=&quot;).append(l);

<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        if (task.getBestSolution() != null) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (!task.term().equals(task.getBestSolution().term())) {</span>
<span class="nc" id="L70">                sb.append(&quot; solution=&quot;);</span>
<span class="nc" id="L71">                task.getBestSolution().appendTo(sb);</span>
            }
        }

<span class="fc" id="L75">        Task pt = task.getParentTask();</span>
<span class="fc" id="L76">        Task pb = task.getParentBelief();</span>
<span class="fc" id="L77">        sb.append('\n');</span>

<span class="fc" id="L79">        sb.append(&quot;  &quot;);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (pt != null) {</span>
            //sb.append(&quot;  PARENT &quot;);
<span class="fc" id="L82">            getExplanation(pt, indent+1, sb);</span>
        }
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (pb != null) {</span>
            //sb.append(&quot;  BELIEF &quot;);
<span class="fc" id="L86">            getExplanation(pb, indent+1, sb);</span>
        }
<span class="fc" id="L88">    }</span>

//    static Set&lt;Truthed&gt; getSentences(Iterable&lt;Task&gt; tasks) {
//
//        int size;
//
//        size = tasks instanceof Collection ? ((Collection) tasks).size() : 2;
//
//        Set&lt;Truthed&gt; s = Global.newHashSet(size);
//        for (Task t : tasks)
//            s.add(t);
//        return s;
//    }

    /** performs some (but not exhaustive) tests on a term to determine some cases where it is invalid as a sentence content
     * returns the compound valid for a Task if so,
     * otherwise returns null
     * */
    static boolean validTaskTerm(Term t) {

<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        if (!(t instanceof Compound))//(t instanceof CyclesInterval) || (t instanceof Variable)</span>
<span class="nc" id="L109">            return false;</span>

<span class="fc" id="L111">        Compound st = (Compound) t;</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (t.op().isStatement()) {</span>

            /* A statement sentence is not allowed to have a independent variable as subj or pred&quot;); */
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (subjectOrPredicateIsIndependentVar(st))</span>
<span class="fc" id="L116">                return false;</span>

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if (Global.DEBUG_PARANOID) {</span>
                //should be checked on statement construction
                //if it occurrs here, that did not happen somewhere prior
<span class="nc bnc" id="L121" title="All 2 branches missed.">                if (Statement.invalidStatement(st.term(0), st.term(1)))</span>
<span class="nc" id="L122">                    throw new RuntimeException(&quot;statement invalidity should be tested before created: &quot; + st);</span>
            }

        }

<span class="fc" id="L127">        return true;</span>
    }

    static float prioritySum(@NotNull Iterable&lt;? extends Budgeted &gt; dd) {
<span class="nc" id="L131">        float f = 0;</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        for (Budgeted  x : dd)</span>
<span class="nc" id="L133">            f += x.getPriority();</span>
<span class="nc" id="L134">        return f;</span>
    }

    static boolean subjectOrPredicateIsIndependentVar(@NotNull Compound t) {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (!t.hasVarIndep()) return false;</span>
<span class="fc bfc" id="L139" title="All 4 branches covered.">        return (t.term(0).op(Op.VAR_INDEP)) || (t.term(1).op(Op.VAR_INDEP));</span>
    }


    @NotNull
<span class="nc" id="L144">    default Task getTask() { return this; }</span>


    /**
     * Get the parent task of a task.
     * It is not guaranteed to remain because it is
     * stored as a Soft or Weak reference so that
     * task ancestry does not grow uncontrollably;
     *
     * instead, we rely on the JVM garbage collector
     * to serve as an enforcer of AIKR
     *
     * @return The task from which the task is derived, or
     * null if it has been forgotten
     */
    @Nullable
    default Task getParentTask() {
<span class="fc" id="L161">        return dereference(getParentTaskRef());</span>
    }

    Reference&lt;Task&gt; getParentTaskRef();


    @Nullable
    Task getParentBelief();

    Reference&lt;Task&gt; getParentBeliefRef();

    /**
     * Check whether different aspects of sentence are equivalent to another one
     *
     * @param that The other judgment
     * @return Whether the two are equivalent
     */
    boolean equivalentTo(Task that, boolean punctuation, boolean term, boolean truth, boolean stamp, boolean creationTime);

    /** called when a Concept processes this Task */
    void onConcept(Concept c);

    @NotNull
    default Task solution(Compound t, char newPunc, Truth solutionTruth, long newOcc, Task question, @NotNull Memory memory) {
<span class="fc" id="L185">        return new MutableTask(t, newPunc)</span>
<span class="fc" id="L186">            .truth(solutionTruth)</span>
<span class="fc" id="L187">            .budget(getPriority(), getDurability(), getQuality())</span>
<span class="fc" id="L188">            .time(memory.time(), newOcc)</span>
<span class="fc" id="L189">            .parent(getParentTaskRef(), getParentBeliefRef())</span>
<span class="fc" id="L190">            .setEvidence(getEvidence())</span>
<span class="fc" id="L191">            .log(new Solution(question));</span>
    }

    char getPunctuation();

    @Nullable
    @Override
    long[] getEvidence();

    @Override
    long getCreationTime();

    @NotNull
    @Override
    Task setCreationTime(long c);

    /**
     * Recognize a Question
     *
     * @return Whether the object is a Question
     */
    default boolean isQuestion() {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        return (getPunctuation() == Symbols.QUESTION);</span>
    }

    /**
     * Recognize a Judgment
     *
     * @return Whether the object is a Judgment
     */
    default boolean isJudgment() {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        return (getPunctuation() == Symbols.JUDGMENT);</span>
    }

    default boolean isGoal() {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        return (getPunctuation() == Symbols.GOAL);</span>
    }

    default boolean isQuest() {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        return (getPunctuation() == Symbols.QUEST);</span>
    }

    default boolean isCommand()  {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        return (getPunctuation() == Symbols.COMMAND);</span>
    }

    default boolean hasQueryVar() {
<span class="fc" id="L238">        return term().hasVarQuery();</span>
    }



    @Nullable
    default StringBuilder appendTo(StringBuilder sb) {
<span class="nc" id="L245">        return appendTo(sb, null);</span>
    }

    @NotNull
    default Task name() {
<span class="nc" id="L250">        return this;</span>
    }

    @Nullable
    default CharSequence toString(@NotNull NAR nar, boolean showStamp) {
<span class="nc" id="L255">        return toString(nar.memory, showStamp);</span>
    }

    @Nullable
    default CharSequence toString(Memory memory, boolean showStamp) {
<span class="fc" id="L260">        return appendTo(new StringBuilder(), memory, showStamp);</span>
    }

    @NotNull
<span class="fc" id="L264">    @Override default public Task get() { return this ;}</span>

    default Termed concept() {
<span class="nc" id="L267">        return term();</span>
    }

    @Override
    Compound term();

    @Override
    Truth getTruth();

    default boolean isQuestOrQuestion() {
<span class="fc bfc" id="L277" title="All 4 branches covered.">        return isQuestion() || isQuest();</span>
    }

    default boolean isJudgmentOrGoal() {
<span class="fc bfc" id="L281" title="All 4 branches covered.">        return isJudgment() || isGoal();</span>
    }

    /** allows for budget feedback that occurrs on revision */
    default void onRevision(Truth truthConclusion) {

<span class="fc" id="L287">    }</span>

    void mulPriority(float factor);

    void setExecuted();

    default float getConfidenceIfTruthOr(float v) {
<span class="nc" id="L294">        Truth t = getTruth();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (t == null) return v;</span>
<span class="nc" id="L296">        return t.getConfidence();</span>
    }

//    default float projectionConfidence(long when, long now) {
//        //TODO avoid creating Truth Values by calculating the confidence directly. then use this in projection's original usage as well
//
//        float factor = TruthFunctions.temporalProjection(getOccurrenceTime(), when, now);
//
//        return factor * getConfidence();
//
//        //return projection(when, now).getConfidence();
//    }


<span class="pc" id="L310">    enum TaskState {</span>
<span class="fc" id="L311">        Anticipated,</span>
<span class="fc" id="L312">        Executed</span>
    }

    @Nullable
    TaskState getState();

    final class Solution extends AtomicReference&lt;Task&gt; {
        Solution(Task referent) {
<span class="fc" id="L320">            super(referent);</span>
<span class="fc" id="L321">        }</span>

        @NotNull
        @Override
        public String toString() {
<span class="fc" id="L326">            return &quot;Solved: &quot; + get();</span>
        }
    }


    @Nullable
    Task getBestSolution();

    @Nullable
    Reference&lt;Task&gt; getBestSolutionRef();



    @Nullable
    default StringBuilder toString(/**@Nullable*/Memory memory) {
<span class="nc" id="L341">        return appendTo(null, memory);</span>
    }

    @Nullable
    default StringBuilder appendTo(@Nullable StringBuilder sb, /**@Nullable*/Memory memory) {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (sb == null) sb = new StringBuilder();</span>
<span class="fc" id="L347">        return appendTo(sb, memory, false);</span>
    }

    @NotNull
    @Deprecated default String toStringWithoutBudget() {
<span class="fc" id="L352">        return toStringWithoutBudget(null);</span>
    }

    @NotNull
    @Deprecated default String toStringWithoutBudget(Memory memory) {
<span class="fc" id="L357">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L358">        appendTo(b, memory, true, false,</span>
                false, //budget
                false//log
        );
<span class="fc" id="L362">        return b.toString();</span>
    }

    @Nullable
    @Deprecated
    default StringBuilder appendTo(StringBuilder buffer, /**@Nullable*/ Memory memory, boolean showStamp) {
<span class="fc bfc" id="L368" title="All 2 branches covered.">        boolean notCommand = getPunctuation()!=Symbols.COMMAND;</span>
<span class="pc bpc" id="L369" title="1 of 4 branches missed.">        return appendTo(buffer, memory, true, showStamp &amp;&amp; notCommand,</span>
                notCommand, //budget
                showStamp //log
        );
    }

    @Nullable
    default StringBuilder appendTo(@Nullable StringBuilder buffer, /**@Nullable*/@Nullable Memory memory, boolean term, boolean showStamp, boolean showBudget, boolean showLog) {


        String contentName;
<span class="fc" id="L380">        Compound t = term();</span>
<span class="pc bpc" id="L381" title="2 of 4 branches missed.">        contentName = term &amp;&amp; t != null ? t.toString() : &quot;&quot;;</span>

        CharSequence tenseString;
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (memory!=null) {</span>
<span class="fc" id="L385">            tenseString = getTense(memory.time(), memory.duration());</span>
        }
        else {
            //TODO dont bother craeting new StringBuilder and calculating the entire length etc.. just append it to a reusable StringReader?
<span class="fc" id="L389">            appendOccurrenceTime(</span>
                    (StringBuilder)(tenseString = new StringBuilder()));
        }


<span class="fc bfc" id="L394" title="All 2 branches covered.">        CharSequence stampString = showStamp ? stampAsStringBuilder() : null;</span>

<span class="fc" id="L396">        int stringLength = contentName.length() + tenseString.length() + 1 + 1;</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (getTruth() != null)</span>
<span class="fc" id="L399">            stringLength += 11;</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (showStamp)</span>
<span class="fc" id="L402">            stringLength += stampString.length()+1;</span>

        /*if (showBudget)*/
        //&quot;$0.8069;0.0117;0.6643$ &quot;
<span class="fc" id="L406">        stringLength += 1 + 6 + 1 + 6 + 1 + 6 + 1  + 1;</span>

        String finalLog;
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (showLog) {</span>
<span class="fc" id="L410">            Object ll = getLogLast();</span>

<span class="fc bfc" id="L412" title="All 2 branches covered.">            finalLog = (ll!=null ? ll.toString() : null);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            if (finalLog!=null)</span>
<span class="fc" id="L414">                stringLength += finalLog.length()+1;</span>
            else
<span class="fc" id="L416">                showLog = false;</span>
<span class="fc" id="L417">        }</span>
        else
<span class="fc" id="L419">            finalLog = null;</span>


<span class="pc bpc" id="L422" title="1 of 2 branches missed.">        if (buffer == null)</span>
<span class="nc" id="L423">            buffer = new StringBuilder(stringLength);</span>
        else
<span class="fc" id="L425">            buffer.ensureCapacity(stringLength);</span>


<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (showBudget) {</span>
<span class="fc" id="L429">            getBudget().toBudgetStringExternal(buffer).append(' ');</span>
        }

<span class="fc" id="L432">        buffer.append(contentName).append(getPunctuation());</span>

<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (tenseString.length() &gt; 0)</span>
<span class="fc" id="L435">            buffer.append(' ').append(tenseString);</span>

<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (getTruth()!= null) {</span>
<span class="fc" id="L438">            buffer.append(' ');</span>
<span class="fc" id="L439">            getTruth().appendString(buffer, 2);</span>
        }

<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (showStamp)</span>
<span class="fc" id="L443">            buffer.append(' ').append(stampString);</span>

<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (showLog) {</span>
<span class="fc" id="L446">            buffer.append(' ').append(finalLog);</span>
        }

<span class="fc" id="L449">        return buffer;</span>
    }

    @Nullable
    default Object getLogLast() {
<span class="fc" id="L454">        List&lt;String&gt; log = getLog();</span>
<span class="pc bpc" id="L455" title="1 of 4 branches missed.">        if (log ==null || log.isEmpty()) return null;</span>
<span class="fc" id="L456">        return log.get(log.size()-1);</span>
    }


    default boolean hasParent(Task t) {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (getParentTask() == null)</span>
<span class="nc" id="L462">            return false;</span>
<span class="nc" id="L463">        Task p = getParentTask();</span>
        do {
<span class="nc" id="L465">            Task n = p.getParentTask();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (n == null) break;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (n.equals(t))</span>
<span class="nc" id="L468">                return true;</span>
<span class="nc" id="L469">            p = n;</span>
<span class="nc" id="L470">        } while (true);</span>
<span class="nc" id="L471">        return false;</span>
    }

    @Nullable
    default Task getRootTask() {
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (getParentTask() == null) {</span>
<span class="nc" id="L477">            return null;</span>
        }
<span class="nc" id="L479">        Task p = getParentTask();</span>
        do {
<span class="nc" id="L481">            Task n = p.getParentTask();</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (n == null) break;</span>
<span class="nc" id="L483">            p = n;</span>
<span class="nc" id="L484">        } while (true);</span>
<span class="nc" id="L485">        return p;</span>
    }


    @NotNull
    default String getExplanation() {
<span class="fc" id="L491">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L492">        return getExplanation(sb).toString();</span>
    }

    @NotNull
    default StringBuilder getExplanation(@NotNull StringBuilder temporary) {
<span class="fc" id="L497">        temporary.setLength(0);</span>
<span class="fc" id="L498">        getExplanation(this, 0, temporary);</span>
<span class="fc" id="L499">        return temporary;</span>
    }

    default Truth getDesire() {
<span class="nc" id="L503">        return getTruth();</span>
    }



    /** append a log entry; returns this task */
    @NotNull
    Task log(Object entry);

    /** append log entries; returns this task */
    @NotNull
    Task log(List entries);

    /** get the recorded log entries */
    @Nullable
    List getLog();


    //TODO make a Source.{ INPUT, SINGLE, DOUBLE } enum

    /** is double-premise */
    boolean isDouble();

    /** is single premise */
    boolean isSingle();

    /**
     * Check if a Task is a direct input,
     * or if its origin has been forgotten or never known
     */
    default boolean isInput() {
<span class="fc bfc" id="L534" title="All 2 branches covered.">        return getParentTask() == null;</span>
    }


    /**
     * a task is considered amnesiac (origin not rememebered) if its parent task has been forgotten (garbage collected via a soft/weakref)
     */
    default boolean isAmnesiac() {
<span class="nc bnc" id="L542" title="All 4 branches missed.">        return !isInput() &amp;&amp; getParentTask() == null;</span>
    }


    /** if unnormalized, returns a normalized version of the task,
     *  null if not normalizable
     */
    @Nullable
    Task normalize(Memory memory);


    default void ensureValidParentTaskRef() {
<span class="pc bpc" id="L554" title="1 of 4 branches missed.">        if ((getParentTaskRef() != null &amp;&amp; getParentTask() == null))</span>
<span class="nc" id="L555">            throw new RuntimeException(&quot;parentTask must be null itself, or reference a non-null Task&quot;);</span>
<span class="fc" id="L556">    }</span>


    void setTruth(Truth t);

    void setBestSolution(Task belief);



    /** normalize a collection of tasks to each other
     * so that the aggregate budget sums to a provided
     * normalization amount.
     * @param derived
     * @param premisePriority the total value that the derivation group should reach, effectively a final scalar factor determined by premise parent and possibly existing belief tasks
     * @return the input collection, unmodified (elements may be adjusted individually)
     */
    static void normalizeCombined(@NotNull Iterable&lt;Task&gt; derived, float premisePriority) {


<span class="nc" id="L575">        float totalDerivedPriority = prioritySum(derived);</span>
<span class="nc" id="L576">        float factor = Math.min(</span>
                    premisePriority/totalDerivedPriority,
                    1.0f //limit to only diminish
                );

<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (!Float.isFinite(factor))</span>
<span class="nc" id="L582">            throw new RuntimeException(&quot;NaN&quot;);</span>

<span class="nc" id="L584">        derived.forEach(t -&gt; t.getBudget().mulPriority(factor));</span>
<span class="nc" id="L585">    }</span>

    static void normalize(@NotNull Iterable&lt;Task&gt; derived, float premisePriority) {
<span class="nc" id="L588">        derived.forEach(t -&gt; t.getBudget().mulPriority(premisePriority));</span>
<span class="nc" id="L589">    }</span>
    static void inputNormalized(@NotNull Iterable&lt;Task&gt; derived, float premisePriority, @NotNull Consumer&lt;Task&gt; target) {
<span class="fc" id="L591">        derived.forEach(t -&gt; {</span>
<span class="fc" id="L592">            t.getBudget().mulPriority(premisePriority);</span>
<span class="fc" id="L593">            target.accept(t);</span>
<span class="fc" id="L594">        });</span>
<span class="fc" id="L595">    }</span>

    @NotNull
    static Task command(Compound op) {
        //TODO use lightweight CommandTask impl without all the logic metadata
<span class="fc" id="L600">        return new MutableTask(op, Symbols.COMMAND);</span>
    }

    default boolean isEternal() {
<span class="fc bfc" id="L604" title="All 2 branches covered.">        return getOccurrenceTime()== Tense.ETERNAL;</span>
    }


    @NotNull
    default StringBuilder appendOccurrenceTime(@NotNull StringBuilder sb) {
<span class="fc" id="L610">        long oc = getOccurrenceTime();</span>
<span class="fc" id="L611">        long ct = getCreationTime();</span>

        /*if (oc == Stamp.TIMELESS)
            throw new RuntimeException(&quot;invalid occurrence time&quot;);*/
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        if (ct == Tense.ETERNAL)</span>
<span class="nc" id="L616">            throw new RuntimeException(&quot;invalid creation time&quot;);</span>

        //however, timeless creation time means it has not been perceived yet

<span class="fc bfc" id="L620" title="All 2 branches covered.">        if (oc == Tense.ETERNAL) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (ct == Tense.TIMELESS) {</span>
<span class="fc" id="L622">                sb.append(&quot;:-:&quot;);</span>
            } else {
<span class="fc" id="L624">                sb.append(':').append(Long.toString(ct)).append(':');</span>
            }

<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        } else if (oc == Tense.TIMELESS) {</span>
<span class="nc" id="L628">            sb.append(&quot;N/A&quot;);</span>

        } else {
<span class="fc" id="L631">            int estTimeLength = 8; /* # digits */</span>
<span class="fc" id="L632">            sb.ensureCapacity(estTimeLength);</span>

<span class="fc" id="L634">            sb.append(Long.toString(ct));</span>

<span class="fc" id="L636">            long OCrelativeToCT = (oc - ct);</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            if (OCrelativeToCT &gt;= 0)</span>
<span class="fc" id="L638">                sb.append('+'); //+ sign if positive or zero, negative sign will be added automatically in converting the int to string:</span>
<span class="fc" id="L639">            sb.append(OCrelativeToCT);</span>

        }

<span class="fc" id="L643">        return sb;</span>
    }

    default String getTense(long currentTime, int duration) {

<span class="fc" id="L648">        long ot = getOccurrenceTime();</span>

<span class="fc bfc" id="L650" title="All 2 branches covered.">        if (Tense.isEternal(ot)) {</span>
<span class="fc" id="L651">            return &quot;&quot;;</span>
        }

<span class="fc bfc" id="L654" title="All 3 branches covered.">        switch (Tense.order(currentTime, ot, duration)) {</span>
            case 1:
<span class="fc" id="L656">                return Symbols.TENSE_FUTURE;</span>
            case -1:
<span class="fc" id="L658">                return Symbols.TENSE_PAST;</span>
            default:
<span class="fc" id="L660">                return Symbols.TENSE_PRESENT;</span>
        }
    }

    @NotNull
    default CharSequence stampAsStringBuilder() {

<span class="fc" id="L667">        long[] ev = getEvidence();</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">        int len = ev != null ? ev.length : 0;</span>
<span class="fc" id="L669">        int estimatedInitialSize = 8 + (len * 3);</span>

<span class="fc" id="L671">        StringBuilder buffer = new StringBuilder(estimatedInitialSize);</span>
<span class="fc" id="L672">        buffer.append(Symbols.STAMP_OPENER);</span>

<span class="pc bpc" id="L674" title="1 of 2 branches missed.">        if (getCreationTime() == Tense.TIMELESS) {</span>
<span class="nc" id="L675">            buffer.append('?');</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">        } else if (!Tense.isEternal(getOccurrenceTime())) {</span>
<span class="fc" id="L677">            appendOccurrenceTime(buffer);</span>
        } else {
<span class="fc" id="L679">            buffer.append(getCreationTime());</span>
        }
<span class="fc" id="L681">        buffer.append(Symbols.STAMP_STARTER).append(' ');</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>

<span class="fc" id="L684">            buffer.append(Long.toString(ev[i], 36));</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (i &lt; (len - 1)) {</span>
<span class="fc" id="L686">                buffer.append(Symbols.STAMP_SEPARATOR);</span>
            }
        }

<span class="fc" id="L690">        buffer.append(Symbols.STAMP_CLOSER); //.append(' ');</span>

        //this is for estimating an initial size of the stringbuffer
        //System.out.println(baseLength + &quot; &quot; + derivationChain.size() + &quot; &quot; + buffer.baseLength());

<span class="fc" id="L695">        return buffer;</span>


    }


    /** creates a new child task (has this task as its parent) */
    @NotNull
    default MutableTask spawn(Compound content, char punc) {
<span class="nc" id="L704">        return new MutableTask(content, punc);</span>
    }

    default long getOccurrenceTime() {
<span class="nc" id="L708">        return Tense.ETERNAL;</span>
    }

<span class="nc" id="L711">    default long start() { return getOccurrenceTime(); }</span>
    default long end() {
<span class="nc" id="L713">        return start() + duration();</span>
    }
    default int duration() {
<span class="nc" id="L716">        return 0;</span>
    }




    //projects the truth to a certain time, covering all 4 cases as discussed in
    //https://groups.google.com/forum/#!searchin/open-nars/task$20eteneral/open-nars/8KnAbKzjp4E/rBc-6V5pem8J
    default Truth projection(long targetTime, long now) {

<span class="fc" id="L726">        Truth currentTruth = getTruth();</span>
<span class="fc" id="L727">        long occurrenceTime = getOccurrenceTime();</span>

<span class="fc bfc" id="L729" title="All 2 branches covered.">        boolean eternal = targetTime == Tense.ETERNAL;</span>
<span class="fc" id="L730">        boolean tenseEternal = Tense.isEternal(occurrenceTime);</span>
<span class="pc bpc" id="L731" title="1 of 6 branches missed.">        if (eternal ? tenseEternal : tenseEternal) {</span>
<span class="fc" id="L732">            return currentTruth;</span>
            //return new DefaultTruth(currentTruth);                 //target and itself is eternal so return the truth of itself
        }
<span class="pc bpc" id="L735" title="3 of 4 branches missed.">        else if (eternal &amp;&amp; !tenseEternal) { //target is eternal, but ours isnt, so we need to eternalize it</span>
<span class="nc" id="L736">            return TruthFunctions.eternalize(currentTruth);</span>
        }
        else {
            //ok last option is that both are tensed, in this case we need to project to the target time
            //but since also eternalizing is valid, we use the stronger one.
<span class="fc" id="L741">            DefaultTruth eternalTruth = TruthFunctions.eternalize(currentTruth);</span>

<span class="fc" id="L743">            float factor = TruthFunctions.temporalProjection(occurrenceTime, targetTime, now);</span>

<span class="fc" id="L745">            float projectedConfidence = factor * currentTruth.getConfidence();</span>

<span class="fc bfc" id="L747" title="All 2 branches covered.">            return projectedConfidence &gt; eternalTruth.getConfidence() ? new DefaultTruth(currentTruth.getFrequency(), projectedConfidence) : eternalTruth;</span>
        }
    }

<span class="nc" id="L751">    final class ExpectationComparator implements Comparator&lt;Task&gt;, Serializable {</span>
<span class="nc" id="L752">        static final Comparator the = new ExpectationComparator();</span>
        @Override public int compare(@NotNull Task b, @NotNull Task a) {
<span class="nc" id="L754">            return Float.compare(a.getExpectation(), b.getExpectation());</span>
        }
    }

<span class="nc" id="L758">    final class ConfidenceComparator implements Comparator&lt;Task&gt;, Serializable {</span>
<span class="nc" id="L759">        static final Comparator the = new ExpectationComparator();</span>
        @Override public int compare(@NotNull Task b, @NotNull Task a) {
<span class="nc" id="L761">            return Float.compare(a.getConfidence(), b.getConfidence());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>