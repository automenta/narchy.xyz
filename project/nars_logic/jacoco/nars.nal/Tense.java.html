<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Tense.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.nal</a> &gt; <span class="el_source">Tense.java</span></div><h1>Tense.java</h1><pre class="source lang-java linenums">package nars.nal;

import nars.Global;
import nars.Memory;
import nars.task.Task;
import nars.task.Temporal;
import nars.term.compound.Compound;
import nars.truth.Stamp;
import nars.truth.Truth;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import static nars.nal.UtilityFunctions.or;

<span class="pc" id="L15">public enum Tense  {</span>

<span class="fc" id="L17">    Eternal(&quot;:-:&quot;),</span>
<span class="fc" id="L18">    Past(&quot;:\\:&quot;),</span>
<span class="fc" id="L19">    Present(&quot;:|:&quot;),</span>
<span class="fc" id="L20">    Future(&quot;:/:&quot;);</span>

    @Nullable
<span class="fc" id="L23">    public static final Tense Unknown = null;</span>


    /**
     * default for atemporal events
     * means &quot;always&quot; in Judgment/Question, but &quot;current&quot; in Goal/Quest
     */
    public static final long ETERNAL = Long.MIN_VALUE;

    @Deprecated public static final int ITERNAL = Integer.MIN_VALUE;


    /**
     * flag for an unknown time, or as-yet-un-perceived time,
     * signalling a missing value to set to some default
     * if eventually perceived or derived
     */
    public static final long TIMELESS = Long.MIN_VALUE + 1;


    public final String symbol;

<span class="fc" id="L45">    Tense(String string) {</span>
<span class="fc" id="L46">        symbol = string;</span>
<span class="fc" id="L47">    }</span>




//    public static boolean containsMentalOperator(final Task t) {
//        return containsMentalOperator(t.getTerm(), true);
//        /*
//        if(!(t.term instanceof Operation))
//            return false;
//
//        Operation o= (Operation)t.term;
//        return (o.getOperator() instanceof Mental);
//        */
//    }
//
//    public static boolean containsMentalOperator(Term t, boolean recurse) {
//        if (t instanceof Operation) {
//            //Operation o = (Operation) t;
//            //if (o.getOperatorTerm() instanceof Mental) return true;
//        }
//        if ((recurse) &amp;&amp; (t instanceof Compound)) {
//            Compound ct = (Compound)t;
//            int l = ct.size();
//            for (int i = 0; i &lt; l; i++) {
//                Term s = ct.term(i);
//                if (containsMentalOperator(s, true)) return true;
//            }
//        }
//
//        return false;
//    }

    /**
     * Evaluate the quality of the judgment as a solution to a problem
     *
     * @param problem A goal or question
     * @param solution The solution to be evaluated
     * @return The quality of the judgment as the solution
     */
    public static float solutionQuality(@NotNull Task problem, @NotNull Task solution, long time, int duration) {
<span class="fc" id="L88">        float om = orderMatch(problem.term(), solution.term(), duration);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (om == 0) return 0f;</span>
<span class="fc" id="L90">        return om * solutionQualityMatchingOrder(problem, solution, time);</span>
    }

    /** degree to which the temporal relations of the two terms match */
    public static float orderMatch(@NotNull Compound a, @NotNull Compound b, int duration) {
<span class="fc" id="L95">        float fduration = (float)duration;</span>

<span class="fc" id="L97">        int at = a.t();</span>
<span class="fc" id="L98">        int bt = b.t();</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (at == bt) return 1f;</span>

<span class="fc" id="L101">        float ad = at /fduration;</span>
<span class="fc" id="L102">        float bd = bt /fduration;</span>
<span class="fc" id="L103">        return Math.min(0f, 1f - Math.abs(ad-bd)/((ad+bd)/2f));</span>

    }

    public static float solutionQualityMatchingOrder(@NotNull Task problem, @NotNull Task solution, long time) {
<span class="fc" id="L108">        return solutionQualityMatchingOrder(problem, solution, time, problem.hasQueryVar() );</span>
    }

    public static float solutionQualityMatchingOrder(@NotNull final Task problem, @NotNull final Task solution, final long time, final boolean hasQueryVar) {

<span class="fc" id="L113">        long poc = problem.getOccurrenceTime();</span>

        //TODO avoid creating new Truth instances
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        Truth truth = (poc != solution.getOccurrenceTime()) ?</span>
<span class="nc" id="L117">                solution.projection(poc, time) :</span>
<span class="fc" id="L118">                solution.getTruth();</span>

        //if (problem.hasQueryVar()) {
<span class="fc" id="L121">        float originality = solution.getOriginality();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        return hasQueryVar ?</span>
<span class="fc" id="L123">                or(originality, truth.getExpectation() / solution.term().complexity()) :</span>
<span class="fc" id="L124">                or(originality, truth.getConfidence());</span>
    }

//    /**
//        this method is used if the order is known to be matching, so it is not checked
//     */
//    public static float solutionQualityMatchingOrderOLD(Task problem, Task solution, long time, boolean hasQueryVar) {
//
//        /*if ((problem == null) || (solution == null)) {
//            throw new RuntimeException(&quot;problem or solution is null&quot;);
//        }*/
//
//        long poc = problem.getOccurrenceTime();
//        Truth truth = poc != solution.getOccurrenceTime() ? solution.projection(poc, time) : solution.getTruth();
//
//        //if (problem.hasQueryVar()) {
//        return hasQueryVar ? truth.getExpectation() / solution.term().complexity() : truth.getConfidence();
//    }

//    public static float solutionQuality(boolean hasQueryVar, long occTime, Task solution, Truth projectedTruth, long time) {
//        return solution.projectionTruthQuality(projectedTruth, occTime, time, hasQueryVar);
//    }

    public static int order(float timeDiff, int durationCycles) {
<span class="fc" id="L148">        float halfDuration = durationCycles / 2.0f;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (timeDiff &gt;= halfDuration) {</span>
<span class="fc" id="L150">            return +1;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        } else if (timeDiff &lt;= -halfDuration) {</span>
<span class="fc" id="L152">            return -1;</span>
        } else {
<span class="fc" id="L154">            return 0;</span>
        }
    }

    /**
     * if (relative) event B after (stationary) event A then order=forward;
     * event B before       then order=backward
     * occur at the same time, relative to duration: order = concurrent
     */
    public static int order(long a, long b, int durationCycles) {
<span class="pc bpc" id="L164" title="2 of 4 branches missed.">        if ((a == ETERNAL) || (b == ETERNAL))</span>
<span class="nc" id="L165">            throw new RuntimeException(&quot;order() does not compare ETERNAL times&quot;);</span>

<span class="fc" id="L167">        return order(b - a, durationCycles);</span>
    }

//    public static boolean concurrent(Temporal a, Temporal b, int durationCycles) {
//        return concurrent(a.getOccurrenceTime(), b.getOccurrenceTime(), durationCycles);
//    }

//    /**
//     * whether two times are concurrent with respect ao a specific duration (&quot;present moment&quot;) # of cycles
//     */
//    public static boolean concurrent(long a, long b, int perceptualDuration) {
//        //since Stamp.ETERNAL is Integer.MIN_VALUE,
//        //avoid any overflow errors by checking eternal first
//
//        if (a == ETERNAL) {
//            //if both are eternal, consider concurrent.  this is consistent with the original
//            //method of calculation which compared equivalent integer values only
//            return (b == ETERNAL);
//        } else if (b == ETERNAL) {
//            return false; //a==b was compared above
//        } else {
//            return order(a, b, perceptualDuration) == 0;
//        }
//    }

    public static boolean before(long a, long b, int perceptualDuration) {
<span class="nc" id="L193">        return after(b, a, perceptualDuration);</span>
    }

    /** true if B is after A */
    public static boolean after(long a, long b, int perceptualDuration) {
<span class="pc bpc" id="L198" title="2 of 4 branches missed.">        if (a == ETERNAL || b == ETERNAL)</span>
<span class="nc" id="L199">            return false;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        return order(a, b, perceptualDuration) &gt; 0;</span>
    }

    public static boolean isEternal(long t)  {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        return t &lt;= TIMELESS; /* includes ETERNAL */</span>
    }

    public static long getOccurrenceTime(@NotNull Tense tense, @NotNull Memory m) {
<span class="fc" id="L208">        return getOccurrenceTime(m.time(), tense, m.duration());</span>
    }

    public static long getOccurrenceTime(long creationTime, @NotNull Tense tense, @NotNull Memory m) {
<span class="fc" id="L212">        return getOccurrenceTime(creationTime, tense, m.duration());</span>
    }

    public static long getOccurrenceTime(long creationTime, @NotNull Tense tense, int duration) {

<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (creationTime == TIMELESS) {</span>
            //in this case, occurenceTime must be considered relative to whatever creationTime will be set when perceived
            //so we base it at zero to make this possible
<span class="nc" id="L220">            creationTime = 0;</span>
        }

<span class="pc bfc" id="L223" title="All 4 branches covered.">        switch (tense) {</span>
            case Present:
<span class="fc" id="L225">                return creationTime;</span>
            case Past:
<span class="fc" id="L227">                return creationTime - duration;</span>
            case Future:
<span class="fc" id="L229">                return creationTime + duration;</span>
            default:
            //case Unknown:
            //case Eternal:
<span class="fc" id="L233">                return ETERNAL;</span>
        }
    }

    /** inner between: time difference of later.start() - earlier.end() */
    public static int between(@NotNull Temporal task, @NotNull Temporal belief) {
<span class="nc" id="L239">        long tStart = task.start();</span>
<span class="nc" id="L240">        long bStart = belief.start();</span>

<span class="nc bnc" id="L242" title="All 2 branches missed.">        Temporal earlier = tStart &lt;= bStart ? task : belief;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        Temporal later = earlier == task ? belief : task;</span>

<span class="nc" id="L245">        long a = earlier.end();</span>
<span class="nc" id="L246">        long b = later.start();</span>

<span class="nc" id="L248">        return (int)(b-a);</span>
    }

    /** true if there is a non-zero overlap interval of the tasks */
    public static boolean overlaps(@NotNull Task a, @NotNull Task b) {
<span class="nc" id="L253">        return overlaps(a.start(), a.end(), b.start(), b.end());</span>
    }

    public static boolean overlaps(long xStart, long xEnd, long yStart, long yEnd) {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        return Math.max(xStart,yStart) &lt;= Math.min(xEnd,yEnd);</span>
    }

    /**
     * true if there are any common elements; assumes the arrays are sorted and contain no duplicates
     */
    public static boolean overlapping(@NotNull long[] a, @NotNull long[] b) {

<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (Global.DEBUG) {</span>
<span class="pc bpc" id="L266" title="2 of 4 branches missed.">            if (a.length == 0 || b.length == 0) {</span>
<span class="nc" id="L267">                throw new RuntimeException(&quot;missing evidence&quot;);</span>
            }
        }
        /** TODO there may be additional ways to exit early from this loop */

<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (long x : a) {</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">            for (long y : b) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">                if (x == y) {</span>
<span class="fc" id="L275">                    return true;</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                } else if (y &gt; x) {</span>
                    //any values after y in b will not be equal to x
<span class="fc" id="L278">                    break;</span>
                }
            }
        }
<span class="fc" id="L282">        return false;</span>
    }

    public static boolean overlapping(@NotNull Stamp a, @Nullable Stamp b) {

<span class="fc" id="L287">        long[] ae = a.getEvidence();</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (b == null) return false;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (a == b) return true;</span>

<span class="fc" id="L291">        return overlapping(ae, b.getEvidence());</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L296">        return symbol;</span>
    }
    
//    protected static final Map&lt;String, Tense&gt; stringToTense;
//
//    static {
//        Map&lt;String, Tense&gt; stt = new HashMap(Tense.values().length*2);
//        for (Tense t : Tense.values()) {
//            stt.put(t.toString(), t);
//        }
//        stringToTense = Collections.unmodifiableMap( stt );
//    }
//
//    public static Tense tense(String s) {
//        return stringToTense.get(s);
//    }

}

//TODO make an enum for these Orders


//    static int reverseOrder(final int order) {
//
//        if (order == ORDER_INVALID) {
//            throw new RuntimeException(&quot;ORDER_INVALID not handled here&quot;);
//        }
//
//        if (order == ORDER_NONE) {
//            return ORDER_NONE;
//        } else {
//            return -order;
//        }
//    }


//    static int dedExeOrder(final int order1, final int order2) {
//        if ((order1 == order2) || (order2 == Temporal.ORDER_NONE)) {
//            return order1;
//        } else if ((order1 == Temporal.ORDER_NONE) || (order1 == Temporal.ORDER_CONCURRENT)) {
//            return order2;
//        } else if (order2 == Temporal.ORDER_CONCURRENT) {
//            return order1;
//        }
//        return ORDER_INVALID;
//    }

//    static int abdIndComOrder(final int order1, final int order2) {
//        if (order2 == Temporal.ORDER_NONE) {
//            return order1;
//        } else if ((order1 == Temporal.ORDER_NONE) || (order1 == Temporal.ORDER_CONCURRENT)) {
//            return reverseOrder(order2);
//        } else if ((order2 == Temporal.ORDER_CONCURRENT) || (order1 == -order2)) {
//            return order1;
//        }
//        return ORDER_INVALID;
//    }

//    static int analogyOrder(final int order1, final int order2, final int figure) {
//
//        if ((order2 == Temporal.ORDER_NONE) || (order2 == Temporal.ORDER_CONCURRENT)) {
//            return order1;
//        } else if ((order1 == Temporal.ORDER_NONE) || (order1 == Temporal.ORDER_CONCURRENT)) {
//            return (figure &lt; 20) ? order2 : reverseOrder(order2);
//        } else if (order1 == order2) {
//            if ((figure == 12) || (figure == 21)) {
//                return order1;
//            }
//        } else if ((order1 == -order2)) {
//            if ((figure == 11) || (figure == 22)) {
//                return order1;
//            }
//        }
//        return ORDER_INVALID;
//    }

//    final int resemblanceOrder(final int order1, final int order2, final int figure) {
//        if ((order2 == Temporal.ORDER_NONE)) {
//            return (figure &gt; 20) ? order1 : reverseOrder(order1); // switch when 11 or 12
//        } else if ((order1 == Temporal.ORDER_NONE) || (order1 == Temporal.ORDER_CONCURRENT)) {
//            return (figure % 10 == 1) ? order2 : reverseOrder(order2); // switch when 12 or 22
//        } else if (order2 == Temporal.ORDER_CONCURRENT) {
//            return (figure &gt; 20) ? order1 : reverseOrder(order1); // switch when 11 or 12
//        } else if (order1 == order2) {
//            return (figure == 21) ? order1 : -order1;
//        }
//        return ORDER_INVALID;
//    }

//    final int composeOrder(final int order1, final int order2) {
//        if (order2 == Temporal.ORDER_NONE) {
//            return order1;
//        } else if (order1 == Temporal.ORDER_NONE) {
//            return order2;
//        } else if (order1 == order2) {
//            return order1;
//        }
//        return ORDER_INVALID;
//    }

//    /**
//     * whether temporal induction can generate a task by avoiding producing wrong terms; only one temporal operate is allowed
//     */
//    public final static boolean tooMuchTemporalStatements(final Term t, int maxTemporalRelations) {
//        return (t == null) || (t.containedTemporalRelations() &gt; maxTemporalRelations);
//    }
//
//    //is input or by the system triggered operation
//    public static boolean isInputOrTriggeredOperation(final Task newEvent) {
//        if (newEvent.isInput()) return true;
//        if (containsMentalOperator(newEvent)) return true;
//        if (newEvent.getCause() != null) return true;
//        return false;
//    }


//
//    public static long applyExpectationOffset(final Term temporalStatement, final long occurrenceTime) {
//        if (occurrenceTime == Stamp.ETERNAL) return Stamp.ETERNAL;
//
//        if (temporalStatement != null &amp;&amp; temporalStatement instanceof Implication) {
//            Implication imp = (Implication) temporalStatement;
//            if (imp.getSubject() instanceof Conjunction &amp;&amp; imp.getTemporalOrder() == Temporal.ORDER_FORWARD) {
//                Conjunction conj = (Conjunction) imp.getSubject();
//                if (conj.term[conj.term.length - 1] instanceof Interval) {
//                    Interval intv = (Interval) conj.term[conj.term.length - 1];
//                    long time_offset = intv.duration();
//                    return (occurrenceTime + time_offset);
//                }
//            }
//        }
//        return Stamp.ETERNAL;
//    }


//    /**
//     * whether a term can be used in temoralInduction(,,)
//     */
//    static boolean termForTemporalInduction(final Term t) {
//        /*//
//                //if(t1 instanceof Operation &amp;&amp; t2 instanceof Operation) {
//        //   return; //maybe too restrictive
//        //}
//        if(((t1 instanceof Implication || t1 instanceof Equivalence) &amp;&amp; t1.getTemporalOrder()!=TemporalRules.ORDER_NONE) ||
//           ((t2 instanceof Implication || t2 instanceof Equivalence) &amp;&amp; t2.getTemporalOrder()!=TemporalRules.ORDER_NONE)) {
//            return; //better, if this is fullfilled, there would be more than one temporal operate in the statement, return
//        }
//        */
//
//        //return (t instanceof Inheritance) || (t instanceof Similarity);
//        return (t instanceof Statement);
//    }

    /*
    public static void applyExpectationOffset(Memory memory, Term temporalStatement, Stamp stamp) {
        if(temporalStatement!=null &amp;&amp; temporalStatement instanceof Implication) {
            Implication imp=(Implication) temporalStatement;
            if(imp.getSubject() instanceof Conjunction &amp;&amp; imp.getTemporalOrder()==TemporalRules.ORDER_FORWARD)  {
                Conjunction conj=(Conjunction) imp.getSubject();
                if(conj.term[conj.term.length-1] instanceof Interval) {
                    Interval intv=(Interval) conj.term[conj.term.length-1];
                    long time_offset=intv.durationCycles(memory);
                    stamp.setOccurrenceTime(stamp.getOccurrenceTime()+time_offset);
                }
            }
        }
    }*/


//    public static void temporalInduction(final Task snext, final Task sprev, final NAL nal) {
//        temporalInduction(snext, sprev, nal, nal.getTask(), true);
//    }
//
//    final static Variable var1 = new Variable(&quot;$0&quot;);
//    final static Variable v91 = new Variable(&quot;$91&quot;);
//    final static Variable v92 = new Variable(&quot;$92&quot;);
//
//    public static void temporalInduction(final Task snext, final Task sprev, final NAL nal, Task subbedTask, boolean SucceedingEventsInduction) {
//
//        if (!snext.isJudgment() || !sprev.isJudgment())
//            return;
//
//        Term t1 = snext.getTerm();
//        Term t2 = sprev.getTerm();
//
//        if (Statement.invalidStatement(t1, t2))
//            return;
//
//        Term t11 = null;
//        Term t22 = null;
//
//        if (termForTemporalInduction(t1) &amp;&amp; termForTemporalInduction(t2)) {
//
//            Statement ss1 = (Statement) t1;
//            Statement ss2 = (Statement) t2;
//
//
//            final Variable var2 = var1;
//
//
//            if (ss1.getSubject().equals(ss2.getSubject())) {
//                t11 = Terms.makeStatement(ss1, var1, ss1.getPredicate());
//                t22 = Terms.makeStatement(ss2, var2, ss2.getPredicate());
//            } else if (ss1.getPredicate().equals(ss2.getPredicate())) {
//                t11 = Terms.makeStatement(ss1, ss1.getSubject(), var1);
//                t22 = Terms.makeStatement(ss2, ss2.getSubject(), var2);
//            }
//
//
//            Map&lt;Term, Term&gt; subs = null;
//
//            if (ss2.containsTermRecursively(ss1.getSubject())) {
//                subs = Global.newHashMap(1);
//                subs.put(ss1.getSubject(), var1);
//                if (ss2.containsTermRecursively(ss1.getPredicate())) {
//                    subs.put(ss1.getPredicate(), var2);
//                }
//
//                Substitution sub = new Substitution(subs);
//                t11 = ss1.applySubstitute(sub);
//                t22 = ss2.applySubstitute(sub);
//            }
//
//            if (ss1.containsTermRecursively(ss2.getSubject())) {
//                if (subs == null) subs = Global.newHashMap(1); else subs.clear();
//
//                subs.put(ss2.getSubject(), var1);
//
//                if (ss1.containsTermRecursively(ss2.getPredicate())) {
//                    subs.put(ss2.getPredicate(), var2);
//                }
//
//                Substitution sub = new Substitution(subs);
//                t11 = ss1.applySubstitute(sub);
//                t22 = ss2.applySubstitute(sub);
//            }
//
//            //TODO combine the below blocks they are similar
//
//            //allow also temporal induction on operation arguments:
//            if (ss2 instanceof Operation ^ ss1 instanceof Operation) {
//                if (ss2 instanceof Operation &amp;&amp; !(ss2.getSubject() instanceof Variable)) {//it is an operation, let's look if one of the arguments is same as the subject of the other term
//                    Term comp = ss1.getSubject();
//                    Term ss2_term = ss2.getSubject();
//
//                    boolean applicableVariableType = !(comp instanceof Variable &amp;&amp; comp.hasVarIndep());
//
//                    if (ss2_term instanceof Product) {
//                        Product ss2_prod = (Product) ss2_term;
//
//                        if (applicableVariableType &amp;&amp; Terms.contains(ss2_prod.terms(), comp)) { //only if there is one and it isnt a variable already
//                            Term[] ars = ss2_prod.cloneTermsReplacing(comp, var1);
//
//                            t11 = Terms.makeStatement(ss1, var1, ss1.getPredicate());
//
//                            Operation op = (Operation) Operation.make(
//                                    ss2.getPredicate(),
//                                    Product.make(ars)
//                            );
//
//                            t22 = op;
//                        }
//                    }
//                }
//                if (ss1 instanceof Operation &amp;&amp; !(ss1.getSubject() instanceof Variable)) {//it is an operation, let's look if one of the arguments is same as the subject of the other term
//                    Term comp = ss2.getSubject();
//                    Term ss1_term = ss1.getSubject();
//
//                    boolean applicableVariableType = !(comp instanceof Variable &amp;&amp; comp.hasVarIndep());
//
//                    if (ss1_term instanceof Product) {
//                        Product ss1_prod = (Product) ss1_term;
//
//                        if (applicableVariableType &amp;&amp; Terms.contains(ss1_prod.terms(), comp)) { //only if there is one and it isnt a variable already
//
//                            Term[] ars = ss1_prod.cloneTermsReplacing(comp, var1);
//
//
//                            t22 = Terms.makeStatement(ss2, var1, ss2.getPredicate());
//
//                            Operation op = (Operation) Operation.make(
//                                    ss1.getPredicate(),
//                                    Product.make(ars)
//                            );
//
//                            t11 = op;
//                        }
//                    }
//                }
//            }
//        }
//
//
//        int durationCycles = nal.memory().duration();
//
//        long time1 = snext.getOccurrenceTime();
//        long time2 = sprev.getOccurrenceTime();
//
//        final long timeDiff;
//        if ((time1 == Stamp.ETERNAL) || (time2 == Stamp.ETERNAL))
//            throw new RuntimeException(&quot;induction on eternal terms&quot;); //timeDiff = 0;
//
//        timeDiff = time2 - time1;
//
//        if (!concurrent(time1, time2, durationCycles)) {
//
//            AbstractInterval interval = nal.newInterval(Math.abs(timeDiff));
//
//            if (timeDiff &gt; 0) {
//                t1 = Conjunction.make(ORDER_FORWARD, t1, interval);
//                if (t11 != null) {
//                    t11 = Conjunction.make(ORDER_FORWARD, t11, interval);
//                }
//            } else {
//                t2 = Conjunction.make(ORDER_FORWARD, t2, interval);
//                if (t22 != null) {
//                    t22 = Conjunction.make(ORDER_FORWARD, t22, interval);
//                }
//            }
//        }
//
//
//        int order = order(timeDiff, durationCycles);
//        Truth givenTruth1 = snext.getTruth();
//        Truth givenTruth2 = sprev.getTruth();
//        //   TruthFunctions.
//        Truth truth1 = TruthFunctions.induction(givenTruth1, givenTruth2);
//        Budget budget1 = truth1!=null ? BudgetFunctions.forward(truth1, nal) : null;
//        Statement statement1 = truth1!=null ? Implication.make(t1, t2, order) : null;
//
//        Truth truth2 = TruthFunctions.induction(givenTruth2, givenTruth1);
//        Budget budget2 = truth2!=null ? BudgetFunctions.forward(truth2, nal) : null;
//        Statement statement2 = truth2!=null ? Implication.make(t2, t1, reverseOrder(order)) : null;
//
//        Truth truth3 = TruthFunctions.comparison(givenTruth1, givenTruth2);
//        Budget budget3 = truth3!=null ? BudgetFunctions.forward(truth3, nal) : null;
//        Statement statement3 = truth3!=null ? Equivalence.make(t1, t2, order) : null;
//
//        //https://groups.google.com/forum/#!topic/open-nars/0k-TxYqg4Mc
//        if (!SucceedingEventsInduction) { //reduce priority according to temporal distance
//            //it was not &quot;semantically&quot; connected by temporal succession
//            int tt1 = (int) snext.getOccurrenceTime();
//            int tt2 = (int) sprev.getOccurrenceTime();
//            float d = Math.abs(tt1 - tt2) / ((float)nal.memory().duration.get());
//            if (d != 0) {
//                float mul = 1.0f / d;
//                if (budget1!=null)  budget1.mulPriority(mul);
//                if (budget2!=null)  budget2.mulPriority(mul);
//                if (budget3!=null)  budget3.mulPriority(mul);
//            }
//        }
//
//
//
//
//
//        //maybe this way is also the more flexible and intelligent way to introduce variables for the case above
//        //TODO: rethink this for 1.6.3
//        //&quot;Perception Variable Introduction Rule&quot; - https://groups.google.com/forum/#!topic/open-nars/uoJBa8j7ryE
//        if (statement2 != null) { //there is no general form
//            //ok then it may be the (&amp;/ =/&gt; case which
//            //is discussed here: https://groups.google.com/forum/#!topic/open-nars/uoJBa8j7ryE
//            Statement st = statement2;
//            if (st.getPredicate() instanceof Inheritance &amp;&amp; (st.getSubject() instanceof Conjunction || st.getSubject() instanceof Operation)) {
//                Term precon = st.getSubject();
//                Inheritance consequence = (Inheritance) st.getPredicate();
//                Term pred = consequence.getPredicate();
//                Term sub = consequence.getSubject();
//                //look if subject is contained in precon:
//                boolean SubsSub = precon.containsTermRecursivelyOrEquals(sub);
//                boolean SubsPred = precon.containsTermRecursivelyOrEquals(pred);
//                HashMap&lt;Term, Term&gt; app = new HashMap&lt;Term, Term&gt;();
//                if (SubsSub || SubsPred) {
//                    if (SubsSub)
//                        app.put(sub, v91);
//                    if (SubsPred)
//                        app.put(pred, v92);
//                    Term res = statement2.applySubstitute(app);
//                    if (res != null) { //ok we applied it, all we have to do now is to use it
//                        t22 = ((Statement) res).getSubject();
//                        t11 = ((Statement) res).getPredicate();
//                    }
//                }
//            }
//        }
//
//
//        final int inductionLimit = nal.memory().temporalRelationsMax.get();
//
//        //List&lt;Task&gt; success = new ArrayList&lt;Task&gt;();
//        if (t11 != null &amp;&amp; t22 != null) {
//            Statement statement11 = Implication.make(t11, t22, order);
//            Statement statement22 = Implication.make(t22, t11, reverseOrder(order));
//            Statement statement33 = Equivalence.make(t11, t22, order);
//            if (!tooMuchTemporalStatements(statement11, inductionLimit)) {
//                Task t = nal.deriveDoubleTemporal(statement11, truth1, budget1, subbedTask, sprev);
//            }
//            if (!tooMuchTemporalStatements(statement22, inductionLimit)) {
//                Task t = nal.deriveDoubleTemporal(statement22, truth2, budget2, subbedTask, sprev);
//            }
//            if (!tooMuchTemporalStatements(statement33, inductionLimit)) {
//                Task t = nal.deriveDoubleTemporal(statement33, truth3, budget3, subbedTask, sprev);
//            }
//        }
//        if (!tooMuchTemporalStatements(statement1, inductionLimit)) {
//            Task t = nal.deriveDoubleTemporal(statement1, truth1, budget1, subbedTask, sprev);
//        }
//        if (!tooMuchTemporalStatements(statement2, inductionLimit)) {
//
//            /*  =/&gt;  */
//
//            Task task = nal.deriveDoubleTemporal(statement2, truth2, budget2, subbedTask, sprev);
//
//            if (task!=null) {
//
//                deriveCompiledInferenceHelper(snext, sprev, nal, task);
//            }
//
//
//        }
//        if (!tooMuchTemporalStatements(statement3, inductionLimit)) {
//            nal.deriveDoubleTemporal(statement3, truth3, budget3, subbedTask, sprev);
//        }
//
//    }

//    /** //micropsi inspired strive for knowledge
//     //get strongest belief of that concept and use the revison truth, if there is no, use this truth */
//    protected static void deriveCompiledInferenceHelper(Sentence snext, Sentence sprev, NAL nal, Task task) {
//
//        desireUpdateCompiledInferenceHelper(snext, task, nal, sprev);
//
//        double conf = task.getTruth().getConfidence();
//        Concept C = nal.nar.concept(task.getTerm());
//        if (C != null &amp;&amp; C.hasBeliefs()) {
//            Task bel = C.getBeliefs().top();
//            Truth cur = bel.getTruth();
//            conf = Math.max(cur.getConfidence(), conf); //no matter if revision is possible, it wont be below max
//            //if there is no overlapping evidental base, use revision:
//            boolean revisable;
//            revisable = !Stamp.overlapping(bel, task);
//            if (revisable) {
//                conf = TruthFunctions.revision(task.getTruth(), bel.getTruth()).getConfidence();
//            }
//        }
//
//        questionFromLowConfidenceHighPriorityJudgement(task, conf, nal);
//    }
//
//    static Task desireUpdateCompiledInferenceHelper(final Sentence s1, Task task, final NAL nal, final Sentence s2) {
//        /*
//        IN &lt;SELF --&gt; [good]&gt;! %1.00;0.90%
//        IN (^pick,left). :|: %1.00;0.90%
//        IN  PauseInput(3)
//        IN &lt;SELF --&gt; [good]&gt;. :|: %0.00;0.90%
//        &lt;(&amp;/,(^pick,left,$1),+3) =/&gt; &lt;$1 --&gt; [good]&gt;&gt;. :|: %0.00;0.45%
//        &lt;(&amp;/,(^pick,left,$1),+3) =/&gt; &lt;$1 --&gt; [good]&gt;&gt;. %0.00;0.31%
//        &lt;(&amp;/,(^pick,left,$1),+3) &lt;/&gt; &lt;$1 --&gt; [good]&gt;&gt;. :|: %0.00;0.45%
//        &lt;(&amp;/,(^pick,left,$1),+3) &lt;/&gt; &lt;$1 --&gt; [good]&gt;&gt;. %0.00;0.31%
//        &lt;(&amp;/,(^pick,left),+3) =/&gt; &lt;SELF --&gt; [good]&gt;&gt;. :|: %0.00;0.45%
//        &lt;(&amp;/,(^pick,left),+3) =/&gt; &lt;SELF --&gt; [good]&gt;&gt;. %0.00;0.31%
//        &lt;(&amp;/,(^pick,left),+3) &lt;/&gt; &lt;SELF --&gt; [good]&gt;&gt;. :|: %0.00;0.45%
//        &lt;(&amp;/,(^pick,left),+3) &lt;/&gt; &lt;SELF --&gt; [good]&gt;&gt;. %0.00;0.31%
//
//        It takes the system sometimes like 1000 steps to go from
//        &quot;(^pick,left) leads to SELF not being good&quot;
//        to
//        &quot;since &lt;SELF --&gt; good&gt; is a goal, (^pick,left) is not desired&quot;
//        making it bad for RL tasks but this will change, maybe with the following principle:
//
//
//        task: &lt;(&amp;/,(^pick,left,$1),+3) =/&gt; &lt;$1 --&gt; [good]&gt;&gt;.
//        belief: &lt;SELF --&gt; [good]&gt;!
//        |-
//        (^pick,left)! (note the change of punctuation, it needs the punctuation of the belief here)
//
//        */
//        if (s1.isJudgment()) { //necessary check?
//            Sentence belief=task;
//            Concept S1_State_C=nal.nar.concept(s1.getTerm());
//            if(S1_State_C != null &amp;&amp; S1_State_C.hasGoals() &amp;&amp;
//                    !(((Statement) belief.getTerm()).getPredicate() instanceof Operation)) {
//                Task a_desire = S1_State_C.getGoals().top();
//
////                Sentence g = new Sentence(S1_State_C.getTerm(),Symbols.JUDGMENT,
////                        new DefaultTruth(1.0f,0.99f), a_desire);
////
////
////                g.setOccurrenceTime(s1.getOccurrenceTime());
//
//                final long now = nal.time();
//
//                //strongest desire for that time is what we want to know
//                Task strongest_desireT = S1_State_C.getGoals().top(S1_State_C.getTerm().hasVarQuery(), now, s1.getOccurrenceTime(), s1.getTruth());
//
//                Task strongest_desire = strongest_desireT.projectTask(s1.getOccurrenceTime(), strongest_desireT.getOccurrenceTime());
//                Truth T=TruthFunctions.desireDed(belief.getTruth(), strongest_desire.getTruth());
//
//                //Stamp st=new Stamp(strongest_desire.stamp.clone(),belief.stamp, nal.memory.time());
//
//                final long occ;
//
//                if(strongest_desire.isEternal()) {
//                    occ = Stamp.ETERNAL;
//                } else {
//                    long shift=0;
//                    if(task.getTerm().getTemporalOrder()==TemporalRules.ORDER_FORWARD) {
//                        shift=nal.memory().duration();
//                    }
//                    occ = (strongest_desire.getOccurrenceTime()-shift);
//                }
//
//
//
//                //nal.setCurrentBelief(belief);
//
//                //Sentence W=new Sentence(s2.term,Symbols.GOAL,T, belief).setOccurrenceTime(occ);
//
//                Budget val=BudgetFunctions.forward(T, nal);
//
//                return nal.derive(nal.newTask(s2.getTerm()).goal().truth(T).budget(val)
//                                .parent(task, strongest_desireT)
//                                .occurr(occ).temporalInductable(false)
//                );
//
//            }
//        }
//
//        //PRINCIPLE END
//        return null;
//    }
//
//
//
//    private static Task questionFromLowConfidenceHighPriorityJudgement(Task task, double conf, final NAL nal) {
//        if(!(task.getTerm() instanceof Implication)) return null;
//
//        if(nal.memory().emotion.busy()&lt;Global.CURIOSITY_BUSINESS_THRESHOLD
//                &amp;&amp; Global.CURIOSITY_ALSO_ON_LOW_CONFIDENT_HIGH_PRIORITY_BELIEF
//                &amp;&amp; task.isJudgment()
//                &amp;&amp; conf&lt;Global.CURIOSITY_CONFIDENCE_THRESHOLD
//                &amp;&amp; task.getPriority()&gt;Global.CURIOSITY_PRIORITY_THRESHOLD) {
//
//                boolean valid=false;
//
//                Implication equ=(Implication) task.getTerm();
//                if(equ.getTemporalOrder()!=TemporalRules.ORDER_NONE) {
//                    valid=true;
//                }
//
//                if(valid) {
//                    return nal.derive(nal.newTask(task.getTerm())
//                                    .question()
//                                    .parent(task)
//                                    .occurrNow()
//                                    .budget(task.getBudget(), Global.CURIOSITY_DESIRE_PRIORITY_MUL, Global.CURIOSITY_DESIRE_DURABILITY_MUL)
//                    );
//                }
//
//        }
//        return null;
//    }
//

//    /**
//     * Evaluate the quality of a truth judgment with a new projected turth value as a solution to a problem
//     *
//     * @param problem  A goal or question
//     * @param solution The solution to be evaluated
//     * @return The quality of the judgment as the solution
//     */
//    public static float solutionQuality(final Sentence problem, final Sentence solution, final Truth projectedTruth, long time) {
//
//        return solution.projectionTruthQuality(projectedTruth, problem.getOccurrenceTime(), time, problem.hasQueryVar());
//
////        if (!matchingOrder(problem, solution)) {
////            return 0.0F;
////        }
//
////        Truth truth;
////        if (ptime!=solution.getOccurrenceTime())
////            truth = solution.projectionTruth(ptime, memory.time());
////        else
////            truth = solution.truth;
////
////        if (problem.hasQueryVar()) {
////            return truth.getExpectation() / solution.term.getComplexity();
////        } else {
////            return truth.getConfidence();
////        }
//
//    }


    /* ----- Functions used both in direct and indirect processing of tasks ----- */

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>