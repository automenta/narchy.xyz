<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LocalRules.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.nal</a> &gt; <span class="el_source">LocalRules.java</span></div><h1>LocalRules.java</h1><pre class="source lang-java linenums">/*
 * LocalRules.java
 *
 * Copyright (C) 2008  Pei Wang
 *
 * This file is part of Open-NARS.
 *
 * Open-NARS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Open-NARS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the abduction warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Open-NARS.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package nars.nal;

import com.gs.collections.impl.tuple.Tuples;
import nars.*;
import nars.budget.Budget;
import nars.budget.BudgetFunctions;
import nars.budget.UnitBudget;
import nars.task.MutableTask;
import nars.task.Task;
import nars.term.Term;
import nars.term.compound.Compound;
import nars.truth.ProjectedTruth;
import nars.truth.Truth;
import nars.truth.TruthFunctions;
import org.jetbrains.annotations.NotNull;

import java.util.Set;
import java.util.function.Consumer;


/**
 * Directly process a task by a oldBelief, with only two Terms in both. In
 * matching, the new task is compared with an existing direct Task in that
 * Concept, to carry out:
 * &lt;p/&gt;
 * revision: between judgments or goals on non-overlapping evidence;
 * satisfy: between a Sentence and a Question/Goal;
 * merge: between items of the same type and stamp;
 * conversion: between different inheritance relations.
 */
<span class="pc" id="L51">public enum LocalRules {</span>
    ;

//
//    /**
//     * Check whether two sentences can be used in revision
//     *
//     * @param newBelief The first sentence
//     * @param oldBelief The second sentence
//     * @return If revision is possible between the two sentences
//     */
//    public static boolean revisible(final Sentence newBelief, final Sentence oldBelief) {
//        if (newBelief.isRevisible())
//            if (newBelief.equalTerms(oldBelief))
//                if (TemporalRules.matchingOrder(newBelief.getTemporalOrder(), oldBelief.getTemporalOrder())) {
//                    return true;
//                }
//
//        return false;
//    }


//    /**
//     * Belief revision
//     * &lt;p&gt;
//     * called from Concept.reviseTable and match
//     *
//     * @param newBelief       The new belief in task
//     * @param oldBelief       The previous belief with the same content
//     * @param feedbackToLinks Whether to send feedback to the links
//
//     */
//    public static Task revision(final Task newBelief, final Task oldBelief, final boolean feedbackToLinks, final NAL nal) {
//        //Stamper stamp = nal.newStampIfNotOverlapping(newBelief, oldBelief);
//        //if (stamp == null) return null;
//
//        if (Stamp.overlapping(newBelief, oldBelief))
//            return null;
//
//        Truth newBeliefTruth = newBelief.getTruth();
//        Truth oldBeliefTruth = oldBelief.getTruth();
//        Truth truth = TruthFunctions.revision(newBeliefTruth, oldBeliefTruth);
//        Budget budget = BudgetFunctions.revise(newBeliefTruth, oldBeliefTruth, truth, nal);
//
//        Task revised = nal.validDerivation(nal.newTask(newBelief.getTerm())
//                .punctuation(newBelief.getPunctuation())
//                .truth(truth)
//                .budget(budget)
//                .parent(newBelief));
//
//        if (revised != null)
//            nal.memory().logic.BELIEF_REVISION.hit();
//
//        return revised;
//    }




    /**
     * Check if a Sentence provide a better answer to a Question or Goal
     *
     * @param proposedBelief       The proposed answer
     * @param question     The question to be processed
     * @return the projected Task, or the original Task
     */
    public static void trySolution(@NotNull Task question, @NotNull Task sol, @NotNull NAR nal, @NotNull Consumer&lt;Task&gt; eachSolutions) {

//        if ((sol == null) || (sol.getDeleted())) {
//            throw new RuntimeException(&quot;proposedBelief &quot; + sol + &quot; deleted or null&quot;);
//        }

//        float om = Tense.orderMatch(question, solution, nal.memory.duration());
//
//        if (!Tense.matchingOrder(question, solution)) {
//            //System.out.println(&quot;Unsolved: Temporal order not matching&quot;);
//            //memory.emit(Unsolved.class, task, belief, &quot;Non-matching temporal Order&quot;);
//            return;
//        }


<span class="fc" id="L132">        Memory memory = nal.memory;</span>

<span class="fc" id="L134">        long now = memory.time();</span>

        /** temporary for comparing the result before unification and after */
        //float newQ0 = TemporalRules.solutionQuality(question, belief, projectedTruth, now);

<span class="fc" id="L139">        final Set&lt;Task&gt; answered = Global.newHashSet(0);</span>

<span class="fc" id="L141">        Consumer&lt;Term&gt; proc = (st) -&gt; {</span>

<span class="fc" id="L143">            long questionOcc = question.getOccurrenceTime();</span>

<span class="fc" id="L145">            Truth solutionTruth = sol.projection(questionOcc, now);</span>

<span class="fc" id="L147">            Task ss = sol.solution((Compound) st,</span>
<span class="fc" id="L148">                        sol.getPunctuation(),</span>
                        solutionTruth,
                        questionOcc,
                        question,
                        memory
                );


            //TODO move this to a callee's consumer?
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (processSolution(question, nal, ss, memory, now)) {</span>

<span class="fc bfc" id="L159" title="All 2 branches covered.">                if (Global.DEBUG_NON_INPUT_ANSWERED_QUESTIONS || question.isInput())</span>
<span class="fc" id="L160">                    answered.add(question);</span>
            }

<span class="fc" id="L163">        };</span>

<span class="fc" id="L165">        Compound quesTerm = question.term();</span>
<span class="fc" id="L166">        Compound solTerm = sol.term();</span>

<span class="pc bpc" id="L168" title="1 of 4 branches missed.">        if (solTerm.hasVarIndep() &amp;&amp; !solTerm.equals(quesTerm)) {</span>

<span class="fc" id="L170">            Premise.unify(Op.VAR_INDEP, quesTerm, solTerm, nal.memory, proc);</span>

        } else {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            if (sol == null)</span>
<span class="nc" id="L174">                throw new RuntimeException(&quot;Unification invalid: &quot; + sol + &quot; unified and projected to &quot; + sol);</span>

<span class="fc" id="L176">            proc.accept(sol.term());</span>
        }

<span class="fc" id="L179">        answered.forEach(q -&gt; {</span>
<span class="fc" id="L180">            eachSolutions.accept(q.getBestSolution());</span>

            //defer these events until after frame ends so reasoning in this cycle may continue
<span class="fc" id="L183">            nal.beforeNextFrame(() -&gt; {</span>
                //TODO use an Answer class which is Runnable, combining that with the Twin info
<span class="fc" id="L185">                memory.eventAnswer.emit(Tuples.twin(q, q.getBestSolution()));</span>
<span class="fc" id="L186">            });</span>
<span class="fc" id="L187">        });</span>
<span class="fc" id="L188">    }</span>

    public static boolean processSolution(@NotNull Task question, @NotNull NAR nal, @NotNull Task sol, @NotNull Memory memory, long now) {

//        if (!(question.isQuestion() || question.isQuest())) {
//            throw new RuntimeException(question + &quot; not a question&quot;);
//        }

        //long then = question.getOccurrenceTime();

<span class="fc" id="L198">        Task oldBest = question.getBestSolution();</span>
<span class="fc bfc" id="L199" title="All 4 branches covered.">        if (oldBest!=null &amp;&amp; oldBest.equals(sol)) {</span>
<span class="fc" id="L200">            return false;</span>
        }
<span class="fc" id="L202">        question.setBestSolution(sol);</span>

        //use sol.getTruth() in case sol was changed since input to this method:
        //float newQ = solutionQuality(question, sol, sol.getTruth(), now);
<span class="fc" id="L206">        float newQ = Tense.solutionQuality(question, sol, now, nal.memory.duration());</span>
//        if (newQ == 0) {
//            memory.emotion.happy(0, questionTask, nal);
//            return null;
//        }



        //get the quality of the old solution if it were applied now (when conditions may differ)
<span class="fc bfc" id="L215" title="All 2 branches covered.">        float oldQ = (oldBest != null) ? Tense.solutionQuality(question, oldBest, now, nal.memory.duration()) : -1;</span>

//        if (oldQ &gt;= newQ) {
//            //old solution was better
//            return false;
//        }


        //TODO solutionEval calculates the same solutionQualities as here, avoid this unnecessary redundancy
<span class="fc" id="L224">        Budget budget = solutionEval(question, sol, nal);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (budget == null) {</span>
<span class="fc" id="L226">            return false;</span>
        }


        //else, new solution is btter
<span class="fc" id="L231">        memory.emotion.happy(newQ - oldQ, question);</span>


<span class="fc" id="L234">        memory.logic.SOLUTION_BEST.set(newQ);</span>


<span class="fc" id="L237">        sol.getBudget().set(budget);</span>


        /*memory.output(task);

        //only questions and quests get here because else output is spammed
        if(task.sentence.isQuestion() || task.sentence.isQuest()) {
            memory.emit(Solved.class, task, belief);
        } else {
            memory.emit(Output.class, task, belief);
        }*/

        //nal.addSolution(nal.getCurrentTask(), budget, belief, task);

        //.reason(currentTask.getHistory())


        //if (belief != inputBelief) { //!belief.equals(inputBelief)) {
        //it was either unified and/or projected:
            /*belief = nal.addNewTask(nal.newTask(belief.getTerm(), belief.getPunctuation())
                            .truth(belief.getTruth())
                            .budget(budget)
                            .parent(belief) //.parent(questionTask, questionTask.getParentBelief())
                            .occurr(belief.getOccurrenceTime())

                            .solution(belief),
                    &quot;Adjusted Solution&quot;,
                    true, false, false);*/


        /** decrease question's budget for transfer to solutions */
        //question.getBudget().andPriority(budget.getPriority());

        //memory.eventDerived.emit(sol);
        //nal.nar().input(sol); //is this necessary? i cant find any reason for reinserting to input onw that it's part of the concept's belief/goal tables
        //}


<span class="fc" id="L275">        return true;</span>

    }

    /**
     * Evaluate the quality of a belief as a solution to a problem, then reward
     * the belief and de-prioritize the problem
     *
     * @param question  The problem (question or goal) to be solved
     * @param solution The belief as solution
     * @param question     The task to be immediately processed, or null for continued
     *                 process
     * @return The budget for the new task which is the belief activated, if
     * necessary
     */
    public static Budget solutionEval(@NotNull Task question, @NotNull Task solution, @NotNull NAR nar) {
        //boolean feedbackToLinks = false;
        /*if (task == null) {
            task = nal.getCurrentTask();
            feedbackToLinks = true;
        }*/
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (question.getDeleted())</span>
<span class="nc" id="L297">            return null;</span>

<span class="fc" id="L299">        boolean judgmentTask = question.isJudgment();</span>
<span class="fc" id="L300">        float quality = Tense.solutionQuality(question, solution, nar.time(), nar.memory.duration());</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (quality &lt;= 0)</span>
<span class="fc" id="L302">            return null;</span>

<span class="fc" id="L304">        Budget budget = null;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (judgmentTask) {</span>
<span class="fc" id="L306">            question.getBudget().orPriority(quality);</span>
        } else {
<span class="fc" id="L308">            float taskPriority = question.getPriority();</span>

<span class="fc" id="L310">            budget = new UnitBudget(UtilityFunctions.or(taskPriority, quality), question.getDurability(), BudgetFunctions.truthToQuality(solution.getTruth()));</span>
<span class="fc" id="L311">            question.getBudget().setPriority(Math.min(1 - quality, taskPriority));</span>
        }
        /*
        if (feedbackToLinks) {
            TaskLink tLink = nal.getCurrentTaskLink();
            tLink.setPriority(Math.min(1 - quality, tLink.getPriority()));
            TermLink bLink = nal.getCurrentBeliefLink();
            bLink.incPriority(quality);
        }*/
<span class="fc" id="L320">        return budget;</span>
    }

//    public static float solutionQuality(Task problem, Task solution, Truth truth, long time) {
//        return Tense.solutionQuality(problem.hasQueryVar(), problem.getOccurrenceTime(), solution, truth, time);
//    }

    /**
     * WARNING: this assumes the task's terms are already
     * known to be equal.
     */
    private static boolean isRevisible(@NotNull Task newBelief, Task oldBelief) {
<span class="fc" id="L332">        Term t = newBelief.term();</span>
<span class="fc" id="L333">        return</span>
<span class="fc bfc" id="L334" title="All 4 branches covered.">            !(t.op().isConjunctive() &amp;&amp; t.hasAny(Op.VAR_DEP))    // t.hasVarDep());</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">            &amp;&amp; !newBelief.equals(oldBelief)</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">            &amp;&amp; !Tense.overlapping(newBelief, oldBelief);</span>
    }

    /**
     * creates a revision task (but does not input it)
     * if failed, returns null
     */
    public static Task getRevision(@NotNull Task newBelief, @NotNull Task oldBelief, long now) {

<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (!isRevisible(newBelief, oldBelief)) {</span>
<span class="fc" id="L346">            return null;</span>
        }
        //if (Tense.matchingOrder(newBelief.getTemporalOrder(), oldBelief.getTemporalOrder()))

<span class="fc" id="L350">        Truth newBeliefTruth = newBelief.getTruth();</span>

<span class="fc" id="L352">        long occ = newBelief.getOccurrenceTime();</span>

//        //interpolate the occurrence time by their relative confidences
//        long newo = newBelief.getOccurrenceTime();
//        long oldo = oldBelief.getOccurrenceTime();
//        long target;
//        if (newo!=oldo) {
//            long dnew = Math.abs(now - newo);
//            long dold = Math.abs(now - oldo);
//            long dden = dnew + dold;
//            target = dden != 0 ? (long) (Util.lerp(newo, oldo,
//                    (float) (dnew / (dnew + dold))
//            )) : newo;
//        } else {
//            target = newo;
//        }

<span class="fc" id="L369">        Truth oldBeliefTruth = oldBelief.projection(occ, now);</span>

<span class="fc" id="L371">        Truth conclusion = TruthFunctions.revision(newBeliefTruth, oldBeliefTruth);</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if (conclusion instanceof ProjectedTruth) {</span>
            //allow eternalized truth to override with eternalized occurrence
<span class="nc" id="L374">            occ = ((ProjectedTruth) conclusion).target;</span>
        }

<span class="fc" id="L377">        return new MutableTask(newBelief.concept())</span>
<span class="fc" id="L378">                .punctuation(newBelief.getPunctuation())</span>
<span class="fc" id="L379">                .truth(conclusion)</span>
<span class="fc" id="L380">                .budget(BudgetFunctions.revise(newBeliefTruth, oldBelief, conclusion, newBelief.getBudget()))</span>
<span class="fc" id="L381">                .parent(newBelief, oldBelief)</span>
<span class="fc" id="L382">                .time(now, occ)</span>
<span class="fc" id="L383">                .because(&quot;Revision&quot;);</span>
    }


    /* -------------------- same terms, difference relations -------------------- */
//
//    /**
//     * The task and belief match reversely
//     *
//     * @param p Reference to the memory
//     */
//    public static Task matchReverse(final Premise p) {
//        final Task task = p.getTask();
//        final Task belief = p.getBelief();
//
//        if (TemporalRules.matchingOrder(task.getTemporalOrder(), TemporalRules.reverseOrder(belief.getTemporalOrder()))) {
//            if (task.isJudgment()) {
//                return NAL2.inferToSym(task, belief, p);
//            } else {
//                return conversion(p);
//            }
//        }
//        return null;
//    }

//    /**
//     * Inheritance/Implication matches Similarity/Equivalence
//     *
//     * @param asym   A Inheritance/Implication sentence
//     * @param sym    A Similarity/Equivalence sentence
//     * @param figure location of the shared term
//     * @param p    Reference to the memory
//     */
//    public static void matchAsymSym(final Task asym, final Task sym, int figure, final Premise p) {
//        if (p.getTask().isJudgment()) {
//            inferToAsym(asym, sym, p);
//        } else {
//            convertRelation(p);
//        }
//    }

//    /* -------------------- two-premise logic rules -------------------- */
//
//    /**
//     * {&lt;S &lt;-&gt; P&gt;, &lt;P --&gt; S&gt;} |- &lt;S --&gt; P&gt; Produce an Inheritance/Implication
//     * from a Similarity/Equivalence and a reversed Inheritance/Implication
//     *
//     * @param asym The asymmetric premise
//     * @param sym  The symmetric premise
//     * @param p  Reference to the memory
//     */
//    private static Task inferToAsym(Task asym, Task sym, Premise p) {
//        TaskSeed s = p.newDoublePremise(asym, sym);
//        if (s == null)
//            return null;
//
//        Statement statement = (Statement) asym.getTerm();
//        Term sub = statement.getPredicate();
//        Term pre = statement.getSubject();
//
//        Statement content = Statement.make(statement, sub, pre, statement.getTemporalOrder());
//        if (content == null) return null;
//
//        Truth truth = TruthFunctions.reduceConjunction(sym.getTruth(), asym.getTruth());
//
//
//            return p.deriveDouble(
//                    s.term(content)
//                            .punctuation(asym.getPunctuation())
//                            .truth(truth)
//                            .budget(BudgetFunctions.forward(truth, p)),
//                    false);
//
//
//
//    }
//
//    /* -------------------- one-premise logic rules -------------------- */
//
//    /**
//     * {&lt;P --&gt; S&gt;} |- &lt;S --&gt; P&gt; Produce an Inheritance/Implication from a
//     * reversed Inheritance/Implication
//     *
//     * @param p Reference to the memory
//     */
//    private static Task conversion(final Premise p) {
//        Truth truth = TruthFunctions.conversion(p.getBelief().getTruth());
//        Budget budget = BudgetFunctions.forward(truth, p);
//        return convertedJudgment(truth, budget, p);
//    }
//
//    /**
//     * {&lt;S --&gt; P&gt;} |- &lt;S &lt;-&gt; P&gt; {&lt;S &lt;-&gt; P&gt;} |- &lt;S --&gt; P&gt; Switch between
//     * Inheritance/Implication and Similarity/Equivalence
//     *
//     * @param p Reference to the memory
//     */
//    private static Task convertRelation(final Premise p) {
//        final Truth beliefTruth = p.getBelief().getTruth();
//        final AnalyticTruth truth;
//        if ((p.getTask().getTerm()).isCommutative()) {
//            truth = TruthFunctions.abduction(beliefTruth, 1.0f);
//        } else {
//            truth = TruthFunctions.deduction(beliefTruth, 1.0f);
//        }
//        if (truth != null) {
//            Budget budget = BudgetFunctions.forward(truth, p);
//            return convertedJudgment(truth, budget, p);
//        }
//        return null;
//    }
//
//    /**
//     * Convert judgment into different relation
//     * &lt;p&gt;
//     * called in MatchingRules
//     *
//     * @param budget The budget value of the new task
//     * @param truth  The truth value of the new task
//     * @param p    Reference to the memory
//     */
//    private static Task convertedJudgment(final Truth newTruth, final Budget newBudget, final Premise p) {
//        Statement content = (Statement) p.getTask().getTerm();
//        Statement beliefContent = (Statement) p.getBelief().getTerm();
//        int order = TemporalRules.reverseOrder(beliefContent.getTemporalOrder());
//        final Term subjT = content.getSubject();
//        final Term predT = content.getPredicate();
//        final Term subjB = beliefContent.getSubject();
//        final Term predB = beliefContent.getPredicate();
//        Term otherTerm;
//
//        if (subjT.hasVarQuery() &amp;&amp; predT.hasVarQuery()) {
//            //System.err.println(&quot;both subj and pred have query; this case is not implemented yet (if it ever occurrs)&quot;);
//            //throw new RuntimeException(&quot;both subj and pred have query; this case is not implemented yet (if it ever occurrs)&quot;);
//        } else if (subjT.hasVarQuery()) {
//            otherTerm = (predT.equals(subjB)) ? predB : subjB;
//            content = Statement.make(content, otherTerm, predT, order);
//        } else if (predT.hasVarQuery()) {
//            otherTerm = (subjT.equals(subjB)) ? predB : subjB;
//            content = Statement.make(content, subjT, otherTerm, order);
//        }
//
//        if (content != null)
//            return p.deriveSingle(content, Symbols.JUDGMENT, newTruth, newBudget);
//
//        return null;
//    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>