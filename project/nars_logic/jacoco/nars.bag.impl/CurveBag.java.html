<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CurveBag.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.bag.impl</a> &gt; <span class="el_source">CurveBag.java</span></div><h1>CurveBag.java</h1><pre class="source lang-java linenums">package nars.bag.impl;

import com.gs.collections.api.block.function.primitive.FloatToFloatFunction;
import nars.bag.BLink;
import nars.bag.Bag;
import nars.budget.Budget;
import nars.budget.BudgetMerge;
import nars.util.data.sorted.SortedIndex;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.Iterator;
import java.util.Random;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * Bag which stores items, sorted, in one array.
 * Removal policy can select items by percentile via the array index.
 * A curve function maps a probabilty distribution to an index allowing the bag
 * to choose items with certain probabilities more than others.
 * &lt;p&gt;
 * In theory, the curve can be calculated to emulate any potential removal policy.
 * &lt;p&gt;
 * Insertion into the array is a O(log(n)) insertion sort, plus O(N) to shift items (unless the array is tree-like and can avoid this cost).
 * Removal is O(N) to shift items, and an additional possible O(N) if a specific item to be removed is not found at the index expected for its current priority value.
 * &lt;p&gt;
 * TODO make a CurveSampling interface with at least 2 implementations: Random and LinearScanning. it will use this instead of the 'boolean random' constructor argument
 */
public class CurveBag&lt;V&gt; implements Bag&lt;V&gt; {

    @NotNull
    final ArrayBag&lt;V&gt; arrayBag;

<span class="fc" id="L36">    public static final BagCurve power2BagCurve = new Power2BagCurve();</span>
<span class="fc" id="L37">    public static final BagCurve power4BagCurve = new Power4BagCurve();</span>
<span class="fc" id="L38">    public static final BagCurve power6BagCurve = new Power6BagCurve();</span>

    //TODO move sampler features to subclass of CurveBag which specifically provides sampling
    public final BagCurve curve;
    private final Random random;

    public CurveBag(int capacity, Random rng) {
<span class="fc" id="L45">        this(</span>
            //CurveBag.power6BagCurve,
            power4BagCurve,
            capacity, rng);
<span class="fc" id="L49">    }</span>


    public CurveBag(BagCurve curve, int capacity, Random rng) {
<span class="fc" id="L53">        this(new ArrayBag.BudgetedArraySortedIndex&lt;&gt;(capacity), curve, rng);</span>

                                /*if (capacity &lt; 128)*/
        //items = new ArraySortedItemList&lt;&gt;(capacity);
                /*else  {
                    //items = new FractalSortedItemList&lt;&gt;(capacity);
                    //items = new RedBlackSortedItemList&lt;&gt;(capacity);
                }*/

<span class="fc" id="L62">    }</span>

    public CurveBag(@NotNull SortedIndex&lt;BLink&lt;V&gt;&gt; items, BagCurve curve, Random rng) {
<span class="fc" id="L65">        super();</span>
<span class="fc" id="L66">        this.arrayBag = new ArrayBag(items);</span>
<span class="fc" id="L67">        this.curve = curve;</span>
<span class="fc" id="L68">        this.random = rng;</span>
<span class="fc" id="L69">    }</span>


    /**
     * set the merging function to 'plus'
     */
    @NotNull
    @Deprecated public Bag&lt;V&gt; mergePlus() {
<span class="fc" id="L77">        arrayBag.setMergeFunction(BudgetMerge.plusDQDominated);</span>
<span class="fc" id="L78">        return this;</span>
    }


//    @Override
//    public CurveBag&lt;V&gt; setMergeFunction(BudgetMerge mergeFunction) {
//        arrayBag.setMergeFunction(mergeFunction);
//        return this;
//    }

    @Nullable
    @Override
    public BLink&lt;V&gt; pop() {
<span class="nc" id="L91">        return peekNext(true);</span>
    }

    @Override
    public void commit() {
<span class="fc" id="L96">        arrayBag.commit();</span>
<span class="fc" id="L97">    }</span>

    @Nullable
    public BLink&lt;V&gt; peekNext(boolean remove) {

<span class="fc" id="L102">        ArrayBag&lt;V&gt; b = this.arrayBag;</span>

<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        while (!isEmpty()) {</span>

<span class="fc" id="L106">            int index = sampleIndex();</span>

<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            BLink&lt;V&gt; i = remove ?</span>
<span class="pc" id="L109">                    b.removeItem(index) : b.getItem(index);</span>

<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            if (!i.getBudget().getDeleted()) {</span>
<span class="fc" id="L112">                return i;</span>
            }

            //ignore this deleted item now that it's removed from the bag
            //if it wasnt already removed above
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (!remove)</span>
<span class="nc" id="L118">                remove(i.get());</span>

<span class="nc" id="L120">        }</span>
<span class="nc" id="L121">        return null; // empty bag</span>
    }



    @Override
    public final void topWhile(@NotNull Predicate each) {
<span class="nc" id="L128">        arrayBag.topWhile(each);</span>
<span class="nc" id="L129">    }</span>

    /** optimized batch fill, using consecutive array elements, also ensuring uniqueness
     * returns the instance for fluentcy
     * */
    @NotNull
    @Override public CurveBag&lt;V&gt; sample(int n, @Nullable Predicate&lt;BLink&lt;V&gt;&gt; each, @NotNull Collection&lt;BLink&lt;V&gt;&gt; target) {

<span class="fc" id="L137">        int ss = size();</span>
        final int begin, end;
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (ss &lt;= n) {</span>
            //special case: give everything
<span class="fc" id="L141">            begin = 0;</span>
<span class="fc" id="L142">            end = ss;</span>
        } else {
<span class="fc" id="L144">            begin = Math.min(sampleIndex(), ss-n);</span>
<span class="fc" id="L145">            end = begin + n;</span>
        }

<span class="fc bfc" id="L148" title="All 2 branches covered.">        for (int i = begin; i &lt; end; i++) {</span>
<span class="fc" id="L149">            BLink&lt;V&gt; ii = get(i);</span>
<span class="pc bpc" id="L150" title="1 of 4 branches missed.">            if (each == null || each.test(ii)) {</span>
<span class="fc" id="L151">                target.add(ii);</span>
            }
        }

<span class="fc" id="L155">        return this;</span>
        //System.out.println(&quot;(of &quot; + ss + &quot;) select &quot; + n + &quot;: &quot; + begin + &quot;..&quot; + end + &quot; = &quot; + target);

    }

    @Override
    public void clear() {
<span class="fc" id="L162">        arrayBag.clear();</span>
<span class="fc" id="L163">    }</span>

    @Override
    public BLink&lt;V&gt; get(Object key) {
<span class="fc" id="L167">        return arrayBag.get(key);</span>
    }

    @Nullable
    @Override
    public final BLink&lt;V&gt; sample() {
<span class="fc" id="L173">        return peekNext(false);</span>
    }

    @Override
    public BLink&lt;V&gt; remove(V key) {
<span class="nc" id="L178">        return arrayBag.remove(key);</span>
    }


    @Nullable
    @Override
    public BLink&lt;V&gt; put(Object v, Budget vBagBudget, float scale) {
<span class="fc" id="L185">        return arrayBag.put(v, vBagBudget, scale);</span>
    }


    @Nullable
    @Override public BLink&lt;V&gt; put(Object v) {
<span class="fc" id="L191">        BLink&lt;V&gt; existing = get(v);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        return (existing != null) ?</span>
<span class="nc" id="L193">                existing :</span>
<span class="fc" id="L194">                put((V) v, getDefaultBudget((V) v));</span>
    }

    @NotNull
    protected BLink&lt;V&gt; getDefaultBudget(V v) {
<span class="fc" id="L199">        return new BLink(v, 0,0,0);</span>
    }

    @Override
    public int capacity() {
<span class="fc" id="L204">        return arrayBag.capacity();</span>
    }


    @Override
    public int size() {
<span class="fc" id="L210">        return arrayBag.size();</span>
    }

    @NotNull
    @Override
    public Iterator&lt;BLink&lt;V&gt;&gt; iterator() {
<span class="fc" id="L216">        return arrayBag.iterator();</span>
    }

    @Override
    public void forEachKey(Consumer&lt;? extends V&gt; each) {
<span class="fc" id="L221">        arrayBag.forEachKey(each);</span>
<span class="fc" id="L222">    }</span>

    //    public static long fastRound(final double d) {
//        if (d &gt; 0) {
//            return (long) (d + 0.5d);
//        } else {
//            return (long) (d - 0.5d);
//        }
//    }
//    


    //    /**
//     * calls overflow() on an overflown object
//     * returns the updated or created concept (not overflow like PUT does (which follows Map.put() semantics)
//     * NOTE: this is the generic version which may or may not work, or be entirely efficient in some subclasses
//     */
//    public V update(final BagTransaction&lt;K, V&gt; selector) {
//
//
//        if (Global.DEBUG &amp;&amp; !isSorted()) {
//            throw new RuntimeException(&quot;not sorted&quot;);
//        }
//
//        K key = selector.name();
//        V item;
//        if (key != null) {
//            item = get(key);
//        }
//        else {
//            item = peekNext();
//        }
//
//        if (item == null) {
//            item = selector.newItem();
//            if (item == null)
//                return null;
//            else {
//                // put the (new or merged) item into itemTable
//                final V overflow = put(item);
//
//                if (overflow != null)
//                    selector.overflow(overflow);
//                else if (overflow == item)
//                    return null;
//
//
//                return item;
//            }
//        } else {
//
//
//            remove(item.name());
//
//            final V changed = selector.update(item);
//
//
//            if (changed == null) {
//
//                put(item);
//
//                return item;
//            }
//            else {
//                //it has changed
//
//
//                final V overflow = put(changed);
//
//                /*if (overflow == changed)
//                    return null;*/
//
//                if (overflow != null) // &amp;&amp; !overflow.name().equals(changed.name()))
//                    selector.overflow(overflow);
//
//                return changed;
//            }
//        }
//
//
//    }

//
//    /**
//     * optimized peek implementation that scans the curvebag
//     * iteratively surrounding a randomly selected point
//     */
//    @Override
//    protected int peekNextFill(BagSelector&lt;K, V&gt; tx, V[] batch, int bstart, int len, int maxAttempts) {
//
//
//        int siz = size();
//        len = Math.min(siz, len);
//
//        List&lt;V&gt; a = arrayBag.items.getList();
//
//        int istart;
//
//        if (len != siz) {
//            //asking for some of the items
//            int r = Math.max(1, len / 2);
//            int center = sample();
//            istart = center + r; //scan downwards from here (increasing pri order)
//
//            if (r % 2 == 1) istart--; //if odd, give extra room to the start (higher priority)
//
//            //TODO test and if possible use more fair policy that accounts for clipping
//            if (istart-r &lt; 0) {
//                istart -= (istart - r); //start further below
//            }
//            if (istart &gt;= siz)
//                istart = siz-1;
//        }
//        else {
//            //optimization: asking for all of the items (len==siz)
//            //   just add all elements, so dont sample
//            istart = siz-1;
//        }
//
//
//        List&lt;K&gt; toRemove = null;
//
//        UnitBudget b = new UnitBudget(); //TODO avoid creating this
//
//
//        //int bend = bstart + len;
//        int next = bstart;
//
//        //scan increasing priority, stopping at the top or if buffer filled
//        for (int i = istart; (i &gt;= 0) &amp;&amp; (next &lt; len); i--) {
//            V v = a.get(i);
//
//            if (v == null) break; //HACK wtf?
//            //throw new RuntimeException(&quot;null&quot;);
//
//            if (v.isDeleted()) {
//                if (toRemove == null) toRemove = Global.newArrayList(0); //TODO avoid creating this
//                toRemove.add(v.name());
//            } else {
//                batch[next++] = v;
//            }
//        }
//
//        //pad with nulls. helpful for garbage collection incase they contain old values (the array is meant to be re-used)
//        if (next != len)
//            Arrays.fill(batch, bstart+next, bstart+len, null);
//
//        //update after they have been selected because this will modify their order in the curvebag
//        for (int i = bstart; i &lt; bstart+next; i++)
//            updateItem(tx, batch[i], b);
//
//
//        if (toRemove != null)
//            toRemove.forEach(this::remove);
//
//        return next; //# of items actually filled in the array
//    }

    @Override public final void top(@NotNull Consumer each) {
<span class="fc" id="L381">        arrayBag.top(each);</span>
<span class="fc" id="L382">    }</span>
    @Override public void topN(int limit, @NotNull Consumer each) {
<span class="nc" id="L384">        arrayBag.topN(limit, each);</span>
<span class="nc" id="L385">    }</span>

    @Override
    public void setCapacity(int c) {
<span class="fc" id="L389">        arrayBag.setCapacity(c);</span>
<span class="fc" id="L390">    }</span>

    /** (utility method specific to curvebag) */
    public boolean isSorted() {
<span class="nc" id="L394">        return arrayBag.isSorted();</span>
    }

    /** (utility method specific to curvebag) */
    public void validate() {
<span class="nc" id="L399">        arrayBag.validate();</span>
<span class="nc" id="L400">    }</span>


    public BLink&lt;V&gt; get(int i) {
<span class="fc" id="L404">        return arrayBag.getItem(i);</span>
    }


    /**
     * Defines the focus curve.  x is a proportion between 0 and 1 (inclusive).
     * x=0 represents low priority (bottom of bag), x=1.0 represents high priority
     *
     * @return
     */

    @FunctionalInterface
    public interface BagCurve extends FloatToFloatFunction {
    }

//    public static class RandomSampler implements ToIntFunction&lt;CurveBag&gt;, Serializable {
//
//        public final BagCurve curve;
//        public final Random rng;
//
//        public RandomSampler(Random rng, BagCurve curve) {
//            this.curve = curve;
//            this.rng = rng;
//        }

    /**
     * maps y in 0..1.0 to an index in [0..size)
     */
    static int index(float y, int size) {
<span class="fc" id="L433">        size--;</span>

<span class="fc" id="L435">        int i = Math.round(y * size);</span>

<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        if (i &gt; size) return size;</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">        if (i &lt; 0) return 0;</span>

<span class="fc" id="L440">        return i;</span>
    }

    @Override
    public float getPriorityMin() {
<span class="fc" id="L445">        return arrayBag.getPriorityMin();</span>
    }
    @Override
    public float getPriorityMax() {
<span class="fc" id="L449">        return arrayBag.getPriorityMax();</span>
    }

    /** provides a next index to sample from */
    public final int sampleIndex() {
<span class="fc" id="L454">        int s = size();</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (s == 1) return 0;</span>

<span class="fc" id="L457">        float x = random.nextFloat();</span>

<span class="fc" id="L459">        BagCurve curve = this.curve;</span>
<span class="fc" id="L460">        float y = curve.valueOf(x);</span>

        //System.out.println(&quot;\t range:&quot; +  min + &quot;..&quot; + max + &quot; -&gt; f(&quot; + x + &quot;)=&quot; + y + &quot;-&gt; &quot; + index);
<span class="fc" id="L463">        return index(y, s);</span>
    }




<span class="nc" id="L469">    public static class CubicBagCurve implements BagCurve {</span>

        @Override
        public final float valueOf(float x) {
            //1.0 - ((1.0-x)^2)
            // a function which has domain and range between 0..1.0 but
            //   will result in values above 0.5 more often than not.  see the curve:
            //http://fooplot.com/#W3sidHlwZSI6MCwiZXEiOiIxLjAtKCgxLjAteCleMikiLCJjb2xvciI6IiMwMDAwMDAifSx7InR5cGUiOjAsImVxIjoiMS4wLSgoMS4wLXgpXjMpIiwiY29sb3IiOiIjMDAwMDAwIn0seyJ0eXBlIjoxMDAwLCJ3aW5kb3ciOlsiLTEuMDYyODU2NzAzOTk5OTk5MiIsIjIuMzQ1MDE1Mjk2IiwiLTAuNDM2NTc0NDYzOTk5OTk5OSIsIjEuNjYwNTc3NTM2MDAwMDAwNCJdfV0-
<span class="nc" id="L477">            float nx = 1.0f - x;</span>
<span class="nc" id="L478">            return 1.0f - (nx * nx * nx);</span>
        }

        @NotNull
        @Override
        public String toString() {
<span class="nc" id="L484">            return &quot;CubicBagCurve&quot;;</span>
        }
    }

<span class="fc" id="L488">    public static class Power4BagCurve implements BagCurve {</span>

        @Override
        public final float valueOf(float x) {
<span class="fc" id="L492">            float nnx = x * x;</span>
<span class="fc" id="L493">            return (nnx * nnx);</span>
        }

        @NotNull
        @Override
        public String toString() {
<span class="nc" id="L499">            return &quot;Power4BagCurve&quot;;</span>
        }
    }

<span class="fc" id="L503">    public static class Power6BagCurve implements BagCurve {</span>

        @Override
        public final float valueOf(float x) {
            /** x=0, y=0 ... x=1, y=1 */
<span class="nc" id="L508">            float nnx = x * x;</span>
<span class="nc" id="L509">            return (nnx * nnx * nnx);</span>
        }

        @NotNull
        @Override
        public String toString() {
<span class="nc" id="L515">            return &quot;Power6BagCurve&quot;;</span>
        }
    }

//    /**
//     * Approximates priority -&gt; probability fairness with an exponential curve
//     */
//    @Deprecated
//    public static class FairPriorityProbabilityCurve implements BagCurve {
//
//        @Override
//        public final float valueOf(float x) {
//            return (float) (1.0f - Math.exp(-5.0f * x));
//        }
//
//        @Override
//        public String toString() {
//            return &quot;FairPriorityProbabilityCurve&quot;;
//        }
//
//    }

<span class="fc" id="L537">    public static class Power2BagCurve implements BagCurve {</span>

        @Override
        public final float valueOf(float x) {
<span class="nc" id="L541">            return (x * x);</span>
        }

        @NotNull
        @Override
        public String toString() {
<span class="nc" id="L547">            return &quot;QuadraticBagCurve&quot;;</span>
        }

    }

    //    @Override
//    protected int update(BagTransaction&lt;K, V&gt; tx, V[] batch, int start, int stop, int maxAdditionalAttempts) {
//
//        super.update()
//        int center = this.sampler.applyAsInt(this);
//
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>