<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Memory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars</a> &gt; <span class="el_source">Memory.java</span></div><h1>Memory.java</h1><pre class="source lang-java linenums">/*
 * Memory.java
 *
 * Copyright (C) 2008  Pei Wang
 *
 * This file is part of Open-NARS.
 *
 * Open-NARS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Open-NARS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Open-NARS.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package nars;


import com.gs.collections.api.tuple.Twin;
import nars.bag.Bag;
import nars.bag.impl.CurveBag;
import nars.concept.AtomConcept;
import nars.concept.Concept;
import nars.concept.ConceptProcess;
import nars.concept.DefaultConcept;
import nars.nal.nal8.Execution;
import nars.nal.space.Space;
import nars.nal.space.SpaceConcept;
import nars.task.Task;
import nars.term.Term;
import nars.term.TermIndex;
import nars.term.Termed;
import nars.term.atom.Atom;
import nars.term.compound.Compound;
import nars.term.transform.CompoundTransform;
import nars.term.variable.Variable;
import nars.time.Clock;
import nars.util.data.random.XorShift128PlusRandom;
import nars.util.event.DefaultTopic;
import nars.util.event.EventEmitter;
import nars.util.event.Topic;
import nars.util.meter.EmotionMeter;
import nars.util.meter.LogicMeter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.function.Function;

/**
 * Memory consists of the run-time state of a NAR, including: * term and concept
 * memory * clock * reasoner state * etc.
 * &lt;p&gt;
 * Excluding input/output channels which are managed by a NAR.
 * &lt;p&gt;
 * A memory is controlled by zero or one NAR's at a given time.
 * &lt;p&gt;
 * Memory is serializable so it can be persisted and transported.
 */
public class Memory extends Param {

    protected Atom self;

    public final Random random;

    @NotNull
    @Deprecated
    public final transient EventEmitter&lt;Class, Object[]&gt; event;

<span class="fc" id="L80">    public final transient Topic&lt;Task&gt; eventTaskRemoved = new DefaultTopic&lt;&gt;();</span>
<span class="fc" id="L81">    public final transient Topic&lt;ConceptProcess&gt; eventConceptProcess = new DefaultTopic&lt;&gt;();</span>
<span class="fc" id="L82">    public final transient Topic&lt;Task&gt; eventRevision = new DefaultTopic&lt;&gt;();</span>

<span class="fc" id="L84">    public final transient Topic&lt;Memory&gt; eventReset = new DefaultTopic&lt;&gt;();</span>

<span class="fc" id="L86">    public final transient Topic&lt;NAR&gt; eventFrameStart = new DefaultTopic&lt;&gt;();</span>

    /**
     * fired at the end of each memory cycle
     */
<span class="fc" id="L91">    public final transient Topic&lt;Memory&gt; eventCycleEnd = new DefaultTopic&lt;&gt;(); //eventCycleStart; //new DefaultObserved();</span>

<span class="fc" id="L93">    public final transient Topic&lt;Task&gt; eventTaskProcess = new DefaultTopic&lt;&gt;();</span>

<span class="fc" id="L95">    public static final Logger logger = LoggerFactory.getLogger(Memory.class);</span>

    /**
     * used for reporting or informing outside. consists of additional notes
     * or data which could annotate a log or summary of system activity
     */
<span class="fc" id="L101">    public final transient Topic&lt;Object&gt; eventSpeak = new DefaultTopic&lt;&gt;();</span>



<span class="fc" id="L105">    public final transient Topic&lt;Task&gt; eventInput = new DefaultTopic&lt;&gt;();</span>
<span class="fc" id="L106">    public final transient Topic&lt;Serializable&gt; eventError = new DefaultTopic&lt;&gt;();</span>

    /** all derivations, even if they do not eventually reach the memory via input;
     *  this generates many events, use with caution
     */
<span class="fc" id="L111">    public final transient Topic&lt;Task&gt; eventDerived = new DefaultTopic&lt;&gt;();</span>

<span class="fc" id="L113">    public final transient Topic&lt;Twin&lt;Task&gt;&gt; eventAnswer = new DefaultTopic&lt;&gt;();</span>
<span class="fc" id="L114">    public final transient Topic&lt;Concept&gt; eventConceptChanged = new DefaultTopic();</span>

    /** executables (incl. operators) */
<span class="fc" id="L117">    public final transient Map&lt;Term, Topic&lt;Execution&gt;&gt; exe = new HashMap();</span>



    //TODO move these to separate components, not part of Memory:
    @NotNull
    public final transient EmotionMeter emotion;
    @NotNull
    public final transient LogicMeter logic;

    @NotNull
    public final Clock clock;

    /** holds known Term's and Concept's */
    public final TermIndex index;


    /** maximum NAL level currently supported by this memory, for restricting it to activity below NAL8 */
    int level;

    /** for creating new stamps
     * TODO move this to and make this the repsonsibility of Clock implementations
     * */
<span class="fc" id="L140">    long currentStampSerial = 1;</span>


    public Memory(@NotNull Clock clock, TermIndex index) {
<span class="fc" id="L144">        this(clock, new XorShift128PlusRandom(1), index);</span>
<span class="fc" id="L145">    }</span>

    /**
     * Create a new memory
     */
<span class="fc" id="L150">    public Memory(@NotNull Clock clock, Random rng, TermIndex index) {</span>

<span class="fc" id="L152">        random = rng;</span>

<span class="fc" id="L154">        level = 8;</span>

<span class="fc" id="L156">        this.clock = clock;</span>
<span class="fc" id="L157">        clock.clear(this);</span>

<span class="fc" id="L159">        this.index = index;</span>


<span class="fc" id="L162">        self = Global.DEFAULT_SELF; //default value</span>

<span class="fc" id="L164">        event = new EventEmitter.DefaultEventEmitter();</span>


        //temporary
<span class="fc" id="L168">        logic = new LogicMeter(this);</span>
<span class="fc" id="L169">        emotion = new EmotionMeter(this);</span>


<span class="fc" id="L172">    }</span>



    @Override
    public final int nal() {
<span class="fc" id="L178">        return level;</span>
    }

    public final void nal(int newLevel) {
<span class="fc" id="L182">        level = newLevel;</span>
<span class="fc" id="L183">    }</span>


//    public Concept concept(final String t) {
//        return concept(Atom.the(t));
//    }

//    /** provides fast iteration to concepts with questions */
//    public Set&lt;Concept&gt; getQuestionConcepts() {
//        return questionConcepts;
//    }
//
//    /** provides fast iteration to concepts with goals */
//    public Set&lt;Concept&gt; getGoalConcepts() {
//        throw new RuntimeException(&quot;disabled until it is useful&quot;);
//        //return goalConcepts;
//    }


    public final Atom self() {
<span class="nc" id="L203">        return self;</span>
    }

    public void setSelf(Atom t) {
<span class="nc" id="L207">        self = t;</span>
<span class="nc" id="L208">    }</span>


//    public void delete() {
//        clear();
//
//        event.delete();
//    }


    @Override
    public synchronized void clear() {

<span class="fc" id="L221">        eventReset.emit(this);</span>

<span class="fc" id="L223">        clock.clear(this);</span>

<span class="fc" id="L225">        index.clear();</span>

<span class="fc" id="L227">        emotion.clear();</span>

<span class="fc" id="L229">    }</span>


//    Concept concept(Compound c, CompoundTransform transform) {
//        return concept(index.transform(c, transform));
//    }

    static boolean validConceptTerm(Term term) {
<span class="fc bfc" id="L237" title="All 2 branches covered.">        return !(term instanceof Variable);</span>
    }

    @NotNull
    Concept newDefaultConcept(Term t) {

<span class="fc" id="L243">        int termLinkBagSize = 32;</span>
<span class="fc" id="L244">        int taskLinkBagSize = 32;</span>

<span class="fc" id="L246">        Bag&lt;Task&gt; taskLinks =</span>
<span class="fc" id="L247">                new CurveBag&lt;Task&gt;(taskLinkBagSize, random).mergePlus();</span>

<span class="fc" id="L249">        Bag&lt;Termed&gt; termLinks =</span>
<span class="fc" id="L250">                new CurveBag&lt;Termed&gt;(termLinkBagSize, random).mergePlus();</span>

<span class="fc bfc" id="L252" title="All 2 branches covered.">        return (t instanceof Atom) ?</span>

<span class="fc" id="L254">            new AtomConcept(t, termLinks, taskLinks) :</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">            ((!(t instanceof Space)) ?</span>

<span class="fc" id="L258">                new DefaultConcept(t, taskLinks, termLinks, this) :</span>

<span class="fc" id="L260">                new SpaceConcept((Space)t, taskLinks, termLinks, this));</span>
    }

    @Nullable
    public Concept concept(Termed t) {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (t instanceof Concept) return ((Concept)t);</span>

<span class="fc" id="L267">        Term tt = t.term();</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (!validConceptTerm(tt)) return null;</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (!tt.isNormalized()) {</span>
<span class="fc" id="L270">            t = index.normalized(tt);</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">            if (t instanceof Concept)</span>
<span class="nc" id="L272">                return ((Concept)t);</span>
<span class="fc" id="L273">            tt = t.term();</span>
        }

        //TODO ? put the unnormalized term for cached future normalizations?

<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (tt.isCompound() ) {</span>

<span class="fc" id="L280">            tt = tt.anonymous();</span>

<span class="fc" id="L282">            tt = index.transform((Compound)tt, CompoundAnonymizer);</span>
        }

<span class="fc" id="L285">        Function&lt;Term, Termed&gt; build = this::newDefaultConcept;</span>
<span class="fc" id="L286">        Termed exists = index.apply(tt, build);</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (exists instanceof Concept) {</span>
<span class="fc" id="L289">            return ((Concept)exists);</span>
        }

<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (exists==null)</span>
<span class="nc" id="L293">            exists = t;</span>

        //attempt replace entry from term to concept
<span class="fc" id="L296">        Termed tx = build.apply(exists.term());</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (tx instanceof Concept) {</span>
<span class="fc" id="L298">            index.putTerm(tx);</span>
<span class="fc" id="L299">            return (Concept) tx;</span>
        }


<span class="nc" id="L303">        return null;</span>
    }


    public final Concept taskConcept(Termed t) {
<span class="nc" id="L308">        Concept c = concept(t);</span>

<span class="nc bnc" id="L310" title="All 6 branches missed.">        if (c == null || (!c.levelValid( nal()) ) || (!Task.validTaskTerm(c.term())))</span>
<span class="nc" id="L311">            return null;</span>

<span class="nc" id="L313">        return c;</span>
    }



//    public void add(final Iterable&lt;Task&gt; source) {
//        for (final Task t : source)
//            add((Task) t);
//    }

    /** current temporal perception duration of the reasoner */
    public final int duration() {
<span class="fc" id="L325">        return duration.intValue();</span>
    }






    /* ---------- new task entries ---------- */

    /**
     * called anytime a task has been removed, deleted, discarded, ignored, etc.
     */
    public final void remove(@NotNull Task task, @Nullable Object removalReason) {

<span class="fc bfc" id="L340" title="All 2 branches covered.">        boolean willBeReceived = !eventTaskRemoved.isEmpty();</span>

<span class="pc bpc" id="L342" title="1 of 4 branches missed.">        if (willBeReceived &amp;&amp; removalReason!=null)</span>
<span class="fc" id="L343">            task.log(removalReason);</span>

<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (!task.getDeleted()) {</span>

<span class="fc" id="L347">            task.getBudget().delete();</span>

<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (willBeReceived) {</span>

                /*if (Global.DEBUG_DERIVATION_STACKTRACES &amp;&amp; Global.DEBUG_TASK_LOG)
                    task.log(Premise.getStack());*/

<span class="fc" id="L354">                eventTaskRemoved.emit(task);</span>
            }
            /* else: a more destructive cleanup of the discarded task? */
        }

<span class="fc" id="L359">    }</span>

//    /**
//     * sends an event signal to listeners subscribed to channel 'c'
//     */
//    final public void emit(final Class c, final Object... signal) {
//        event.emit(c, signal);
//    }

//    /**
//     * sends an event signal to listeners subscribed to channel 'c'
//     */
//    final public void emit(final Class c) {
//        event.emit(c);
//    }


    /**
     * produces a new stamp serial #, used to uniquely identify inputs
     */
    public final long newStampSerial() {
        //TODO maybe AtomicLong ?
<span class="fc" id="L381">        return currentStampSerial++;</span>
    }

//    /** whether the NAR is currently accepting new inputs */
//    public boolean isInputting() {
//        if (inputPausedUntil == -1) return true;
//        return time() &gt;= inputPausedUntil;
//    }


//    /**
//     * samples a next active concept for processing;
//     * may return null if no concept is available depending on the control system
//     */
//    public Concept nextConcept() {
//        return getCycleProcess().nextConcept();
//    }
//
//    /** scan for a next concept matching the predicate */
//    public Concept nextConcept(Predicate&lt;Concept&gt; pred, float v) {
//        return getCycleProcess().nextConcept(pred, v);
//    }



//    /**
//     * TODO return value
//     */
//    public void delete(Term term) {
//        Concept c = concept(term);
//        if (c == null) return;
//
//        delete(c);
//    }

//    /** queues the deletion of a concept until after the current cycle ends.
//     */
//    public synchronized void delete(Concept c) {
//        if (!inCycle()) {
//            //immediately delete
//            _delete(c);
//        }
//        else {
//            pendingDeletions.add(c);
//        }
//
//    }
//
//    /** called by Memory at end of each cycle to flush deleted concepts */
//    protected void deletePendingConcepts() {
//        if (!pendingDeletions.isEmpty()) {
//
//            for (Concept c : pendingDeletions)
//                _delete(c);
//
//            pendingDeletions.clear();
//        }
//    }
//
//    /**
//     * actually delete procedure for a concept; removes from indexes
//     * TODO return value
//     */
//    protected void delete(Concept c) {
//
////        Concept removedFromActive = getCycleProcess().remove(c);
////
////        if (c!=removedFromActive) {
////            throw new RuntimeException(&quot;another instances of active concept &quot; + c + &quot; detected on removal: &quot; + removedFromActive);
////        }
//
//        Concept removedFromIndex = concepts.remove(c.getTerm());
//        if (removedFromIndex == null) {
//            throw new RuntimeException(&quot;concept &quot; + c + &quot; was not removed from memory&quot;);
//        }
//        /*if (c!=removedFromIndex) {
//            throw new RuntimeException(&quot;another instances of concept &quot; + c + &quot; detected on removal: &quot; + removedFromActive);
//        }*/
//
//        c.delete();
//    }


//    @Override
//    public final boolean equals(Object obj) {
//        if (this == obj) return true;
//        if (!(obj instanceof Memory)) return false;
//        return Memory.equals(this, (Memory) obj);
//    }

//    public static boolean equals(final Memory a, final Memory b) {
//
//        //TODO
//        //for now, just accept that they include the same set of terms
//
//        Set&lt;Term&gt; aTerm = new LinkedHashSet();
//        Set&lt;Term&gt; bTerm = new LinkedHashSet();
//        a.concepts.forEach(ac -&gt; aTerm.add(ac.getTerm()));
//        b.concepts.forEach(bc -&gt; bTerm.add(bc.getTerm()));
//        if (!aTerm.equals(bTerm)) {
//            /*System.out.println(aTerm.size() + &quot; &quot; + aTerm);
//            System.out.println(bTerm.size() + &quot; &quot; + bTerm);*/
//            return false;
//        }
//
//
//        /*if (!a.concepts.equals(b.concepts)) {
//
//        }*/
//        return true;
//    }

    public final long time() {
<span class="fc" id="L494">        return clock.time();</span>
    }

//    public final void put(final Concept c) {
//        concepts.put(c);
//    }

    public final void cycle(int num) {

        //final Clock clock = this.clock;
<span class="fc" id="L504">        Topic&lt;Memory&gt; eachCycle = eventCycleEnd;</span>

        //synchronized (clock) {

<span class="fc bfc" id="L508" title="All 2 branches covered.">            for (; num &gt; 0; num--) {</span>


<span class="fc" id="L511">                eachCycle.emit(this);</span>

            }

        //}

<span class="fc" id="L517">    }</span>


//    /** called when a Concept's lifecycle has changed */
//    public void updateConceptState(Concept c) {
//        boolean hasQuestions = c.hasQuestions();
//        boolean hasGoals = !c.getGoals().isEmpty();
//
//        if (isActive(c)) {
//            //index an incoming concept with existing questions or goals
//            if (hasQuestions) updateConceptQuestions(c);
//            //if (hasGoals) updateConceptGoals(c);
//        }
//        else  {
//            //unindex an outgoing concept with questions or goals
//            if (hasQuestions) questionConcepts.remove(c);
//            //..
//        }
//
//    }
//
//    /** handles maintenance of concept question/goal indices when concepts change according to reports by certain events
//        called by a Concept when its questions state changes (becomes empty or becomes un-empty) */
//    public void updateConceptQuestions(Concept c) {
//        if (!c.hasQuestions() &amp;&amp; !c.hasQuests()) {
//            if (!questionConcepts.remove(c))
//                throw new RuntimeException(&quot;Concept &quot; + c + &quot; never registered any questions&quot;);
//        }
//        else {
//            if (!questionConcepts.add(c)) {
//                throw new RuntimeException(&quot;Concept &quot; + c + &quot; aready registered existing questions&quot;);
//            }
//
//            //this test was cycle.size() previously:
//            if (questionConcepts.size() &gt; getCycleProcess().size()) {
//                throw new RuntimeException(&quot;more questionConcepts &quot; +questionConcepts.size() + &quot; than concepts &quot; + getCycleProcess().size());
//            }
//        }
//    }
//
//    public void updateConceptGoals(Concept c) {
//        //TODO
//    }


    //    private String toStringLongIfNotNull(Bag&lt;?, ?&gt; item, String title) {
//        return item == null ? &quot;&quot; : &quot;\n &quot; + title + &quot;:\n&quot;
//                + item.toString();
//    }
//
//    private String toStringLongIfNotNull(Item item, String title) {
//        return item == null ? &quot;&quot; : &quot;\n &quot; + title + &quot;:\n&quot;
//                + item.toStringLong();
//    }
//
//    private String toStringIfNotNull(Object item, String title) {
//        return item == null ? &quot;&quot; : &quot;\n &quot; + title + &quot;:\n&quot;
//                + item.toString();
//    }

    @NotNull
    @Override
    public String toString() {
<span class="fc" id="L580">        return getClass().getSimpleName() + ':' + nal() + &quot;[@&quot; + time() + &quot;,C=&quot; + size() + ']';</span>
    }

    public final int size() {
<span class="fc" id="L584">        return index.size();</span>
    }

//    /**
//     * identifies the type of memory as a string
//     */
//    String toTypeString() {
//        return getClass().getSimpleName();
//    }

    public void start() {

<span class="fc" id="L596">    }</span>

<span class="fc" id="L598">    final static CompoundTransform CompoundAnonymizer = new CompoundTransform&lt;Compound,Term&gt;() {</span>

        @Override public boolean test(Term term) {
<span class="fc" id="L601">            return true;</span>
        }

        @Override public Term apply(Compound parent, @NotNull Term subterm, int depth) {
<span class="fc" id="L605">            return subterm.anonymous();</span>
        }
    };


    //    public byte[] toBytes() throws IOException, InterruptedException {
//        //TODO probably will want to do something more careful
//        return new JBossMarshaller().objectToByteBuffer(this);
//    }

    //public Iterator&lt;Concept&gt; getConcepts(boolean active, boolean inactive) {
//        if (active &amp;&amp; !inactive)
//            return getControl().iterator();
//        else if (!active &amp;&amp; inactive)
//            return Iterators.filter(concepts.iterator(), c -&gt; isActive(c));
//        else if (active &amp;&amp; inactive)
//            return concepts.iterator(); //'concepts' should contain all concepts
//        else
//            return Iterators.emptyIterator();
//    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>