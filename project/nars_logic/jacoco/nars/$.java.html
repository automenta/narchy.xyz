<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>$.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars</a> &gt; <span class="el_source">$.java</span></div><h1>$.java</h1><pre class="source lang-java linenums">package nars;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.ConsoleAppender;
import nars.java.AtomObject;
import nars.nal.Tense;
import nars.nal.nal8.Operator;
import nars.task.MutableTask;
import nars.task.Task;
import nars.term.*;
import nars.term.atom.Atom;
import nars.term.compound.Compound;
import nars.term.compound.GenericCompound;
import nars.term.match.VarPattern;
import nars.term.variable.Variable;
import nars.truth.Truth;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

import static java.util.stream.Collectors.toList;
import static nars.Op.*;

/**
 * core utility class for:
    --building any type of value, either programmatically or parsed from string input
       (which can be constructed in a static context)
    --??
 */
<span class="pc" id="L38">public enum $  {</span>
    ;

<span class="fc" id="L41">    public static final TermBuilder terms = new TermBuilder() {</span>

        @NotNull
        @Override
        public Termed make(Op op, int relation, TermContainer subterms, int dt) {
<span class="fc" id="L46">            return new GenericCompound(op, relation, (TermVector)subterms);</span>
        }
    };


<span class="fc" id="L51">    public static final org.slf4j.Logger logger = LoggerFactory.getLogger($.class);</span>
<span class="fc" id="L52">    public static final Function&lt;Object, Term&gt; ToStringToTerm = (x) -&gt; $.the(x.toString());</span>

    public static &lt;T extends Term&gt; T $(String term) {
<span class="fc" id="L55">        Termed normalized = Narsese.the().term(term, terms);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">        if (normalized!=null)</span>
<span class="fc" id="L57">            return (T)(normalized.term());</span>
<span class="fc" id="L58">        return null;</span>

        //        try { }
        //        catch (InvalidInputException e) { }
    }

    @Deprecated public static &lt;C extends Compound&gt; MutableTask $(String term, char punc) {
<span class="fc" id="L65">        Term t = Narsese.the().term(term).term();</span>
        //TODO normalize etc
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (!Task.validTaskTerm(t))</span>
<span class="nc" id="L68">            return null;</span>

<span class="fc" id="L70">        return new MutableTask(t)</span>
<span class="fc" id="L71">                .punctuation(punc)</span>
<span class="fc" id="L72">                .eternal();</span>
                //.normalized();
    }

    @NotNull
    public static &lt;O&gt; AtomObject&lt;O&gt; ref(String term, O instance) {
<span class="nc" id="L78">        return new AtomObject(term, instance);</span>
    }

    @NotNull
    public static Atom the(String id) {
<span class="fc" id="L83">        return Atom.the(id);</span>
    }

    @NotNull
    public static Atom[] the(@NotNull String... id) {
<span class="fc" id="L88">        int l = id.length;</span>
<span class="fc" id="L89">        Atom[] x = new Atom[l];</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        for (int i = 0; i &lt; l; i++)</span>
<span class="fc" id="L91">            x[i] = Atom.the(id[i]);</span>
<span class="fc" id="L92">        return x;</span>
    }


    public static Atom the(int i) {
<span class="nc" id="L97">        return Atom.the(i);</span>
    }

    /**
     * Op.INHERITANCE from 2 Terms: subj --&gt; pred
     *  returns a Term if the two inputs are equal to each other
     */
    @Nullable
    public static Term inh(Term subj, Term pred) {

//        if ((predicate instanceof Operator) &amp;&amp; if (subject instanceof Product))
//            return new GenericCompound(Op.INHERITANCE, (Operator)predicate, (Product)subject);
//        else

<span class="fc" id="L111">        return the(INHERIT, subj, pred);</span>
    }


    @Nullable
    public static Term inh(String subj, String pred) {
<span class="fc" id="L117">        return inh((Term)$(subj), $(pred));</span>
    }


    @Nullable
    public static Term sim(Term subj, Term pred) {
<span class="fc" id="L123">        return the(SIMILAR, subj, pred);</span>
    }

    @NotNull
    public static Compound oper(String operator, String... args) {
<span class="fc" id="L128">        return oper(Operator.the(operator), $.p(args));</span>
    }


    @NotNull
    public static Compound oper(Operator opTerm, Term... arg) {
<span class="fc" id="L134">        return oper(opTerm, $.p(arg));</span>
    }

//    static Compound oper(Atom opTerm, Compound args) {
//        return oper(new Operator(opTerm), args);
//    }

    @NotNull
    static Compound oper(Operator opTerm, @Nullable Compound arg) {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        return (Compound) the(</span>
                INHERIT,
<span class="pc" id="L145">                arg == null ? TermIndex.Empty : arg,</span>
                opTerm
        );
    }


    @Nullable
    public static Term impl(Term a, Term b) {
<span class="fc" id="L153">        return the(IMPLICATION, a, b);</span>
    }

    @Nullable
    public static Term neg(Term x) {
<span class="fc" id="L158">        return the(NEGATE, x);</span>
    }

    @NotNull
    public static &lt;T extends Term&gt; Compound&lt;T&gt; p(@NotNull Collection&lt;? super T&gt; t) {
<span class="fc" id="L163">        return $.p(t.toArray((T[]) new Term[t.size()]));</span>
    }

    @NotNull
    public static Compound p(@Nullable Term... t) {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (t == null)</span>
<span class="nc" id="L169">            return TermIndex.Empty;</span>

<span class="fc" id="L171">        int l = t.length;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (l == 0) //length 0 product are allowd and shared</span>
<span class="fc" id="L173">            return TermIndex.Empty;</span>

<span class="fc" id="L175">        return (Compound) the(PRODUCT, t);</span>
    }

    /** creates from a sublist of a list */
    @NotNull
    static Compound p(@NotNull List&lt;Term&gt; l, int from, int to) {
<span class="fc" id="L181">        Term[] x = new Term[to - from];</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (int j = 0, i = from; i &lt; to; i++)</span>
<span class="fc" id="L184">            x[j++] = l.get(i);</span>

<span class="fc" id="L186">        return $.p(x);</span>
    }

    @NotNull
    public static Compound&lt;Atom&gt; p(String... t) {
<span class="fc" id="L191">        return $.p((Atom[]) $.the(t));</span>
    }

    @NotNull
    public static Variable v(@NotNull Op type, String s) {
<span class="fc" id="L196">        return v(type.ch, s);</span>
    }


    @NotNull
    public static Variable varDep(int i) {
<span class="nc" id="L202">        return v(VAR_DEP, i);</span>
    }

    @NotNull
    public static Variable varDep(String s) {
<span class="fc" id="L207">        return v(VAR_DEP, s);</span>
    }

    @NotNull
    public static Variable varIndep(int i) {
<span class="nc" id="L212">        return v(VAR_INDEP, i);</span>
    }

    @NotNull
    public static Variable varIndep(String s) {
<span class="nc" id="L217">        return v(VAR_INDEP, s);</span>
    }

    @NotNull
    public static Variable varQuery(int i) {
<span class="nc" id="L222">        return v(VAR_QUERY, i);</span>
    }

    @NotNull
    public static Variable varQuery(String s) {
<span class="nc" id="L227">        return v(VAR_QUERY, s);</span>
    }

    @NotNull
    public static VarPattern varPattern(int i) {
<span class="fc" id="L232">        return (VarPattern) v(VAR_PATTERN, i);</span>
    }


    /**
     * Try to make a new compound from two components. Called by the logic rules.
     * &lt;p&gt;
     *  A {-- B becomes {A} --&gt; B
     * @param subj The first component
     * @param pred The second component
     * @return A compound generated or null
     */
    @Nullable
    public static Term inst(Term subj, Term pred) {
<span class="fc" id="L246">        return terms.inst(subj, pred);</span>
    }
    @Nullable
    public static Term instprop(Term subject, Term predicate) {
<span class="nc" id="L250">        return terms.instprop(subject, predicate);</span>
    }
    @Nullable
    public static Term prop(Term subject, Term predicate) {
<span class="nc" id="L254">        return terms.prop(subject, predicate);</span>
    }

//    public static Term term(final Op op, final Term... args) {
//        return Terms.term(op, args);
//    }

    @NotNull
    public static MutableTask belief(Compound term, @NotNull Truth copyFrom) {
<span class="fc" id="L263">        return belief(term, copyFrom.getFrequency(), copyFrom.getConfidence());</span>
    }

    @NotNull
    public static MutableTask belief(Compound term, float freq, float conf) {
<span class="fc" id="L268">        return new MutableTask(term).belief().truth(freq, conf);</span>
    }

    @NotNull
    public static MutableTask goal(Compound term, float freq, float conf) {
<span class="fc" id="L273">        return new MutableTask(term).goal().truth(freq, conf);</span>
    }

    @NotNull
    public static Compound sete(@NotNull Collection&lt;? extends Term&gt; t) {
<span class="fc" id="L278">        return (Compound) the(SET_EXT, t);</span>
    }

   private static Term[] array(@NotNull Collection&lt;? extends Term&gt; t) {
<span class="nc" id="L282">        return t.toArray(new Term[t.size()]);</span>
    }

    @NotNull
    public static Compound seti(@NotNull Collection&lt;Term&gt; t) {
<span class="nc" id="L287">        return $.seti(array(t));</span>
    }

    @NotNull
    public static Compound sete(Term... t) {
<span class="fc" id="L292">        return (Compound) the(SET_EXT, t);</span>
    }

    /** shorthand for extensional set */
    @NotNull
    public static Compound s(Term... t) {
<span class="nc" id="L298">        return sete(t);</span>
    }

    @NotNull
    public static Compound seti(Term... t) {
<span class="fc" id="L303">        return (Compound) the(SET_INT, t);</span>
    }

    /**
     * Try to make a new compound from two components. Called by the logic rules.
     * &lt;p&gt;
     *  A --] B becomes A --&gt; [B]
     * @param subject The first component
     * @param predicate The second component
     * @return A compound generated or null
     */
    @Nullable
    public static Term property(Term subject, Term predicate) {
<span class="nc" id="L316">        return inh(subject, $.seti(predicate));</span>
    }

    @NotNull
    public static Variable v(char ch, String name) {

//        if (name.length() &lt; 3) {
//            int digit = Texts.i(name, -1);
//            if (digit != -1) {
//                Op op = Variable.typeIndex(ch);
//                return Variable.the(op, digit);
//            }
//        }

<span class="pc bpc" id="L330" title="1 of 5 branches missed.">        switch (ch) {</span>
            case Symbols.VAR_DEPENDENT:
<span class="fc" id="L332">                return new Variable.VarDep(name);</span>
            case Symbols.VAR_INDEPENDENT:
<span class="fc" id="L334">                return new Variable.VarIndep(name);</span>
            case Symbols.VAR_QUERY:
<span class="fc" id="L336">                return new Variable.VarQuery(name);</span>
            case Symbols.VAR_PATTERN:
<span class="fc" id="L338">                return new VarPattern(name);</span>
            default:
<span class="nc" id="L340">                throw new RuntimeException(&quot;invalid variable type: &quot; + ch);</span>
        }

    }

    @NotNull
    public static Variable v(@NotNull Op type, int counter) {
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (counter &lt; Variable.MAX_VARIABLE_CACHED_PER_TYPE) {</span>
<span class="fc" id="L348">            Variable[] vct = Variable.varCache[typeIndex(type)];</span>
<span class="fc" id="L349">            Variable existing = vct[counter];</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            return existing != null ? existing : (vct[counter] = v(type.ch, String.valueOf(counter)));</span>
        }

<span class="nc" id="L353">        return v(type.ch, String.valueOf(counter));</span>
    }

    @Nullable
    public static Term conj(Term... a) {
<span class="fc" id="L358">        return the(CONJUNCTION, a);</span>
    }

    @Nullable
    public static Term disj(Term... a) {
<span class="fc" id="L363">        return the(DISJUNCTION, a);</span>
    }

    static {
//        // assume SLF4J is bound to logback in the current environment
//        LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();
//
//        try {
//            JoranConfigurator configurator = new JoranConfigurator();
//            configurator.setContext(context);
//            // Call context.reset() to clear any previous configuration, e.g. default
//            // configuration. For multi-step configuration, omit calling context.reset().
//            context.reset();
//            //configurator.doConfigure(args[0]);
//        } catch (Exception je) {
//            // StatusPrinter will handle this
//        }
//        StatusPrinter.printInCaseOfErrorsOrWarnings(context);
//
//        Logger logger = LoggerFactory.getLogger($.class);
//        logger.info(&quot;Entering application.&quot;);
//
//
//
//        logger.info(&quot;Exiting application.&quot;);
//
//        LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
//        // print logback's internal status
//        StatusPrinter.print(lc);
//
//        // assume SLF4J is bound to logback-classic in the current environment
//        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
//        loggerContext.start();
//        //loggerContext.stop();
    }

    @NotNull
    public static final Logger logRoot;

    /** NALogging non-axiomatic logging encoder. log events expressed in NAL terms */
    @NotNull
    public static final PatternLayoutEncoder logEncoder;

    static {
<span class="fc" id="L407">        Thread.currentThread().setName(&quot;$&quot;);</span>

        //http://logback.qos.ch/manual/layouts.html

<span class="fc" id="L411">        logRoot = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);</span>

<span class="fc" id="L413">        LoggerContext loggerContext = logRoot.getLoggerContext();</span>
        // we are not interested in auto-configuration
<span class="fc" id="L415">        loggerContext.reset();</span>

<span class="fc" id="L417">        logEncoder = new PatternLayoutEncoder();</span>
<span class="fc" id="L418">        logEncoder.setContext(loggerContext);</span>
<span class="fc" id="L419">        logEncoder.setPattern(&quot;\\( %highlight(%level),%green(%thread),%yellow(%logger{0}) \\): \&quot;%message\&quot;.%n&quot;);</span>
<span class="fc" id="L420">        logEncoder.start();</span>


<span class="fc" id="L423">        ConsoleAppender&lt;ILoggingEvent&gt; appender = new ConsoleAppender&lt;&gt;();</span>
<span class="fc" id="L424">        appender.setContext(loggerContext);</span>
<span class="fc" id="L425">        appender.setEncoder(logEncoder);</span>
<span class="fc" id="L426">        appender.start();</span>
<span class="fc" id="L427">        logRoot.addAppender(appender);</span>

//        rootLogger.debug(&quot;Message 1&quot;);
//        rootLogger.info(&quot;Message 1&quot;);
//        rootLogger.warn(&quot;Message 2&quot;);
//        rootLogger.error(&quot;Message 2&quot;);
<span class="fc" id="L433">    }</span>

    @Nullable
    public static Term equiv(Term subject, Term pred) {
<span class="fc" id="L437">        return the(EQUIV, subject, pred);</span>
    }

    @Nullable
    public static Term diffInt(Term a, Term b) {
<span class="fc" id="L442">        return the(DIFF_INT, a, b);</span>
    }

    @Nullable
    public static Term diffExt(Term a, Term b) {
<span class="fc" id="L447">        return the(DIFF_EXT, a, b);</span>
    }

    @Nullable
    public static Term imageExt(Term... x) {
<span class="nc" id="L452">        return the(IMAGE_EXT, x);</span>
    }
    @Nullable
    public static Term imageInt(Term... x) {
<span class="nc" id="L456">        return the(IMAGE_INT, x);</span>
    }
    @Nullable
    public static Term sect(Term... x) {
<span class="fc" id="L460">        return the(INTERSECT_EXT, x);</span>
    }
    @Nullable
    public static Term sectInt(Term... x) {
<span class="fc" id="L464">        return the(INTERSECT_INT, x);</span>
    }


    @NotNull
    public static Operator operator(String name) {
<span class="fc" id="L470">        return new Operator($.the(name));</span>
    }


    @Nullable
    public static Term the(@NotNull Op op, Term... subterms) {
<span class="fc" id="L476">        return the(op, -1, subterms);</span>
    }
    @Nullable
    public static Term the(@NotNull Op op, int relation, Term... subterms) {
<span class="fc" id="L480">        return the(op, relation, TermContainer.the(op, subterms));</span>
    }

    @Nullable
    public static Term the(@NotNull Op op, @NotNull Collection&lt;? extends Term&gt; subterms) {
<span class="fc" id="L485">        return the(op, -1, subterms);</span>
    }
    @Nullable
    public static Term the(@NotNull Op op, int relation, @NotNull Collection&lt;? extends Term&gt; subterms) {
<span class="fc" id="L489">        return the(op, relation, TermContainer.the(op, subterms));</span>
    }

    @Nullable
    public static Term the(@NotNull Op op, int relation, TermContainer subterms) {
<span class="fc" id="L494">        return the(op, relation, Tense.ITERNAL, subterms);</span>
    }

    @Nullable
    public static Term the(@NotNull Op op, int relation, int t, TermContainer subterms) {
<span class="fc" id="L499">        return terms.newTerm(op, relation, t, subterms);</span>
    }


    public static int typeIndex(@NotNull Op o) {
<span class="pc bpc" id="L504" title="1 of 5 branches missed.">        switch (o) {</span>
            case VAR_PATTERN:
<span class="fc" id="L506">                return 0;</span>
            case VAR_DEP:
<span class="fc" id="L508">                return 1;</span>
            case VAR_INDEP:
<span class="fc" id="L510">                return 2;</span>
            case VAR_QUERY:
<span class="fc" id="L512">                return 3;</span>
        }
<span class="nc" id="L514">        throw new RuntimeException(o + &quot; not a variable&quot;);</span>
    }

    /** construct set_ext of key,value pairs from a Map */
    @NotNull
    public static Compound seteMap(@NotNull Map&lt;Term,Term&gt; map) {
<span class="nc" id="L520">        return $.sete(</span>
<span class="nc" id="L521">                (Collection&lt;? extends Term&gt;) map.entrySet().stream().map(</span>
<span class="nc" id="L522">                    e -&gt; $.p(e.getKey(),e.getValue()))</span>
<span class="nc" id="L523">                .collect( toList())</span>
        );
    }
    @NotNull
    public static &lt;X&gt; Compound seteMap(@NotNull Map&lt;Term,? extends X&gt; map, @NotNull Function&lt;X, Term&gt; toTerm) {
<span class="fc" id="L528">        return $.sete(</span>
<span class="fc" id="L529">                (Collection&lt;? extends Term&gt;) map.entrySet().stream().map(</span>
<span class="fc" id="L530">                    e -&gt; $.p(e.getKey(), toTerm.apply(e.getValue())))</span>
<span class="fc" id="L531">                .collect( toList())</span>
        );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>