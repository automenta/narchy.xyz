<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Premise.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars</a> &gt; <span class="el_source">Premise.java</span></div><h1>Premise.java</h1><pre class="source lang-java linenums">package nars;

import nars.concept.Concept;
import nars.nal.Level;
import nars.nal.LocalRules;
import nars.nal.Tense;
import nars.task.MutableTask;
import nars.task.Task;
import nars.task.Tasked;
import nars.term.Term;
import nars.term.Termed;
import nars.term.compound.Compound;
import nars.term.transform.FindSubst;
import nars.term.transform.MapSubst;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Map;
import java.util.function.Consumer;

/**
 * Defines the conditions used in an instance of a derivation
 */
public interface Premise extends Level, Tasked {

    /**
     * The task and belief have the same content
     * &lt;p&gt;
     * called in RuleTables.reason
     *
     * @param question The task
     * @param solution The belief
     * @return null if no match
     */
    static void match(@NotNull Task question, @NotNull Task solution, @NotNull NAR nar, @NotNull Consumer&lt;Task&gt; eachSolution) {


        //if (question.isQuestion() || question.isGoal()) {
            //if (Tense.matchingOrder(question, solution)) {
            //}
        //}

<span class="fc" id="L43">        unify(Op.VAR_QUERY, question.term(), solution.term(), nar.memory, (st) -&gt; {</span>
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">            Task s = !st.equals(solution.term()) ?</span>
<span class="pc" id="L45">                    MutableTask.clone(solution).term((Compound) st) : solution;</span>
<span class="fc" id="L46">            LocalRules.trySolution(question, s, nar, eachSolution);</span>
<span class="fc" id="L47">        });</span>

<span class="fc" id="L49">    }</span>

    /**
     * To unify two terms
     *
     * @param varType The varType of variable that can be substituted
     * @param t       The first and second term as an array, which will have been modified upon returning true
     * @return Whether the unification is possible.  't' will refer to the unified terms
     * &lt;p&gt;
     * only sets the values if it will return true, otherwise if it returns false the callee can expect its original values untouched
     */
    static void unify(Op varType, @NotNull Term a, @NotNull Term b, @NotNull Memory memory, @NotNull Consumer&lt;Term&gt; solution) {

<span class="fc" id="L62">        FindSubst f = new FindSubst(varType, memory.random) {</span>

            @Override public boolean onMatch() {

                //TODO combine these two blocks to use the same sub-method

<span class="fc" id="L68">                Term aa = a;</span>

                //FORWARD
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">                if (aa instanceof Compound) {</span>

<span class="fc" id="L73">                    aa = getXY(a);</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">                    if (aa == null) aa = a;</span>

<span class="fc" id="L76">                    Op aaop = aa.op();</span>
<span class="pc bpc" id="L77" title="5 of 6 branches missed.">                    if (a.op() == Op.VAR_QUERY &amp;&amp; (aaop == Op.VAR_INDEP || aaop == Op.VAR_DEP))</span>
<span class="nc" id="L78">                        return false;</span>

                }

<span class="fc" id="L82">                Term bb = b;</span>

                //REVERSE
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">                if (bb instanceof Compound) {</span>
<span class="fc" id="L86">                    bb = applySubstituteAndRenameVariables(</span>
                            ((Compound) b),
                            (Map&lt;Term, Term&gt;)yx //inverse map
                    );


<span class="fc" id="L92">                    Op bbop = bb.op();</span>
<span class="pc bpc" id="L93" title="5 of 6 branches missed.">                    if (b.op() == Op.VAR_QUERY &amp;&amp; (bbop == Op.VAR_INDEP || bbop == Op.VAR_DEP))</span>
<span class="nc" id="L94">                        return false;</span>
                }

                //t[0] = aa;
                //t[1] = bb;

<span class="fc" id="L100">                solution.accept(bb);</span>

<span class="fc" id="L102">                return true; //determines how many</span>
            }

            @Nullable
            Term applySubstituteAndRenameVariables(Compound t, @Nullable Map&lt;Term,Term&gt; subs) {
<span class="pc bpc" id="L107" title="1 of 4 branches missed.">                return (subs == null) || (subs.isEmpty()) ?</span>
<span class="fc" id="L108">                        t /* no change necessary */ :</span>
<span class="fc" id="L109">                        memory.index.apply(new MapSubst(subs), t);</span>
            }

        };

<span class="fc" id="L114">        f.matchAll(a, b);</span>
<span class="fc" id="L115">    }</span>


//    /**
//     * appliesSubstitute and renameVariables, resulting in a cloned object,
//     * will not change this instance
//     */
//    static Term applySubstituteAndRenameVariables(Compound t, Subst subs) {
//        if ((subs == null) || (subs.isEmpty())) {
//            //no change needed
//            return t;
//        }
//
//        return t.apply(subs);
//    }

    Concept getConcept();

    //BagBudget&lt;Termed&gt; getTermLink();

    //TaskLink getTaskLink();

    @Nullable
    Task getBelief();


    Task getTask();


    NAR nar();


    default long time() {
<span class="fc" id="L148">        return nar().time();</span>
    }


//    default public void emit(final Class c, final Object... o) {
//        nar().emit(c, o);
//    }


    /**
     * curent maximum allowed NAL level the reasoner is configured to support
     */
    default int nal() {
<span class="nc" id="L161">        return nar().nal();</span>
    }

    /**
     * whether at least NAL level N is enabled
     */
    default boolean nal(int n) {
<span class="nc bnc" id="L168" title="All 2 branches missed.">        return nal() &gt;= n;</span>
    }


    @NotNull
    default Memory memory() {
<span class="fc" id="L174">        return nar().memory;</span>
    }


    default Term self() {
<span class="nc" id="L179">        return memory().self();</span>
    }



//    /**
//     * produces a cropped and filtered stack trace (list of methods called)
//     */
//    static List&lt;String&gt; getStack() {
//        StackTraceElement[] s = Thread.currentThread().getStackTrace();
//
//        String prefix = &quot;&quot;;
//
//        boolean tracing = false;
//        //String prevMethodID;
//
//        List&lt;String&gt; path = new ArrayList();
//        for (StackTraceElement e : s) {
//            String className = e.getClassName();
//            String methodName = e.getMethodName();
//
//
//            if (tracing) {
//
//                //Filter conditions
//                if (className.contains(&quot;reactor.&quot;))
//                    continue;
//                if (className.contains(&quot;EventEmitter&quot;))
//                    continue;
//                if ((&quot;NAL&quot;.equals(className) || &quot;Memory&quot;.equals(className)) &amp;&amp; &quot;emit&quot;.equals(methodName))
//                    continue;
//
//                int cli = className.lastIndexOf('.') + 1;
//                if (cli != -1)
//                    className = className.substring(cli, className.length()); //class's simpleName
//
//                String methodID = className + '_' + methodName;
//
//                String sm = prefix + methodID + '_' + e.getLineNumber();
//
//
//                path.add(sm);
//
//                //prevMethodID = methodID;
//
//
//                //Termination conditions
//                if (className.contains(&quot;ConceptFireTask&quot;) &amp;&amp; &quot;accept&quot;.equals(methodName))
//                    break;
//                if (className.contains(&quot;ImmediateProcess&quot;) &amp;&amp; &quot;rule&quot;.equals(methodName))
//                    break;
//                if (className.contains(&quot;ConceptFire&quot;) &amp;&amp; &quot;rule&quot;.equals(methodName))
//                    break;
//            } else if (className.endsWith(&quot;.NAL&quot;) &amp;&amp; &quot;deriveTask&quot;.equals(methodName)) {
//                tracing = true; //begins with next stack element
//            }
//
//        }
//
//
//        return path;
//
//    }

//
//    default int duration() {
//        return memory().duration();
//    }

//    default public CyclesInterval newInterval(final long cycles) {
//        //return Interval.intervalSequence(Math.abs(timeDiff), Global.TEMPORAL_INTERVAL_PRECISION, nal.memory);
//        return CyclesInterval.make(cycles, duration());
//
//    }




//    default public &lt;C extends Compound&gt; TaskSeed newTask(C content, Task task, Task belief, boolean allowOverlap) {
//        content = Sentence.termOrNull(content);
//        if (content == null)
//            return null;
//        TaskSeed s = newDoublePremise(task, belief, allowOverlap);
//        if (s == null) return null;
//        return s.term(content);
//    }

//    default public boolean unify(Op varType, Term a, Term b, Term[] u) {
//        return Variables.unify(varType, a, b, u, getRandom());
//    }

//    default public boolean unify(Op varType, Term a, Term b) {
//        return unify(varType, a, b, new Term[] { a, b } );
//    }





//    /**
//     * TEMPORARY ADAPTER FOR OLD API
//     */
//    @Deprecated
//    public Task derive(final Task task, @Deprecated final boolean revised, final boolean single, Task currentTask, boolean allowOverlap) {
//        return derive(new TaskSeed(memory, task), revised, single, currentTask, allowOverlap);
//    }

//
//    default public Task deriveSingle(final Compound newContent, final char punctuation, final Truth newTruth, final Budget newBudget) {
//        return deriveSingle(newContent, punctuation, newTruth, newBudget, 1f, 1f);
//    }
//
//    default public Task deriveSingle(Compound newContent, final char punctuation, final Truth newTruth, final Budget newBudget, float priMult, float durMult) {
//        final Task parentTask = getTask();
//        //final Task grandParentTask = parentTask.getParentTask();
//        /*if (parentTask != null) {
//            final Compound parentTaskTerm = parentTask.getTerm();
//            if (parentTaskTerm == null) {
//                return null;
//            }
//            if (parentTaskTerm.equals(newContent)) {
//                return null;
//            }
//        }*/
//
//        newContent = Sentence.termOrNull(newContent);
//        if (newContent == null)
//            return null;
//
//
////        final Task ptask;
////        final Task currentBelief = getBelief();
////        if (parentTask.isJudgment() || currentBelief == null) {
////            ptask = parentTask;
////        } else { //Unspecified cheat we need to get rid of.
////            // to answer a question with negation in NAL-5 --- move to activated task?
////            ptask = currentBelief;
////        }
//
//
//        return deriveSingle(newTask(newContent, punctuation)
//                .truth(newTruth)
//                .budget(newBudget, priMult, durMult)
//                .parent(parentTask, null));
//
//    }
//
//    default public Task deriveSingle(Task t) {
//        return derive(t, false, true);
//    }

    /**
     * Shared final operations by all double-premise rules, called from the
     * rules except StructuralRules
     *
     * @param newTaskContent The content of the sentence in task
     * @param newTruth       The truth value of the sentence in task
     * @param newBudget      The budget value in task
     */


//    default public Task deriveDouble(Compound newTaskContent, char punctuation, final Truth newTruth, final Budget newBudget, Task parentTask, Task parentBelief, final boolean temporalAdd, boolean allowOverlap) {
//
//
//        newTaskContent = Sentence.termOrNull(newTaskContent);
//        if (newTaskContent == null)
//            return null;
//
//        if ((parentTask == null) || (parentBelief == null))
//            throw new RuntimeException(&quot;should not derive doublePremiseTask with non-double Stamp&quot;);
//
//        TaskSeed task = newTask(newTaskContent)
//                .punctuation(punctuation)
//                .truth(newTruth)
//                .parent(parentTask, parentBelief)
//                .temporalInductable(!temporalAdd)
//                .budget(newBudget);
//
//        return deriveDouble(task, allowOverlap);
//    }

//    default public Task deriveDouble(TaskSeed task, boolean allowOverlap) {
//        return derive(task, false, false);
//    }


    /**
     * Validate and possibly input a derived task
     *
     * The final destination of Tasks generated by this reasoning
     * process.  It receives all of the information about the state
     * of the new task, and can filter/reject it upon arrival.
     * &lt;p&gt;
     * tasks added with this method will be buffered by this NAL instance;
     * at the end of the processing they can be reviewed and filtered
     * then they need to be added to memory with inputTask(t)
     * &lt;p&gt;
     */
    @NotNull
    default Task removeInvalid(@NotNull Task task) {

<span class="fc" id="L380">        Memory memory = nar().memory;</span>

<span class="fc" id="L382">        Object invalidationReason = validate(task);</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (invalidationReason != null) {</span>
<span class="nc" id="L384">            memory.remove(task, invalidationReason);</span>
<span class="nc" id="L385">            task = null;</span>
        }

<span class="fc" id="L388">        return task;</span>
    }

    /** returns a string indicating a reason why it is invalid, or null if it actually is valid */
    static String validate(@NotNull Task derived) {

<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (derived.term() == null) {</span>
<span class="nc" id="L395">            throw new RuntimeException(&quot;task has null term&quot;);</span>
        }

<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (derived.isInput()) {</span>
<span class="nc" id="L399">            throw new RuntimeException(&quot;Derived task must have a parent task or belief: &quot; + derived);</span>
        }

<span class="pc bpc" id="L402" title="1 of 4 branches missed.">        if (derived.isJudgmentOrGoal() &amp;&amp; derived.getConfidence() &lt; Global.TRUTH_EPSILON) {</span>
<span class="nc" id="L403">            return &quot;Insufficient confidence&quot;;</span>
        }

        /*if (!FilterDuplicateExistingBelief.isUniqueBelief(this, task)) {
            return &quot;Duplicate&quot;;
        }*/

<span class="fc" id="L410">        return null;</span>
    }


//    @Deprecated
//    public static long inferOccurrenceTime(Stamp t, Stamp b) {
//
//
//        if ((t == null) &amp;&amp; (b == null))
//            throw new RuntimeException(&quot;Both sentence parameters null&quot;);
//        if (t == null)
//            return b.getOccurrenceTime();
//        else if (b == null)
//            return t.getOccurrenceTime();
//
//
//        final long tOc = t.getOccurrenceTime();
//        final boolean tEternal = (tOc == Stamp.ETERNAL);
//        final long bOc = b.getOccurrenceTime();
//        final boolean bEternal = (bOc == Stamp.ETERNAL);
//
//        /* see: https://groups.google.com/forum/#!searchin/open-nars/eternal$20belief/open-nars/8KnAbKzjp4E/rBc-6V5pem8J) */
//
//        final long oc;
//        if (tEternal &amp;&amp; bEternal) {
//            /* eternal belief, eternal task =&gt; eternal conclusion */
//            oc = Stamp.ETERNAL;
//        } else if (tEternal /*&amp;&amp; !bEternal*/) {
//            /*
//            The task is eternal, while the belief is tensed.
//            In this case, the conclusion will be eternal, by generalizing the belief
//            on a moment to the general situation.
//            According to the semantics of NARS, each truth-value provides a piece of
//            evidence for the general statement, so this inference can be taken as a
//            special case of abduction from the belief B&lt;f,c&gt; and G==&gt;B&lt;1,1&gt; to G&lt;f,c/(c+k)&gt;
//            where G is the eternal form of B.&quot;
//            */
//            oc = Stamp.ETERNAL;
//        } else if (bEternal /*&amp;&amp; !tEternal*/) {
//            /*
//            The belief is eternal, while the task is tensed.
//            In this case, the conclusion will get the occurrenceTime of the task,
//            because an eternal belief applies to every moment
//
//            ---
//
//            If the task is not tensed but the belief is,
//            then an eternalization rule is used to take the belief as
//            providing evidence for the sentence in the task.
//            */
//            oc = tOc;
//        } else {
//            /*
//            Both premises are tensed.
//            In this case, the truth-value of the belief B&lt;f,c&gt; will be &quot;projected&quot; from
//            its previous OccurrenceTime t1 to the time of the task t2 to become B&lt;f,d*c&gt;,
//            using the discount factor d = 1 - |t1-t2| / (|t0-t1| + |t0-t2|), where t0 is
//            the current time.
//            This formula is cited in https://code.google.com/p/open-nars/wiki/OpenNarsOneDotSix.
//            Here the idea is that if a tensed belief is projected to a different time
//            */
//            /*
//            If both premises are tensed, then the belief is &quot;projected&quot; to the occurrenceTime of the task. Ideally, temporal inference is valid only when
//            the premises are about the same moment, i.e., have the same occurrenceTime or no occurrenceTime (i.e., eternal). However, since
//            occurrenceTime is an approximation and the system is adaptive, a conclusion about one moment (that of the belief) can be projected to
//            another (that of the task), at the cost of a confidence discount. Let t0 be the current time, and t1 and t2 are the occurrenceTime of the
//            premises, then the discount factor is d = 1 - |t1-t2| / (|t0-t1| + |t0-t2|), which is in [0,1]. This factor d is multiplied to the confidence of a
//            promise as a &quot;temporal discount&quot; to project it to the occurrence of the other promise, so as to derive a conclusion about that moment. In
//            this way, if there are conflicting conclusions, the temporally closer one will be preferred by the choice rule.
//             */
//            oc = tOc;
//        }
//
//
//        /*
//        //OLD occurence code:
//        if (currentTaskSentence != null &amp;&amp; !currentTaskSentence.isEternal()) {
//            ocurrence = currentTaskSentence.getOccurenceTime();
//        }
//        if (currentBelief != null &amp;&amp; !currentBelief.isEternal()) {
//            ocurrence = currentBelief.getOccurenceTime();
//        }
//        task.sentence.setOccurrenceTime(ocurrence);
//        */
//
//        return oc;
//    }





    @Nullable
    default Concept concept(Term x) {
<span class="nc" id="L504">        return nar().concept(x);</span>
    }


    /** true if both task and (non-null) belief are temporal events */
    default boolean isEvent() {
        /* TODO This part is used commonly, extract into its own precondition */
<span class="fc" id="L511">        Task b = getBelief();</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (b == null) return false;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        return (!Tense.isEternal(getTask().getOccurrenceTime()) &amp;&amp;</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">                (!Tense.isEternal(b.getOccurrenceTime())));</span>
    }

    /** true if both task and belief (if not null) are eternal */
    default boolean isEternal() {
<span class="fc" id="L519">        Task b = getBelief();</span>
<span class="fc bfc" id="L520" title="All 4 branches covered.">        if ((b != null) &amp;&amp; (!b.isEternal()))</span>
<span class="fc" id="L521">            return false;</span>
<span class="fc" id="L522">        return getTask().isEternal();</span>
    }

//    /** true if either task or belief is non-eternal */
//    default boolean isTemporal() {
//        Task t = getTask();
//        if (!t.isEternal()) return true;
//
//        Task b = getBelief();
//        return (b != null) &amp;&amp; (!b.isEternal());
//
//    }


//    default boolean isTaskEvent() {
//        return !Temporal.isEternal(getTask().getOccurrenceTime());
//    }

    boolean isCyclic();

//    //TODO cache this value
//    default boolean isCyclic() {
//        Task t = getTask();
//        Task b = getBelief();
//        if (b != null) {
//            return Tense.overlapping(t, b);
//        }
//        return false;
//    }

//    /** gets the average summary of one or both task/belief task's */
//    default float getMeanPriority() {
//        float total = 0;
//        int n = 0;
//        Task pt = getTask();
//        if (pt!=null) {
//            if (!pt.isDeleted())
//                total += pt.getPriority();
//            n++;
//        }
//        Task pb = getBelief();
//        if (pb!=null) {
//            if (!pb.isDeleted())
//                total += pb.getPriority();
//            n++;
//        }
//
//        return total/n;
//    }

//    default Task input(Task t) {
//        if (((t = validate(t))!=null)) {
//            nar().input(t);
//            return t;
//        }
//        return null;
//    }

//    default void input(Stream&lt;Task&gt; t) {
//        t.forEach(this::input);
//    }


    @Nullable
    default Task derive(Task derived) {


<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (Global.DEBUG) {</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">            if (getTask().equals(derived))</span>
<span class="fc" id="L591">                return null;</span>
                //throw new RuntimeException(&quot;derivation same as task&quot;);
<span class="pc bpc" id="L593" title="1 of 4 branches missed.">            if (getBelief() != null &amp;&amp; getBelief().equals(derived))</span>
<span class="nc" id="L594">                return null;</span>
                //throw new RuntimeException(&quot;derivation same as belief&quot;);
        }


<span class="fc" id="L599">        derived = removeInvalid(derived);</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (derived != null) {</span>
<span class="fc" id="L601">            memory().eventDerived.emit(derived);</span>
        }
<span class="fc" id="L603">        return derived;</span>
    }

    default Compound getTaskTerm() {
<span class="fc" id="L607">        return getTask().term();</span>
    }

    Termed getBeliefTerm();


    /** beliefTerm iff a Compound, null otherwise */
    @Nullable
    default Compound getBeliefCompound() {
<span class="fc" id="L616">        Term x = getBeliefTerm().term();</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        return x.isCompound() ? (Compound) x : null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>