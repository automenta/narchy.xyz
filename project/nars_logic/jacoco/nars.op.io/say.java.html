<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>say.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.op.io</a> &gt; <span class="el_source">say.java</span></div><h1>say.java</h1><pre class="source lang-java linenums">/*
 * Sample.java
 *
 * Copyright (C) 2008  Pei Wang
 *
 * This file is part of Open-NARS.
 *
 * Open-NARS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Open-NARS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Open-NARS.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package nars.op.io;

import nars.nal.nal8.operator.NullOperator;

/**
 */
<span class="fc" id="L27">public class say extends NullOperator {</span>

	// private Memory memory;
	// private Operation currentOperation;
	// private NARReaction reaction;
	//
	// // boolean rejectEmpty = true;
	// // boolean rejectHasVariables = true;
	//
	//
	// final int MAX_WORD_LENGTH = 16;
	// final Term WORD = Atom.the(&quot;WORD&quot;);
	// final Term QUIET = Atom.the(&quot;QUIET&quot;);
	// final Term INCOHERENT = Atom.the(&quot;INCOHERENT&quot;);
	// final Term SAID = Atom.the(&quot;SAID&quot;);
	// //NOISY
	//
	// long lastEmit = 0;
	// long emitPeriod = 50; //cycles between which buffer is auto-flush
	//
	// @Override
	// public boolean setEnabled(NAR n, boolean enabled) {
	// if (!enabled) {
	// if (reaction!=null) {
	// reaction.off();
	// reaction = null;
	// }
	// }
	//
	// return super.setEnabled(n, enabled);
	// }
	//
	// @Override
	// protected synchronized List&lt;Task&gt; execute(Operation operation, Memory
	// memory) {
	//
	// this.memory = nar.memory;
	// this.currentOperation = operation;
	//
	// if (this.reaction == null) {
	// reaction = new NARReaction(say.this.memory, Events.CycleEnd.class) {
	//
	// @Override
	// public void event(Class event, Object[] args) {
	// long now = nar.time();
	// if (buffer.getUniqueCount() &gt; 0 &amp;&amp; now - lastEmit &gt; emitPeriod) {
	// nar.input(&quot;say()!&quot;);
	// lastEmit = now;
	// }
	// }
	// };
	// }
	// // if (rejectEmpty &amp;&amp; args.length == 1) {
	// // //SELF argument by itself is not worth speaking
	// // throw NegativeFeedback.ignore(&quot;Said nothing&quot;);
	// // }
	// //
	// // if (rejectEmpty &amp;&amp; Terms.containsVariables(args)) {
	// // throw NegativeFeedback.ignore(&quot;Said variables&quot;);
	// // }
	//
	// // List&lt;Term&gt; spoken = Lists.newArrayList(args).subList(0,
	// args.length-1);
	// // List&lt;Term&gt; spoke2=new ArrayList&lt;Term&gt;();
	// // for(Term t: spoken) {
	// // if(t instanceof Product) {
	// // CompoundTerm cn=(CompoundTerm) t;
	// // for(Term k : cn) {
	// // String s=k.toString();
	// // if(s.startsWith(&quot;word-&quot;)) {
	// // spoke2.add(new Term(s.replace(&quot;word-&quot;, &quot;&quot;)));
	// // } else {
	// // spoke2.add(k);
	// // }
	// // }
	// //
	// // } else {
	// // return null;
	// // }
	// // }
	//
	// Term[] args = operation.args();
	// int argsLength = args.length - 1; //ignore ending SELF
	//
	// if (argsLength == 1) {
	// Term wIn = args[0];
	// Term w = asWord(wIn);
	// if (w!=null) {
	// buffer(w, operation.getTask().getPriority());
	// return isWord(w, true);
	// }
	// else {
	// return isWord(wIn, false);
	// }
	// }
	// else if (argsLength == 0) {
	// return flush();
	// //measure coherence, silence, etc
	// }
	// else {
	// List&lt;Term&gt; aa = Arrays.asList(args).subList(0, args.length - 1);
	// return isWord(SetExt.make(aa), false);
	// }
	//
	// // List&lt;Term&gt; spoke2 = Flat.collect(args, new ArrayList());
	// // if (spoke2.size() &gt; 0)
	// // memory.emit(Say.class, spoke2);
	// //
	// // return null;
	// }
	//
	//
	//
	// private List&lt;Task&gt; isWord(Term t, boolean b) {
	// return Arrays.asList(memory.newTask(Inheritance.make(t,
	// WORD)).judgment().
	// truth(b, 0.9f).present().get());
	// }
	//
	// private Compound asWord(Term t) {
	// // if (t.operator() == NALOperator.SET_EXT &amp;&amp; ((SetExt)t).size() == 1) {
	// // t = ((SetExt)t).term[0];
	// // }
	//
	// if (t instanceof Atom) {
	// String s = t.toString();
	// if (s.startsWith(&quot;\&quot;&quot;) &amp;&amp; s.endsWith(&quot;\&quot;&quot;) &amp;&amp; (s.length()-2) &lt;
	// MAX_WORD_LENGTH) {
	// return SetExt.make(t);
	// }
	// }
	//
	// return null;
	// }
	//
	// private List&lt;Task&gt; flush() {
	// lastEmit = memory.time();
	//
	//
	//
	// int num = buffer.getUniqueCount();
	// double thresh = 1.0 / num;
	// Iterator&lt;Map.Entry&lt;Comparable&lt;?&gt;, Long&gt;&gt; eie = buffer.entrySetIterator();
	// if (eie.hasNext()) {
	// Map.Entry&lt;Comparable&lt;?&gt;, Long&gt; ei = eie.next();
	// Term t = (Term) ei.getKey();
	// double p = buffer.getPct(t);
	// if (num &gt;1 &amp;&amp; p &lt;= thresh) {
	// //no clear winner
	//
	// List&lt;Object&gt; ic = new ArrayList(num);
	// Iterators.addAll(ic, buffer.valuesIterator());
	//
	// buffer.clear();
	// return isIncoherent(ic);
	// }
	// else {
	// //the clear winner
	// buffer.clear();
	// return isSpoken(t);
	// }
	//
	// }
	//
	// return isQuiet();
	// }
	//
	// private List&lt;Task&gt; isQuiet() {
	// return Arrays.asList( memory.newTask(
	// Inheritance.make(memory.self(), QUIET)
	// ).judgment().present().truth(1.0f, 0.9f).get());
	// }
	//
	// private List&lt;Task&gt; isSpoken(Term t) {
	// memory.emit(say.class, t);
	// return Arrays.asList( memory.newTask(
	// Inheritance.make(
	// Product.make(t, memory.self()),
	// SAID)
	// ).judgment().present().truth(1.0f, 0.9f).get());
	// }
	//
	// private List&lt;Task&gt; isIncoherent(List&lt;Object&gt; ic) {
	// List&lt;Term&gt; c = Lists.transform(ic, new Function&lt;Object, Term&gt;() {
	// @Override public Term apply(Object input) {
	// return Inheritance.make( (Term)input, WORD ) ;
	// }
	// });
	// return Arrays.asList( memory.newTask(
	// Inheritance.make(
	// Product.make(SetExt.make(c), memory.self()),
	// INCOHERENT)
	// ).judgment().present().truth(1.0f, 0.9f).get());
	//
	// }
	//
	// final Frequency buffer = new Frequency();
	//
	//
	// void buffer(Term word, float priority) {
	// buffer.incrementValue(word, (long)(priority*1000));
	// }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>