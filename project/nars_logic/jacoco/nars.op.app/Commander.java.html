<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Commander.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.op.app</a> &gt; <span class="el_source">Commander.java</span></div><h1>Commander.java</h1><pre class="source lang-java linenums">package nars.op.app;

import com.google.common.collect.Iterators;
import nars.NAR;
import nars.bag.BLink;
import nars.budget.TaskAccumulator;
import nars.concept.Concept;
import nars.nal.Tense;
import nars.task.Task;
import org.jetbrains.annotations.NotNull;

import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Captures input goals and questions into a buffer
 * (ie. input by user) and re-processes them in a
 * controllable pattern, frequency,
 * and priority -- in addition to ordinary system activity.
 *
 * This guides inference according to the explicit
 * inputs that were input, focusing it towards those
 * outcomes.
 *
 * Analogous to a continuous echo/delay effect,
 * or a sustain effecct.
 */
public class Commander implements Consumer&lt;NAR&gt;, Supplier&lt;Concept&gt; {

    public final TaskAccumulator commands;
    @NotNull
    public final Iterator&lt;BLink&lt;Task&gt;&gt; commandIterator;
<span class="nc" id="L35">    public final LinkedHashSet&lt;Concept&gt; concepts = new LinkedHashSet();</span>
<span class="nc" id="L36">    final Iterator&lt;Concept&gt; conceptsIterator = Iterators.cycle(concepts);</span>


//    private final On cycleEnd;
//    private final NAR nar;

    /** how far away from the occurence time of a temporal belief before it is deleted */
    private final int maxTemporalBeliefAge;
<span class="nc" id="L44">    private final int maxTemporalBeliefDurations = 16 /* should be tuned */;</span>
    @NotNull
    private final NAR nar;

<span class="nc" id="L48">    int inputsPerFrame = 2;</span>
<span class="nc" id="L49">    int cycleDivisor = 3;</span>

//    float priorityPerCycle = 1,
//            priorityRemaining = 0; //change left over from last cycle

    public Commander(@NotNull NAR nar, int capacity) {
<span class="nc" id="L55">        this(nar, new TaskAccumulator(capacity));</span>
<span class="nc" id="L56">    }</span>

<span class="nc" id="L58">    public Commander(@NotNull NAR nar, TaskAccumulator buffer) {</span>

<span class="nc" id="L60">        this.nar = nar;</span>

        //TODO reset event
        //this.cycleEnd = active ?
<span class="nc" id="L64">                nar.memory.eventFrameStart.on(this);</span>
                //: null;

<span class="nc" id="L67">        commands = buffer;</span>
<span class="nc" id="L68">        commandIterator = Iterators.cycle(commands.getArrayBag());</span>


<span class="nc" id="L71">        maxTemporalBeliefAge = nar.memory.duration() * maxTemporalBeliefDurations;</span>


<span class="nc" id="L74">        nar.memory.eventInput.on((tp) -&gt; {</span>
<span class="nc" id="L75">            Task t = tp.getTask();</span>
<span class="nc bnc" id="L76" title="All 4 branches missed.">            if (t.isInput() &amp;&amp; !commands.getArrayBag().contains(t))</span>
<span class="nc" id="L77">                input(t);</span>
<span class="nc" id="L78">        });</span>
<span class="nc" id="L79">    }</span>


//    @Override
//    public void setActive(boolean b) {
//        super.setActive(b);
//        if (!b) {
//            commands.clear();
//        }
//    }


    protected void input(@NotNull Task t) {
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (/*(t.isGoal() || t.isQuestOrQuestion()) &amp;&amp; */ t.isInput()) {</span>
<span class="nc" id="L93">            commands.getArrayBag().put(t);</span>
        }
<span class="nc" id="L95">    }</span>


    @Override
    public void accept(@NotNull NAR nar) {

        //TODO iterate tasks until allotted priority has been reached,
        //  TaskProcess each

<span class="nc" id="L104">        int cs = commands.getArrayBag().size();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (cs == 0) return;</span>


<span class="nc" id="L108">        long now = nar.time();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (now%cycleDivisor!= 0) return;</span>

<span class="nc" id="L111">        Iterator&lt;BLink&lt;Task&gt;&gt; commandIterator = this.commandIterator;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        for (int i = 0; i &lt; inputsPerFrame; i++) {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (commandIterator.hasNext()) {</span>
<span class="nc" id="L114">                Task next = commandIterator.next().get();</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">                if (valid(now, next)) {</span>
<span class="nc" id="L116">                    Concept c = nar.process(next);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                    if (c!=null) {</span>
<span class="nc" id="L118">                        concepts.add(c);</span>
                        //TODO add recursive components?
                    }
<span class="nc" id="L121">                }</span>
                else
<span class="nc" id="L123">                    commandIterator.remove();</span>
            }
        }

<span class="nc" id="L127">    }</span>

    public final boolean valid(long now, @NotNull Task t) {

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (t.getBudget().getDeleted())</span>
<span class="nc" id="L132">            return false;</span>

<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (!Tense.isEternal(t.getOccurrenceTime())) {</span>
<span class="nc" id="L135">            long age = Math.abs( now - t.getOccurrenceTime() );</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (age &gt; maxTemporalBeliefAge)</span>
<span class="nc" id="L137">                return false;</span>
        }

<span class="nc" id="L140">        return true;</span>
    }

    @Override
    public Concept get() {
<span class="nc" id="L145">        return conceptsIterator.next();</span>
    }

    public boolean isEmpty() {
<span class="nc" id="L149">        return this.commands.getArrayBag().isEmpty();</span>
    }

    public int size() {
<span class="nc" id="L153">        return this.commands.getArrayBag().size();</span>
    }

    //TODO getBufferPrioritySum
    //TODO setPriorityPerCycle
    //TODO max tasks limit
    //TODO rebudgeting Function&lt;Budget,Budget&gt; for manipulating values
    //add with TTL?
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>