<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultConcept.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.concept</a> &gt; <span class="el_source">DefaultConcept.java</span></div><h1>DefaultConcept.java</h1><pre class="source lang-java linenums">package nars.concept;

import nars.*;
import nars.bag.Bag;
import nars.budget.BudgetMerge;
import nars.concept.util.ArrayListTaskTable;
import nars.concept.util.BeliefTable;
import nars.concept.util.DefaultBeliefTable;
import nars.concept.util.QuestionTaskTable;
import nars.nal.LocalRules;
import nars.task.Task;
import nars.term.Term;
import nars.term.Termed;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.function.BiPredicate;


public class DefaultConcept extends AtomConcept {

<span class="fc" id="L22">    public static final BiPredicate&lt;Task, Task&gt; questionEquivalence = new BiPredicate&lt;Task, Task&gt;() {</span>

        @Override
        public boolean test(@NotNull Task a, Task b) {
<span class="fc" id="L26">            return (a.equals(b));</span>
        }

//        //N/
//        @Override public int compare(Task task, Task t1) {  return 0;        }
//        @Override public int hashCodeOf(Task task) { return task.hashCode(); }
    };
    /**
     * how incoming budget is merged into its existing duplicate quest/question
     */
<span class="fc" id="L36">    static final BudgetMerge duplicateQuestionMerge = BudgetMerge.plusDQDominated;</span>
    @Nullable
    private final Termed[] termLinkTemplates;

<span class="fc" id="L40">    @Nullable</span>
    protected QuestionTaskTable questions = null;
<span class="fc" id="L42">    @Nullable</span>
    protected QuestionTaskTable quests = null;
<span class="fc" id="L44">    @Nullable</span>
    protected BeliefTable beliefs = null;
<span class="fc" id="L46">    @Nullable</span>
    protected BeliefTable goals = null;


//    public DefaultConcept(Term term, Memory p) {
//        this(term, new NullBag(), new NullBag(), p);
//    }

    /**
     * Constructor, called in Memory.getConcept only
     *
     * @param term      A term corresponding to the concept
     * @param taskLinks
     * @param termLinks
     */
    public DefaultConcept(Term term, Bag&lt;Task&gt; taskLinks, Bag&lt;Termed&gt; termLinks, @NotNull Memory m) {
<span class="fc" id="L62">        super(term, termLinks, taskLinks);</span>

        //lazily instantiated
        //beliefs = null; //new DefaultBeliefTable(m.conceptBeliefsMax.intValue(), m.duration());
        //goals = null; //new DefaultBeliefTable(m.conceptGoalsMax.intValue(), m.duration());

<span class="fc" id="L68">        int maxQuestions = m.conceptQuestionsMax.intValue();</span>
<span class="fc" id="L69">        questions = new ArrayListTaskTable(maxQuestions);</span>
<span class="fc" id="L70">        quests = new ArrayListTaskTable(maxQuestions);</span>

<span class="fc" id="L72">        this.termLinkTemplates = TermLinkBuilder.build(term, m);</span>
<span class="fc" id="L73">    }</span>

    /**
     * Pending Quests to be answered by new desire values
     */
    @Nullable
    @Override
    public final QuestionTaskTable getQuests() {
<span class="fc" id="L81">        return quests;</span>
    }

    @Nullable
    @Override
    public final QuestionTaskTable getQuestions() {
<span class="fc" id="L87">        return questions;</span>
    }


    /**
     * Judgments directly made about the term Use ArrayList because of access
     * and insertion in the middle
     */
    @Nullable
    @Override
    public final BeliefTable getBeliefs() {
<span class="fc bfc" id="L98" title="All 2 branches covered.">        return beliefs == null ? BeliefTable.EMPTY : beliefs;</span>
    }

    /**
     * Desire values on the term, similar to the above one
     */
    @Nullable
    @Override
    public final BeliefTable getGoals() {
<span class="fc bfc" id="L107" title="All 2 branches covered.">        return goals == null ? BeliefTable.EMPTY : goals;</span>
    }


//    /** updates the concept-has-questions index if the concept transitions from having no questions to having, or from having to not having */
//    public void onTableUpdated(char punctuation, int originalSize) {
//
//        switch (punctuation) {
//            /*case Symbols.GOAL:
//                break;*/
//            case Symbols.QUEST:
//            case Symbols.QUESTION:
//                if (getQuestions().isEmpty() &amp;&amp; getQuests().isEmpty()) {
//                    //if (originalSize &gt; 0) //became empty
//                        //getMemory().updateConceptQuestions(this);
//                } else {
//                    //if (originalSize == 0) //became non-empty
//                        //getMemory().updateConceptQuestions(this);
//
//                }
//                break;
//        }
//    }

    /* ---------- direct processing of tasks ---------- */


    //
//    /**
//     * for batch processing a collection of tasks; more efficient than processing them individually
//     */
//    //TODO untested
//    public void link(Collection&lt;Task&gt; tasks) {
//
//        final int s = tasks.size();
//        if (s == 0) return;
//
//        if (s == 1) {
//            link(tasks.iterator().next());
//            return;
//        }
//
//
//        //aggregate a merged budget, allowing a maximum of (1,1,1)
//        Budget aggregateBudget = null;
//        for (Task t : tasks) {
//            if (linkTask(t)) {
//                if (aggregateBudget == null) aggregateBudget = new Budget(t, false);
//                else {
//                    //aggregateBudget.merge(t);
//                    aggregateBudget.accumulate(t);
//                }
//            }
//        }
//
//        //linkToTerms the aggregate budget, rather than each task's budget separately
//        if (aggregateBudget != null) {
//            linkTerms(aggregateBudget, true);
//        }
//    }
//


    /**
     * attempt to insert a task.
     *
     * @param c   the concept in which this occurrs
     * @param nal
     * @return: the input value that was inserted, if it was added to the table
     * a previous stored task if this was a duplicate (table unchanged)
     * a new belief created from older ones which serves as a revision of what was input, if it was added to the table
     * null if it was discarded
     */


    @Nullable
    Task add(@NotNull QuestionTaskTable table, Task input, BiPredicate&lt;Task, Task&gt; eq, BudgetMerge duplicateMerge, Memory memory) {
<span class="fc" id="L184">        return table.add(input, eq, duplicateMerge, memory);</span>
    }


    /**
     * To accept a new judgment as belief, and check for revisions and solutions
     *
     * @param belief The task to be processed
     * @param nar
     * @return Whether to continue the processing of the task
     */
    @Nullable
    @Override
    public Task processBelief(Task belief, @NotNull NAR nar) {

<span class="fc" id="L199">        long now = nar.time();</span>
<span class="fc" id="L200">        float successBefore = getSuccess(now);</span>

<span class="fc" id="L202">        Memory memory = nar.memory;</span>

<span class="fc" id="L204">        BeliefTable beliefs = this.beliefs;</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (beliefs == null)</span>
<span class="fc" id="L206">            beliefs = this.beliefs = new DefaultBeliefTable(memory.conceptBeliefsMax.intValue(), memory);</span>

<span class="fc" id="L208">        return beliefs.add(belief, memory, (best) -&gt; {</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (hasQuestions()) {</span>
                //TODO move this to a subclass of TaskTable which is customized for questions. then an arraylist impl of TaskTable can iterate by integer index and not this iterator/lambda
<span class="fc" id="L212">                getQuestions().forEach(question -&gt;</span>
<span class="fc" id="L213">                    LocalRules.trySolution(question, best, nar, nar::input)</span>
                );
            }

            /** update happiness meter on solution  TODO revise */
<span class="fc" id="L218">            float successAfter = getSuccess(now);</span>
<span class="fc" id="L219">            float delta = successAfter - successBefore;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (delta != 0) //more satisfaction of a goal due to belief, more happiness</span>
<span class="fc" id="L221">                memory.emotion.happy(delta);</span>

<span class="fc" id="L223">            memory.eventConceptChanged.emit(DefaultConcept.this);</span>

<span class="fc" id="L225">        });</span>

//        if (belief.isInput() &amp;&amp; !belief.isEternal()) {
//            this.put(Anticipate.class, true);
//        }
    }


    /**
     * To accept a new goal, and check for revisions and realization, then
     * decide whether to actively pursue it
     *
     * @param goal The task to be processed
     * @param task
     * @return Whether to continue the processing of the task
     */
    @Nullable
    @Override
    public Task processGoal(Task inputGoal, @NotNull NAR nar) {

<span class="fc" id="L245">        Memory memory = nar.memory;</span>

<span class="fc" id="L247">        long now = memory.time();</span>

<span class="fc" id="L249">        float successBefore = getSuccess(now);</span>


<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (goals == null) goals = new DefaultBeliefTable(</span>
<span class="fc" id="L253">                nar.memory.conceptGoalsMax.intValue(), memory);</span>

<span class="fc" id="L255">        return getGoals().add(inputGoal, memory, (goal) -&gt; {</span>

<span class="fc" id="L257">            float successAfter = getSuccess(now);</span>
<span class="fc" id="L258">            float delta = successBefore - successAfter;</span>

            // less desire of a goal, more happiness
<span class="fc" id="L261">            memory.emotion.happy(goal.getExpectation() * -delta);</span>

<span class="fc bfc" id="L263" title="All 4 branches covered.">            if (Op.isOperation(goal.term()) &amp;&amp; (goal.getState() != Task.TaskState.Executed)) {</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                if (delta &gt;= Global.EXECUTION_SATISFACTION_TRESHOLD) {</span>
                    //Truth projected = goal.projection(now, now);
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                    if (goal.getExpectation() &gt; Global.EXECUTION_DESIRE_EXPECTATION_THRESHOLD) {</span>


//                        LongHashSet ev = this.lastevidence;
//
//                        //if all evidence of the new one is also part of the old one
//                        //then there is no need to execute
//                        //which means only execute if there is new evidence which suggests doing so1
//                        if (ev.addAll(input.getEvidence())) {
<span class="fc" id="L275">                        nar.execute(goal);</span>

//                            //TODO more efficient size limiting
//                            //lastevidence.toSortedList()
//                            while(ev.size() &gt; max_last_execution_evidence_len) {
//                                ev.remove( ev.min() );
//                            }
//                        }
                    }
                }
            }
<span class="fc" id="L286">        });</span>


        //long then = goal.getOccurrenceTime();
        //int dur = nal.duration();

//        //this task is not up to date (now is ahead of then) we have to project it first
//        if(TemporalRules.after(then, now, dur)) {
//
//            nal.singlePremiseTask(task.projection(nal.memory, now, then) );
//
//            return true;
//
//        }

//         if (goal.getBudget().summaryGreaterOrEqual(memory.questionFromGoalThreshold)) {
//
//                // check if the Goal is already satisfied
//                //Task beliefSatisfied = getBeliefs().topRanked();
//
//            /*float AntiSatisfaction = 0.5f; //we dont know anything about that goal yet, so we pursue it to remember it because its maximally unsatisfied
//            if (beliefSatisfied != null) {
//
//                Truth projectedTruth = beliefSatisfied.projection(goal.getOccurrenceTime(), dur);
//                //Sentence projectedBelief = belief.projectionSentence(goal.getOccurrenceTime(), dur);
//
//                boolean solved = null!=trySolution(beliefSatisfied, projectedTruth, goal, nal); // check if the Goal is already satisfied (manipulate budget)
//                if (solved) {
//                    AntiSatisfaction = goal.getTruth().getExpDifAbs(beliefSatisfied.getTruth());
//                }
//            }
//
//            float Satisfaction = 1.0f - AntiSatisfaction;
//            Truth T = BasicTruth.clone(goal.getTruth());
//
//            T.setFrequency((float) (T.getFrequency() - Satisfaction)); //decrease frequency according to satisfaction value
//
//            if (AntiSatisfaction &gt;= Global.SATISFACTION_TRESHOLD &amp;&amp; goal.sentence.truth.getExpectation() &gt; nal.memory.param.executionThreshold.get()) {
//*/
//
//                questionFromGoal(goal, nal);
//
//                //TODO
//                //InternalExperience.experienceFromTask(nal, task, false);
//
//
//                //}
//            }


    }


//    public static void questionFromGoal(final Task task, final Premise p) {
//        if (Global.QUESTION_GENERATION_ON_DECISION_MAKING || Global.HOW_QUESTION_GENERATION_ON_DECISION_MAKING) {
//            //ok, how can we achieve it? add a question of whether it is fullfilled
//
//            List&lt;Compound&gt; qu = Global.newArrayList(3);
//
//            final Compound term = task.getTerm();
//
//            if (Global.HOW_QUESTION_GENERATION_ON_DECISION_MAKING) {
//                if (!(term instanceof Equivalence) &amp;&amp; !(term instanceof Implication)) {
//
//                    Implication i1 = Implication.make(how, term, TemporalRules.ORDER_CONCURRENT);
//                    if (i1 != null)
//                        qu.add(i1);
//
//                    Implication i2 = Implication.make(how, term, TemporalRules.ORDER_FORWARD);
//                    if (i2 != null)
//                        qu.add(i2);
//
//                }
//            }
//
//            if (Global.QUESTION_GENERATION_ON_DECISION_MAKING) {
//                qu.add(term);
//            }
//
//            if (qu.isEmpty()) return;
//
//            p.input(
//                qu.stream().map(q -&gt; p.newTask(q)
//                    .question()
//                    .parent(task)
//                    .occurr(task.getOccurrenceTime()) //set tense of question to goal tense)
//                    .budget(task.getPriority() * Global.CURIOSITY_DESIRE_PRIORITY_MUL, task.getDurability() * Global.CURIOSITY_DESIRE_DURABILITY_MUL, 1)
//            ));
//
//        }
//    }


    /**
     * To answer a quest or q by existing beliefs
     *
     * @param q    The task to be processed
     * @param task
     * @param nar
     * @return true if the quest/question table changed
     */
    @Override
    public boolean processQuestion(@NotNull Task q, @NotNull NAR nar) {

        final QuestionTaskTable table;
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (q.isQuestion()) {</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">            if (questions == null) questions = new ArrayListTaskTable(nar.memory.conceptQuestionsMax.intValue());</span>
<span class="fc" id="L393">            table = getQuestions();</span>

        } else { // else if (q.isQuest())
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">            if (quests == null) quests = new ArrayListTaskTable(nar.memory.conceptQuestionsMax.intValue());</span>
<span class="fc" id="L397">            table = getQuests();</span>
        }

//        //if (Global.DEBUG) {
//            if (q.getTruth() != null) {
//                System.err.println(q + &quot; has non-null truth&quot;);
//                System.err.println(q.getExplanation());
//                throw new RuntimeException(q + &quot; has non-null truth&quot;);
//            }
        //}

        /** execute the question, for any attached operators that will handle it */
        //getMemory().execute(q);

        //boolean tableAffected = false;


        //boolean newQuestion = table.isEmpty();

<span class="fc" id="L416">        Task match = add(table, q, questionEquivalence, duplicateQuestionMerge, nar.memory);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (match == q) {</span>
            //final int presize = getQuestions().size() + getQuests().size();
            //onTableUpdated(q.getPunctuation(), presize);
            //tableAffected = true;
        } else {
<span class="fc" id="L422">            q = match; //try solution with the original question</span>
        }


        //TODO if the table was not affected, does the following still need to happen:

<span class="fc" id="L428">        long now = q.getOccurrenceTime();</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        Task sol = q.isQuest() ?</span>
<span class="fc" id="L430">                getGoals().top(now) :</span>
<span class="fc" id="L431">                getBeliefs().top(now);</span>

<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (sol != null) {</span>

<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            if (sol.getDeleted()) {</span>
                //throw new RuntimeException(&quot;can not try solution on deleted task: &quot; + sol);
<span class="nc" id="L437">                return true;</span>
            }

<span class="fc" id="L440">            LocalRules.trySolution(q, sol, nar, nar::input); /*(s) -&gt; {</span>
                //...
            });*/
        }

<span class="fc" id="L445">        return true;</span>
    }




    /* ---------- insert Links for indirect processing ---------- */


    //    /**
//     * Recalculate the quality of the concept [to be refined to show
//     * extension/intension balance]
//     *
//     * @return The quality value
//     */
//    public float getAggregateQuality() {
//        float linkPriority = termLinks.getPriorityMean();
//        float termComplexityFactor = 1.0f / term.getComplexity();
//        float result = or(linkPriority, termComplexityFactor);
//        if (result &lt; 0) {
//            throw new RuntimeException(&quot;Concept.getQuality &lt; 0:  result=&quot; + result + &quot;, linkPriority=&quot; + linkPriority + &quot; ,termComplexityFactor=&quot; + termComplexityFactor + &quot;, termLinks.size=&quot; + termLinks.size());
//        }
//        return result;
//    }


    //
//
//    /**
//     * Collect direct isBelief, questions, and goals for display
//     *
//     * @return String representation of direct content
//     */
//    public String displayContent() {
//        final StringBuilder buffer = new StringBuilder(18);
//        buffer.append(&quot;\n  Beliefs:\n&quot;);
//        if (!beliefsEternal.isEmpty()) {
//            for (Sentence s : beliefsEternal) {
//                buffer.append(s).append('\n');
//            }
//        }
//        if (!beliefsTemporal.isEmpty()) {
//            for (Sentence s : beliefsTemporal) {
//                buffer.append(s).append('\n');
//            }
//        }
//        if (!questions.isEmpty()) {
//            buffer.append(&quot;\n  Question:\n&quot;);
//            for (Task t : questions) {
//                buffer.append(t).append('\n');
//            }
//        }
//        return buffer.toString();
//    }


    //
//    public Collection&lt;Sentence&gt; getSentences(char punc) {
//        switch(punc) {
//            case Symbols.JUDGMENT: return beliefs;
//            case Symbols.GOAL: return goals;
//            case Symbols.QUESTION: return Task.getSentences(questions);
//            case Symbols.QUEST: return Task.getSentences(quests);
//        }
//        throw new RuntimeException(&quot;Invalid punctuation: &quot; + punc);
//    }
//    public CharSequence getBeliefsSummary() {
//        if (beliefs.isEmpty())
//            return &quot;0 beliefs&quot;;
//        StringBuilder sb = new StringBuilder();
//        for (Sentence s : beliefs)
//            sb.append(s.toString()).append('\n');
//        return sb;
//    }
//    public CharSequence getGoalSummary() {
//        if (goals.isEmpty())
//            return &quot;0 goals&quot;;
//        StringBuilder sb = new StringBuilder();
//        for (Sentence s : goals)
//            sb.append(s.toString()).append('\n');
//        return sb;
//    }


//    @Override public synchronized boolean delete() {
//
//        if (!super.delete())
//            return false;
//
//        //dont delete the tasks themselves because they may be referenced from othe concepts.
//        beliefs.clear();
//        goals.clear();
//        questions.clear();
//        quests.clear();
//
//
//        getTermLinks().delete();
//        getTaskLinks().delete();
//
//        if (getTermLinkBuilder() != null)
//            getTermLinkBuilder().delete();
//
//        return true;
//    }


//    /**
//     * Recursively build TermLinks between a compound and its components
//     * &lt;p&gt;
//     * called only from Memory.continuedProcess
//     * activates termlinked concepts with fractions of the taskbudget
//
//     *
//     * @param b            The BudgetValue of the task
//     * @param updateTLinks true: causes update of actual termlink bag, false: just queues the activation for future application.  should be true if this concept calls it for itself, not for another concept
//     * @return whether any activity happened as a result of this invocation
//     */
//    public boolean linkTemplates(Budget b, float scale, boolean updateTLinks, NAR nar) {
//
//        if ((b == null) || (b.isDeleted())) return false;
//
//        Term[] tl = getTermLinkTemplates();
//        if (tl == null || tl.length == 0)
//            return false;
//
//        //subPriority = b.getPriority() / (float) Math.sqrt(recipients);
//        float factor = scale / (tl.length);
//
//        final Memory memory = nar.memory;
//
//        if (factor &lt; memory.termLinkThreshold.floatValue())
//            return false;
//
//        boolean activity = false;
//
//        for (Term t : tl) {
//
//            /*if ((t.getTarget().equals(getTerm()))) {
//                //self
//                continue;
//            }*/
//
//
//            //only apply this loop to non-transform termlink templates
//            //PENDING_TERMLINK_BUDGET_MERGE.value(t, subBudget);
//
//            if (updateTLinks) {
//                //if (t.summaryGreaterOrEqual(termLinkThresh)) {
//
//                    if (link(t, b, factor, nar))
//                        activity = true;
//                //}
//            }
//
//        }
//
//        return activity;
//
//    }


//    /**
//     * Recursively build TermLinks between a compound and its components
//     * Process is started by one Task, and recurses only to templates
//     * creating bidirectional links between compound to components
//     */
//    @Override public void linkTemplates(Budget budget, float scale, NAR nar) {
//
//        Termed[] tl = getTermLinkTemplates();
//        int numTemplates;
//        if (tl == null || (numTemplates = tl.length) == 0)
//            return;
//
//        final Memory memory = nar.memory;
//
//        float subScale = scale / numTemplates;
//        if (subScale &lt; memory.termLinkThreshold.floatValue())
//            return;
//
//        for (int i = 0; i &lt; tl.length; i++) {
//            Termed t = tl[i];
//
//            final Concept target;
//            if (t instanceof Concept) {
//                target = (Concept) t;
//            } else {
//                target = nar.conceptualize(t);
//                if (target == null) continue;
//                tl[i] = target;
//            }
//
//            linkTemplate(target, budget, subScale, nar);
//            target.linkTemplates(budget, subScale, nar);
//        }
//
//    }


//    @Override public boolean link(Term t, Budget b, float scale, NAR nar) {
//
//        if (t.equals(term()))
//            throw new RuntimeException(&quot;looped activation&quot;);
//
//        Concept otherConcept = activateConcept(t, b, scale, nar);
//
//        //termLinkBuilder.set(t, false, nar.memory);
//
//        //activate this termlink to peer
//        // this concept termLink to that concept
//        getTermLinks().put(t, b, scale);
//
//        //activate peer termlink to this
//        //otherConcept.activateTermLink(termLinkBuilder.setIncoming(true)); // that concept termLink to this concept
//        otherConcept.getTermLinks().put(term(), b, scale);
//
//        //if (otherConcept.getTermLinkTemplates()) {
//        //UnitBudget termlinkBudget = termLinkBuilder.getBudget();
//        linkTemplates(b, scale, immediateTermLinkPropagation, nar);
//
//        return true;
//    }

    @Override
    public Termed[] getTermLinkTemplates() {
<span class="fc" id="L669">        return termLinkTemplates;</span>
    }

    /**
     * Directly process a new task. Called exactly once on each task. Using
     * local information and finishing in a constant time. Provide feedback in
     * the taskBudget value of the task.
     * &lt;p&gt;
     * called in Memory.immediateProcess only
     *
     * @return whether it was processed
     */
    public final Task process(@NotNull final Task task, @NotNull NAR nar) {

<span class="fc" id="L683">        task.onConcept(this);</span>

<span class="pc bpc" id="L685" title="1 of 5 branches missed.">        switch (task.getPunctuation()) {</span>
            case Symbols.JUDGMENT:
<span class="fc" id="L687">                return processBelief(task, nar);</span>

            case Symbols.GOAL:
<span class="fc" id="L690">                return processGoal(task, nar);</span>

            case Symbols.QUESTION:
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">                if (processQuestion(task, nar))</span>
<span class="fc" id="L694">                    return task;</span>
                break;

            case Symbols.QUEST:
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">                if (processQuest(task, nar))</span>
<span class="fc" id="L699">                    return task;</span>

                break;

            default:
<span class="nc" id="L704">                throw new RuntimeException(&quot;Invalid sentence type: &quot; + task);</span>
        }

<span class="nc" id="L707">        return null;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>