<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PremiseRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.nal.meta</a> &gt; <span class="el_source">PremiseRule.java</span></div><h1>PremiseRule.java</h1><pre class="source lang-java linenums">package nars.nal.meta;

import com.google.common.collect.ListMultimap;
import com.google.common.collect.MultimapBuilder;
import com.google.common.collect.Sets;
import nars.$;
import nars.Global;
import nars.Op;
import nars.nal.Level;
import nars.nal.meta.op.Solve;
import nars.nal.meta.pre.*;
import nars.nal.op.*;
import nars.term.Term;
import nars.term.TermIndex;
import nars.term.TermVector;
import nars.term.Terms;
import nars.term.atom.Atom;
import nars.term.compound.Compound;
import nars.term.compound.GenericCompound;
import nars.term.constraint.MatchConstraint;
import nars.term.constraint.NoCommonSubtermsConstraint;
import nars.term.constraint.NotEqualsConstraint;
import nars.term.constraint.NotOpConstraint;
import nars.term.match.Ellipsis;
import nars.term.transform.CompoundTransform;
import nars.term.transform.MapSubst;
import nars.term.transform.VariableNormalization;
import nars.term.variable.Variable;
import org.jetbrains.annotations.NotNull;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;

import static nars.Op.VAR_PATTERN;
import static nars.term.Terms.concat;

/**
 * A rule which matches a Premise and produces a Task
 * contains: preconditions, predicates, postconditions, post-evaluations and metainfo
 */
public class PremiseRule extends GenericCompound implements Level {


<span class="fc" id="L46">    public static final Class&lt;? extends ImmediateTermTransform&gt;[] Operators = new Class[] {</span>
        intersect.class,
        differ.class,
        union.class,
        substitute.class,
        substituteIfUnifies.class,
//        occurrsForward.class,
//        occurrsBackward.class
    };

    /** blank marker trie node indicating the derivation and terminating the branch */
<span class="fc" id="L57">    public static final BooleanCondition END = new AtomicBooleanCondition&lt;PremiseMatch&gt;() {</span>


        @Override
        public boolean booleanValueOf(PremiseMatch versioneds) {
<span class="fc" id="L62">            return true;</span>
        }

        @Override public String toString() {
<span class="fc" id="L66">            return &quot;End&quot;;</span>
        }
    };

<span class="fc" id="L70">    public boolean immediate_eternalize = false;</span>

<span class="fc" id="L72">    public boolean anticipate = false;</span>
    //public boolean sequenceIntervalsFromTask = false;
    //public boolean sequenceIntervalsFromBelief = false;

    /** conditions which can be tested before term matching */
    public BooleanCondition[] prePreconditions;

    /** conditions which are tested after term matching, including term matching itself */
    public BooleanCondition[] postPreconditions;

    public PostCondition[] postconditions;

    public PatternCompound pattern;

    //it has certain pre-conditions, all given as predicates after the two input premises


<span class="fc" id="L89">    boolean allowBackward = false;</span>

    /** maximum of the minimum NAL levels involved in the postconditions of this rule */
    public int minNAL;

    private final String str;
    protected String source;
    public MatchTaskBelief match;

    @NotNull
    public final Compound getPremise() {
<span class="fc" id="L100">        return (Compound) term(0);</span>
    }

    @NotNull
    public final Compound getConclusion() {
<span class="fc" id="L105">        return (Compound) term(1);</span>
    }

    PremiseRule(@NotNull Compound premisesResultProduct) {
<span class="fc" id="L109">        this((Compound)premisesResultProduct.term(0), (Compound)premisesResultProduct.term(1));</span>
<span class="fc" id="L110">    }</span>

    public PremiseRule(Compound premises, Compound result) {
<span class="fc" id="L113">        super(Op.PRODUCT, new TermVector(premises, result) );</span>
<span class="fc" id="L114">        str = super.toString();</span>
<span class="fc" id="L115">    }</span>


//    public final boolean validTaskPunctuation(final char p) {
//        if ((p == Symbols.QUESTION) &amp;&amp; !allowQuestionTask)
//            return false;
//        return true;
//    }

    protected final void ensureValid() {

//        if (getConclusionTermPattern().containsTemporal()) {
//            if ((!getTaskTermPattern().containsTemporal())
//                    &amp;&amp;
//                    (!getBeliefTermPattern().containsTemporal())) {
//                //if conclusion is temporal term but the premise has none:
//
//                String s = toString();
//                if ((!s.contains(&quot;after&quot;)) &amp;&amp; (!s.contains(&quot;concurrent&quot;) &amp;&amp; (!s.contains(&quot;measure&quot;)))) {
//                    //System.err.println
//                  throw new RuntimeException
//                            (&quot;Possibly invalid temporal rule from atemporal premise: &quot; + this);
//
//                }
//            }
//        }
//

<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (postconditions.length == 0)</span>
<span class="nc" id="L144">            throw new RuntimeException(this + &quot; has no postconditions&quot;);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (!Variable.hasPatternVariable(getTask()))</span>
<span class="nc" id="L146">            throw new RuntimeException(&quot;rule's task term pattern has no pattern variable&quot;);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (!Variable.hasPatternVariable(getBelief()))</span>
<span class="nc" id="L148">            throw new RuntimeException(&quot;rule's task belief pattern has no pattern variable&quot;);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (!Variable.hasPatternVariable(getConclusionTermPattern()))</span>
<span class="nc" id="L150">            throw new RuntimeException(&quot;rule's conclusion belief pattern has no pattern variable&quot;);</span>
<span class="fc" id="L151">    }</span>






    /** add the sequence of involved conditions to a list, for one given postcondition (ex: called for each this.postconditions)  */
    @NotNull
    public List&lt;Term&gt; getConditions(@NotNull PostCondition post) {

<span class="fc" id="L162">        int n = prePreconditions.length + postPreconditions.length;</span>

<span class="fc" id="L164">        List&lt;Term&gt; l = Global.newArrayList(n+4 /* estimate */);</span>

        ///--------------
<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (BooleanCondition p : prePreconditions)</span>
<span class="fc" id="L168">            p.addConditions(l);</span>

<span class="fc" id="L170">        match.addPreConditions(l); //pre-conditions</span>

<span class="fc" id="L172">        Solve truth = Solve.the(post,</span>
            this, anticipate, immediate_eternalize,  postPreconditions
        );

<span class="fc" id="L176">        truth.addConditions(l);</span>

<span class="fc" id="L178">        match.addConditions(l); //the match itself</span>

        { /* FOR EACH MATCH */
<span class="fc" id="L181">            l.add(truth.getDerive()); //will be linked to and invoked by match callbacks</span>
        }


<span class="fc" id="L185">        l.add(END);</span>

<span class="fc" id="L187">        return l;</span>
    }




    public void setSource(String source) {
<span class="fc" id="L194">        this.source = source;</span>
<span class="fc" id="L195">    }</span>

    /** source string that generated this rule (for debugging) */
    public String getSource() {
<span class="nc" id="L199">        return source;</span>
    }

    protected final Term getTask() {
<span class="fc" id="L203">        return getPremise().term(0);</span>
    }




    protected final Term getBelief() {
<span class="fc" id="L210">        return getPremise().term(1);</span>
    }

    protected final Term getConclusionTermPattern() {
<span class="fc" id="L214">        return getConclusion().term(0);</span>
    }



    @Override
    public final String toString() {
<span class="fc" id="L221">        return str;</span>
    }

    public final Term task() {
<span class="nc" id="L225">        return pattern.term(0);</span>
    }
    public final Term belief() {
<span class="nc" id="L228">        return pattern.term(1);</span>
    }

    /** deduplicate and generate match-optimized compounds for rules */
    public void compile(@NotNull TermIndex index) {
<span class="fc" id="L233">        Term[] premisePattern = ((Compound) term(0)).terms();</span>
<span class="fc" id="L234">        premisePattern[0] = index.theTerm(premisePattern[0]); //task pattern</span>
<span class="fc" id="L235">        premisePattern[1] = index.theTerm(premisePattern[1]); //belief pattern</span>
<span class="fc" id="L236">    }</span>

<span class="fc" id="L238">    static final class UppercaseAtomsToPatternVariables implements CompoundTransform&lt;Compound, Term&gt; {</span>


        @Override
        public boolean test(Term term) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (term instanceof Atom) {</span>
<span class="fc" id="L244">                String name = term.toString();</span>
<span class="fc" id="L245">                return (Character.isUpperCase(name.charAt(0)));</span>
            }
<span class="fc" id="L247">            return false;</span>
        }

        @NotNull
        @Override
        public Term apply(@NotNull Compound containingCompound, @NotNull Term v, int depth) {

            //do not alter postconditions
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if ((containingCompound.op() == Op.INHERIT)</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">                    &amp;&amp; PostCondition.reservedMetaInfoCategories.contains(</span>
<span class="fc" id="L257">                    ((Compound) containingCompound).term(1)))</span>
<span class="fc" id="L258">                return v;</span>

<span class="fc" id="L260">            return Variable.v(Op.VAR_PATTERN, v.toString());</span>
        }
    }

<span class="fc" id="L264">    static final UppercaseAtomsToPatternVariables UppercaseAtomsToPatternVariables = new UppercaseAtomsToPatternVariables();</span>


    @NotNull
    public final PremiseRule normalizeRule(@NotNull PatternIndex index) {
<span class="fc" id="L269">        return new PremiseRule(</span>
<span class="fc" id="L270">                (Compound)index.the(</span>
<span class="fc" id="L271">                $.terms.transform(</span>
<span class="fc" id="L272">                    $.terms.transform(this, UppercaseAtomsToPatternVariables),</span>
                new PremiseRuleVariableNormalization()) ) );
    }



    @NotNull
    public final PremiseRule setup(@NotNull PatternIndex index) /* throws PremiseRuleException */ {

<span class="fc" id="L281">        compile(index);</span>

        //1. construct precondition term array
        //Term[] terms = terms();

<span class="fc" id="L286">        Term[] precon = ((Compound) term(0)).terms();</span>
<span class="fc" id="L287">        Term[] postcons = ((Compound) term(1)).terms();</span>


<span class="fc" id="L290">        List&lt;BooleanCondition&gt; prePreConditionsList = Global.newArrayList(precon.length);</span>
<span class="fc" id="L291">        List&lt;BooleanCondition&gt; preConditionsList = Global.newArrayList(precon.length);</span>


<span class="fc" id="L294">        Term taskTermPattern = getTaskTermPattern();</span>
<span class="fc" id="L295">        Term beliefTermPattern = getBeliefTermPattern();</span>

<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (beliefTermPattern.op(Op.ATOM)) {</span>
<span class="nc" id="L298">            throw new RuntimeException(&quot;belief term must contain no atoms: &quot; + beliefTermPattern);</span>
        }

        //if it contains an atom term, this means it is a modifier,
        //and not a belief term pattern
        //(which will not reference any particular atoms)




<span class="fc" id="L308">        pattern = new PatternCompound((Compound)$.p(taskTermPattern, beliefTermPattern));</span>


<span class="fc" id="L311">        ListMultimap&lt;Term, MatchConstraint&gt; constraints = MultimapBuilder.treeKeys().arrayListValues().build();</span>

        //additional modifiers: either preConditionsList or beforeConcs, classify them here
<span class="fc bfc" id="L314" title="All 2 branches covered.">        for (int i = 2; i &lt; precon.length; i++) {</span>
//            if (!(precon[i] instanceof Inheritance)) {
//                System.err.println(&quot;unknown precondition type: &quot; + precon[i] + &quot; in rule: &quot; + this);
//                continue;
//            }

<span class="fc" id="L320">            Compound predicate = (Compound) precon[i];</span>
<span class="fc" id="L321">            Term predicate_name = predicate.term(1);</span>

<span class="fc" id="L323">            String predicateNameStr = predicate_name.toString().substring(1);//.replace(&quot;^&quot;, &quot;&quot;);</span>

<span class="fc" id="L325">            BooleanCondition next = null, preNext = null;</span>

            Term[] args;
            Term arg1, arg2;

            //if (predicate.getSubject() instanceof SetExt) {
                //decode precondition predicate arguments
<span class="fc" id="L332">            args = ((Compound)(predicate.term(0))).terms();</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            arg1 = (args.length &gt; 0) ? args[0] : null;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            arg2 = (args.length &gt; 1) ? args[1] : null;</span>
            /*} else {
                throw new RuntimeException(&quot;invalid arguments&quot;);*/
                /*args = null;
                arg1 = arg2 = null;*/
            //}

<span class="pc bpc" id="L341" title="35 of 65 branches missed.">            switch (predicateNameStr) {</span>

                case &quot;neq&quot;:
<span class="fc" id="L344">                    constraints.put(arg1, new NotEqualsConstraint(arg2));</span>
<span class="fc" id="L345">                    constraints.put(arg2, new NotEqualsConstraint(arg1));</span>

                    //TODO eliminate need for:
                    //next = NotEqual.make(arg1, arg2);

<span class="fc" id="L350">                    break;</span>

                case &quot;no_common_subterm&quot;:
<span class="fc" id="L353">                    constraints.put(arg1, new NoCommonSubtermsConstraint(arg2));</span>
<span class="fc" id="L354">                    constraints.put(arg2, new NoCommonSubtermsConstraint(arg1));</span>

                    //next = NoCommonSubterm.make(arg1, arg2);
<span class="fc" id="L357">                    break;</span>

                //postcondition test
                case &quot;not_equal&quot;:
<span class="fc" id="L361">                    next = NotEqual.make(arg1, arg2);</span>
<span class="fc" id="L362">                    break;</span>


                case &quot;notSet&quot;:
<span class="fc" id="L366">                    constraints.put( arg1, new NotOpConstraint(Op.SetsBits) );</span>
<span class="fc" id="L367">                    break;</span>


                case &quot;notConjunction&quot;:
<span class="fc" id="L371">                    constraints.put(arg1, new NotOpConstraint(Op.ConjunctivesBits));</span>
<span class="fc" id="L372">                    break;</span>


                case &quot;notImplicationOrEquivalence&quot;:
<span class="fc" id="L376">                    constraints.put(arg1, new NotOpConstraint(Op.ImplicationOrEquivalenceBits));</span>
<span class="fc" id="L377">                    break;</span>



//                case &quot;event&quot;:
//                    preNext = Temporality.both;
//                    break;

//                case &quot;temporal&quot;:
//                    preNext = Temporality.either;
//                    break;

                case &quot;occurr&quot;:
<span class="fc" id="L390">                    preNext = new occurr(arg1,arg2);</span>
<span class="fc" id="L391">                    break;</span>

                case &quot;after&quot;:
<span class="pc bpc" id="L394" title="8 of 14 branches missed.">                    switch (arg1.toString()) {</span>
                        case &quot;forward&quot;:
<span class="fc" id="L396">                            preNext = Event.After.forward;</span>
<span class="fc" id="L397">                            break;</span>
                        case &quot;reverseStart&quot;:
<span class="nc" id="L399">                            preNext = Event.After.reverseStart;</span>
<span class="nc" id="L400">                            break;</span>
                        case &quot;reverseEnd&quot;:
<span class="fc" id="L402">                            preNext = Event.After.reverseEnd;</span>
<span class="fc" id="L403">                            break;</span>
                        default:
<span class="nc" id="L405">                            throw new RuntimeException(&quot;invalid after() argument: &quot; + arg1);</span>
                    }
<span class="fc" id="L407">                    break;</span>

                case &quot;dt&quot;:
<span class="pc bpc" id="L410" title="12 of 30 branches missed.">                    switch (arg1.toString()) {</span>
                        case &quot;avg&quot;:
<span class="fc" id="L412">                            preNext = dt.avg; break;</span>
                        case &quot;task&quot;:
<span class="fc" id="L414">                            preNext = dt.task; break;</span>
                        case &quot;exact&quot;:
<span class="nc" id="L416">                            preNext = dt.exact; break;</span>
                        case &quot;sum&quot;:
<span class="fc" id="L418">                            preNext = dt.sum; break;</span>
                        case &quot;sumNeg&quot;:
<span class="fc" id="L420">                            preNext = dt.sumNeg; break;</span>
                        case &quot;bmint&quot;:
<span class="fc" id="L422">                            preNext = dt.bmint; break;</span>
                        case &quot;tminb&quot;:
<span class="fc" id="L424">                            preNext = dt.tminb; break;</span>
                        default:
<span class="nc" id="L426">                            throw new RuntimeException(&quot;invalid dt() argument: &quot; + arg1);</span>
                    }
<span class="fc" id="L428">                    break;</span>


//                case &quot;beforePos&quot;:
//                    preNext = Event.Before.forward;
//                    break;
//                case &quot;beforeNeg&quot;:
//                    preNext = Event.Before.reverse;
//                    break;

//                case &quot;concurrent&quot;:
//                    preNext = Concurrent.the;
//                    break;

//
//                case &quot;measure_time&quot;:
//                    if (args.length!=1)
//                        throw new RuntimeException(&quot;measure_time requires 1 component&quot;);
//
//                    preNext = Temporality.both;
//                    next = new MeasureTime(arg1);
//                    break;



                case &quot;substitute&quot;:
                case &quot;substitute_if_unifies&quot;:
<span class="nc" id="L455">                    throw new RuntimeException(&quot;depr&quot;);</span>
                    //afterConcs.add(new Substitute(arg1, (Variable)arg2));
                    //break;

                    //afterConcs.add(new SubstituteIfUnified(arg1, arg2, args[2]));
                    //break;

//                case &quot;intersection&quot;:
//                    afterConcs.add(new Intersect(arg1, arg2, args[2]));
//                    break;
//
//                case &quot;union&quot;:
//                    afterConcs.add(new Unite(arg1, arg2, args[2]));
//                    break;
//
//                case &quot;difference&quot;:
//                    afterConcs.add(new Differ(arg1, arg2, args[2]));
//                    break;

                case &quot;task&quot;:
<span class="pc bpc" id="L475" title="9 of 18 branches missed.">                    switch (arg1.toString()) {</span>
                        case &quot;negative&quot;:
<span class="fc" id="L477">                            preNext = TaskNegative.the;</span>
<span class="fc" id="L478">                            break;</span>
                        case &quot;\&quot;?\&quot;&quot;:
<span class="fc" id="L480">                            preNext = TaskPunctuation.TaskQuestion;</span>
<span class="fc" id="L481">                            break;</span>
                        case &quot;\&quot;.\&quot;&quot;:
<span class="fc" id="L483">                            preNext = TaskPunctuation.TaskJudgment;</span>
<span class="fc" id="L484">                            break;</span>
                        case &quot;\&quot;!\&quot;&quot;:
<span class="nc" id="L486">                            preNext = TaskPunctuation.TaskGoal;</span>
<span class="nc" id="L487">                            break;</span>
                        default:
<span class="nc" id="L489">                            throw new RuntimeException(&quot;Unknown task punctuation type: &quot; + predicate.term(0));</span>
                    }
<span class="fc" id="L491">                    break;</span>


                case &quot;not_conjunction&quot;:
                case &quot;not_set&quot;:
                case &quot;not_implication_or_equivalence&quot;:
                case &quot;shift_occurrence_forward&quot;:
                case &quot;shift_occurrence_backward&quot;:
<span class="nc" id="L499">                    throw new RuntimeException(&quot;depr&quot;);</span>

                default:
<span class="nc" id="L502">                    throw new RuntimeException(&quot;unhandled postcondition: &quot; + predicateNameStr + &quot; in &quot; + this + &quot;&quot;);</span>

            }


<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (preNext!=null) {</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                if (!prePreConditionsList.contains(preNext)) //unique</span>
<span class="fc" id="L509">                    prePreConditionsList.add(preNext);</span>
            }
<span class="fc bfc" id="L511" title="All 2 branches covered.">            if (next != null)</span>
<span class="fc" id="L512">                preConditionsList.add(next);</span>
        }


<span class="fc" id="L516">        this.match = new MatchTaskBelief(</span>
<span class="fc" id="L517">                            new TaskBeliefPair(pattern.term(0), pattern.term(1)), //HACK</span>
                            constraints);


        //store to arrays
<span class="fc" id="L522">        prePreconditions = prePreConditionsList.toArray(new BooleanCondition[prePreConditionsList.size()]);</span>
<span class="fc" id="L523">        postPreconditions = preConditionsList.toArray(new BooleanCondition[preConditionsList.size()]);</span>


<span class="fc" id="L526">        List&lt;PostCondition&gt; postConditions = Global.newArrayList();</span>

<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (int i = 0; i &lt; postcons.length; ) {</span>
<span class="fc" id="L529">            Term t = postcons[i++];</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">            if (i &gt;= postcons.length)</span>
<span class="nc" id="L531">                throw new RuntimeException(&quot;invalid rule: missing meta term for postcondition involving &quot; + t);</span>


<span class="fc" id="L534">            Term[] modifiers = ((Compound) postcons[i++]).terms();</span>

<span class="fc" id="L536">            PostCondition pc = PostCondition.make(this, t,</span>
<span class="fc" id="L537">                    Terms.toSortedSetArray(modifiers));</span>

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            if (pc!=null)</span>
<span class="fc" id="L540">                postConditions.add( pc );</span>
<span class="fc" id="L541">        }</span>

<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (Sets.newHashSet(postConditions).size()!=postConditions.size())</span>
<span class="nc" id="L544">            throw new RuntimeException(&quot;postcondition duplicates:\n\t&quot; + postConditions);</span>

<span class="fc" id="L546">        postconditions = postConditions.toArray( new PostCondition[postConditions.size() ] );</span>


        //TODO add modifiers to affect minNAL (ex: anything temporal set to 7)
        //this will be raised by conclusion postconditions of higher NAL level
<span class="fc" id="L551">        minNAL =</span>
<span class="fc" id="L552">                Math.max(minNAL,</span>
<span class="fc" id="L553">                    Math.max(</span>
<span class="fc" id="L554">                            Terms.maxLevel(pattern.term(0)),</span>
<span class="fc" id="L555">                            Terms.maxLevel(pattern.term(1)</span>
                            )));


<span class="fc" id="L559">        ensureValid();</span>

<span class="fc" id="L561">        return this;</span>
    }

    public final Term getTaskTermPattern() {
<span class="fc" id="L565">        return ((Compound) term(0)).terms()[0];</span>
    }
    public final Term getBeliefTermPattern() {
<span class="fc" id="L568">        return ((Compound) term(0)).terms()[1];</span>
    }

    public final void setAllowBackward() {
<span class="fc" id="L572">        this.allowBackward = true;</span>
<span class="fc" id="L573">    }</span>


    /**
     * for each calculable &quot;question reverse&quot; rule,
     * supply to the consumer
     */
    public final void forEachQuestionReversal(@NotNull BiConsumer&lt;PremiseRule,String&gt; w) {

        //String s = w.toString();
        /*if(s.contains(&quot;task(\&quot;?&quot;) || s.contains(&quot;task(\&quot;@&quot;)) { //these are backward inference already
            return;
        }
        if(s.contains(&quot;substitute(&quot;)) { //these can't be reversed
            return;
        }*/

//        if(!allowBackward) { //explicitely stated in the rules now
//            return;
//        }

        // T, B, [pre] |- C, [post] ||--

<span class="fc" id="L596">        Term T = getTaskTermPattern();</span>
<span class="fc" id="L597">        Term B = getBeliefTermPattern();</span>
<span class="fc" id="L598">        Term C = getConclusionTermPattern();</span>

        //      C, B, [pre], task_is_question() |- T, [post]
<span class="fc" id="L601">        PremiseRule clone1 = clone(C, B, T, true);</span>
<span class="fc" id="L602">        w.accept(clone1, &quot;C,B,[pre],question |- T,[post]&quot;);</span>

        //      C, T, [pre], task_is_question() |- B, [post]
<span class="fc" id="L605">        PremiseRule clone2 = clone(C, T, B, true);</span>
<span class="fc" id="L606">        w.accept(clone2, &quot;C,T,[pre],question |- B,[post]&quot;);</span>

<span class="fc" id="L608">    }</span>



//    @Override
//    public Term clone(TermContainer subs) {
//        return null;
//    }

    //    @Override
//    public Term clone(Term[] x) {
//        return new TaskRule((Compound)x[0], (Compound)x[1]);
//    }


    /**
     * for each calculable &quot;question reverse&quot; rule,
     * supply to the consumer
     */
    @NotNull
    public final PremiseRule forwardPermutation() {

        // T, B, [pre] |- C, [post] ||--

<span class="fc" id="L632">        Term T = getTaskTermPattern();</span>
<span class="fc" id="L633">        Term B = getBeliefTermPattern();</span>
<span class="fc" id="L634">        Term C = getConclusionTermPattern();</span>

        //      B, T, [pre], task_is_question() |- T, [post]

<span class="fc" id="L638">        return clone(B, T, C, false);</span>
    }

    @NotNull
    private PremiseRule clone(Term newT, Term newB, Term newR, boolean question) {

<span class="fc" id="L644">        Map&lt;Term,Term&gt; m = new HashMap(3);</span>
<span class="fc" id="L645">        m.put(getTaskTermPattern(), newT);</span>
<span class="fc" id="L646">        m.put(getBeliefTermPattern(), newB);</span>
<span class="fc" id="L647">        m.put(getConclusionTermPattern(), newR);</span>

<span class="fc" id="L649">        Compound remapped = (Compound)$.terms.transform(this, new MapSubst(m), false);</span>

        //Append taskQuestion
<span class="fc" id="L652">        Compound pc = (Compound) remapped.term(0);</span>
<span class="fc" id="L653">        Term[] pp = pc.terms(); //premise component</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">        Compound newPremise = question ?</span>
<span class="fc" id="L655">                $.p(concat(pp, TaskPunctuation.TaskQuestionTerm) ) :</span>
<span class="fc" id="L656">                pc;</span>

<span class="fc" id="L658">        return new PremiseRule(newPremise, (Compound)remapped.term(1));</span>


//
//        /*if (StringUtils.countMatches(newPremise.toString(), &quot;task(\&quot;&quot;) &gt; 1) {
//            System.err.println(newPremise);
//        }*/
//
//        newPremise.terms()[0] = newT;
//        newPremise.terms()[1] = newB;
//
//        Term[] newConclusion = getConclusion().terms().clone();
//        newConclusion[0] = newR;
//
//
//        return new PremiseRule(newPremise, $.p( newConclusion ));
    }

//    /**
//     * -1 or +1 depending on how arg1 and arg2 match either Task/Belief of the premise
//     * @return +1 if first arg=task, second arg = belief, -1 if opposite,
//     * throws exception if incomplete match
//     */
//    public final int getTaskOrder(Term arg1, Term arg2) {
//
//        Product p = getPremises();
//        Term taskPattern = p.term(0);
//        Term beliefPattern = p.term(1);
//        if (arg2.equals(taskPattern) &amp;&amp; arg1.equals(beliefPattern)) {
//            return -1;
//        } else if (arg1.equals(taskPattern) &amp;&amp; arg2.equals(beliefPattern)) {
//            return 1;
//        } else {
//            throw new RuntimeException(&quot;after(X,Y) needs to match both taks and belief patterns, in one of 2 orderings&quot;);
//        }
//
//    }

<span class="nc" id="L696">    public final int nal() { return minNAL; }</span>

<span class="fc" id="L698">    public static final class PremiseRuleVariableNormalization extends VariableNormalization {</span>


<span class="fc" id="L701">        int offset = 0;</span>

        public static Variable varPattern(int i) {
<span class="fc" id="L704">            return $.v(VAR_PATTERN, i);</span>
        }

        @Override protected Variable newVariable(@NotNull Variable v, int serial) {


<span class="fc bfc" id="L710" title="All 2 branches covered.">            if (v instanceof Ellipsis) {</span>
<span class="fc" id="L711">                Ellipsis e = (Ellipsis)v;</span>
<span class="fc" id="L712">                Variable r = e.clone(varPattern(serial+offset), this);</span>
<span class="fc" id="L713">                offset = 0; //return to zero</span>
<span class="fc" id="L714">                return r;</span>
            }
            else {
<span class="fc" id="L717">                Variable newVar = v.normalize(serial+offset);</span>
<span class="fc" id="L718">                return newVar;</span>
            }
        }

        @Override
        public final boolean testSuperTerm(@NotNull Compound t) {
            //descend all, because VAR_PATTERN is not yet always considered a variable
<span class="fc" id="L725">            return true;</span>
        }

        public Term applyAfter(Variable secondary) {
<span class="fc" id="L729">            offset++;</span>
<span class="fc" id="L730">            return apply(null, secondary, -1);</span>
        }
    }
}




</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>