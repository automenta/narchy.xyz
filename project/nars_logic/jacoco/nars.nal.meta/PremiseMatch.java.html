<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PremiseMatch.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.nal.meta</a> &gt; <span class="el_source">PremiseMatch.java</span></div><h1>PremiseMatch.java</h1><pre class="source lang-java linenums">package nars.nal.meta;

import nars.$;
import nars.Global;
import nars.Op;
import nars.budget.Budget;
import nars.budget.BudgetFunctions;
import nars.budget.UnitBudget;
import nars.concept.ConceptProcess;
import nars.nal.Deriver;
import nars.nal.meta.op.MatchTerm;
import nars.nal.nal8.Operator;
import nars.nal.op.ImmediateTermTransform;
import nars.task.Task;
import nars.term.Term;
import nars.term.Termed;
import nars.term.compound.Compound;
import nars.term.transform.FindSubst;
import nars.truth.Truth;
import nars.util.version.Versioned;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Map;
import java.util.Random;
import java.util.function.Consumer;


/**
 * rule matching context, re-recyclable as thread local
 */
public class PremiseMatch extends FindSubst {

    /** Global Context */
    public Consumer&lt;Task&gt; receiver;

    /** current Premise */
    public ConceptProcess premise;

    //public final VarCachedVersionMap secondary;
    @NotNull
    public final Versioned&lt;Integer&gt; occDelta;
    @NotNull
    public final Versioned&lt;Integer&gt; tDelta;
    @NotNull
    public final Versioned&lt;Truth&gt; truth;
    @NotNull
    public final Versioned&lt;Character&gt; punct;
    @NotNull
    public final Versioned&lt;MatchTerm&gt; pattern;

<span class="fc" id="L52">    @NotNull</span>
    private TaskBeliefPair termPattern = new TaskBeliefPair();
    public boolean cyclic;
    int termutesPerMatch, termutes;

<span class="fc" id="L57">    final Map&lt;Operator, ImmediateTermTransform&gt; transforms =</span>
<span class="fc" id="L58">            Global.newHashMap();</span>
<span class="fc" id="L59">    private float minConfidence = Global.TRUTH_EPSILON;</span>

    public PremiseMatch(Random r) {
<span class="fc" id="L62">        super(Op.VAR_PATTERN, r );</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (Class&lt;? extends ImmediateTermTransform&gt; c : PremiseRule.Operators) {</span>
<span class="fc" id="L65">            addTransform(c);</span>
        }

        //secondary = new VarCachedVersionMap(this);
<span class="fc" id="L69">        occDelta = new Versioned(this);</span>
<span class="fc" id="L70">        tDelta = new Versioned(this);</span>
<span class="fc" id="L71">        truth = new Versioned(this);</span>
<span class="fc" id="L72">        punct = new Versioned(this);</span>
<span class="fc" id="L73">        pattern = new Versioned(this);</span>
<span class="fc" id="L74">    }</span>

    /**
     * Forward logic with CompoundTerm conclusion
     *
     * @param truth The truth value of the conclusion
     * @param content The content of the conclusion
     * @param nal Reference to the memory
     * @return The budget of the conclusion
     */
    public static Budget compoundForward(@NotNull Truth truth, @NotNull Termed content, @NotNull ConceptProcess nal) {
<span class="fc" id="L85">        return BudgetFunctions.compoundForward(new UnitBudget(), truth, content, nal);</span>
    }

    private void addTransform(@NotNull Class&lt;? extends ImmediateTermTransform&gt; c) {
<span class="fc" id="L89">        Operator o = $.operator(c.getSimpleName());</span>
        try {
<span class="fc" id="L91">            transforms.put(o, c.newInstance());</span>
<span class="nc" id="L92">        } catch (Exception e) {</span>
<span class="nc" id="L93">            throw new RuntimeException(c + &quot;: &quot; + e);</span>
<span class="fc" id="L94">        }</span>
<span class="fc" id="L95">    }</span>

    @Override public ImmediateTermTransform getTransform(Operator t) {
<span class="fc" id="L98">        return transforms.get(t);</span>
    }



    public final void match(@NotNull MatchTerm pattern /* callback */) {
<span class="fc" id="L104">        this.pattern.set(pattern); //to notify of matches</span>
<span class="fc" id="L105">        this.constraints = constraints;</span>
<span class="fc" id="L106">        matchAll(pattern.x, term.get() /* current term */);</span>
<span class="fc" id="L107">        this.constraints = null;</span>
<span class="fc" id="L108">    }</span>

    @Override
    public void matchAll(@NotNull Term x, @NotNull Term y, boolean finish) {
<span class="fc" id="L112">        this.termutes = termutesPerMatch;</span>
<span class="fc" id="L113">        super.matchAll(x, y, finish);</span>
<span class="fc" id="L114">    }</span>

    @Override
    public boolean onMatch() {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        return (termutes-- &gt; 0) ?</span>
<span class="fc" id="L119">            pattern.get().onMatch(this) :</span>
<span class="fc" id="L120">            false;</span>
    }




    @NotNull
    @Override
    public String toString() {
<span class="nc" id="L129">        return &quot;RuleMatch:{&quot; +</span>
                &quot;premise:&quot; + premise +
<span class="nc" id="L131">                &quot;, subst:&quot; + super.toString() +</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                (pattern.get()!=null ? (&quot;, derived:&quot; + pattern) : &quot;&quot;)+</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                (truth.get()!=null ? (&quot;, truth:&quot; + truth) : &quot;&quot;)+</span>
                //(!secondary.isEmpty() ? (&quot;, secondary:&quot; + secondary) : &quot;&quot;)+
                //(occurrenceShift.get()!=null ? (&quot;, occShift:&quot; + occurrenceShift) : &quot;&quot;)+
                //(branchPower.get()!=null ? (&quot;, derived:&quot; + branchPower) : &quot;&quot;)+
                '}';

    }

    /**
     * set the next premise
     */
    public final void start(@NotNull ConceptProcess p, Consumer&lt;Task&gt; receiver, @NotNull Deriver d) {

<span class="fc" id="L146">        premise = p;</span>
<span class="fc" id="L147">        this.receiver = receiver;</span>

<span class="fc" id="L149">        Compound taskTerm = p.getTask().term();</span>

<span class="fc" id="L151">        Termed beliefTerm = p.getBeliefTerm();  //experimental, prefer to use the belief term's Term in case it has more relevant TermMetadata (intermvals)</span>

<span class="fc" id="L153">        this.termutesPerMatch = p.getMaxMatches();</span>

<span class="fc" id="L155">        termPattern.set( taskTerm.term(), beliefTerm.term() );</span>
<span class="fc" id="L156">        term.set( termPattern );</span>

<span class="fc" id="L158">        cyclic = p.isCyclic();</span>

//        //set initial power which will be divided by branch
//        setPower(
//            //LERP the power in min/max range by premise mean priority
//            (int) ((p.getMeanPriority() * (Global.UNIFICATION_POWER - Global.UNIFICATION_POWERmin))
//                    + Global.UNIFICATION_POWERmin)
//        );

        //setPower(branchPower.get()); //HACK is this where it should be assigned?

<span class="fc" id="L169">        d.run(this);</span>

<span class="fc" id="L171">        clear();</span>

<span class="fc" id="L173">    }</span>

//    public final void occurrenceAdd(long durationsDelta) {
//        //TODO move to post
//        int oc = occurrenceShift.getIfAbsent(Tense.TIMELESS);
//        if (oc == Tense.TIMELESS)
//            oc = 0;
//        oc += durationsDelta * premise.getTask().duration();
//        occurrenceShift.set((int)oc);
//    }

    /** calculates Budget used in a derived task,
     *  returns null if invalid / insufficient */
    public final Budget getBudget(@Nullable Truth truth, @NotNull Termed c) {

<span class="fc" id="L188">        ConceptProcess p = this.premise;</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">        Budget budget = truth != null ?</span>
<span class="fc" id="L191">                compoundForward(truth, c, p) :</span>
<span class="fc" id="L192">                BudgetFunctions.compoundBackward(c, p);</span>

//        if (Budget.isDeleted(budget.getPriority())) {
//            throw new RuntimeException(&quot;why is &quot; + budget + &quot; deleted&quot;);
//        }

<span class="fc" id="L198">        float derThresh = p.memory().derivationDurabilityThreshold.floatValue();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (budget.getDurability() &lt; derThresh)</span>
<span class="fc" id="L200">            return null;</span>


//        if (!!budget.summaryLessThan(p.memory().derivationThreshold.floatValue())) {
////            if (false) {
////                RuleMatch.removeInsufficientBudget(premise, new PreTask(t,
////                        m.punct.get(), truth, budget,
////                        m.occurrenceShift.getIfAbsent(Tense.TIMELESS), premise));
////            }
//            return null;
//        }

<span class="fc" id="L212">        return budget;</span>
    }

    @Nullable
    @Override public final Term apply(Term t) {
        //TODO make a half resolve that only does xy?

//        Term ret = getXY(t);
//        if (ret != null) {
//            ret = getYX(ret);
//        }
//
//        if (ret != null) return ret;
//        return t;
<span class="fc" id="L226">            Term ret = premise.memory().index.apply(this, t);</span>

//            if ((ret != null) /*&amp;&amp; (!yx.isEmpty())*/) {
//                ret = ret.apply(yx, fullMatch);
//            }
<span class="fc" id="L231">            return ret;</span>


    }

    public void setMinConfidence(float minConfidence) {
<span class="fc" id="L237">        this.minConfidence = minConfidence;</span>
<span class="fc" id="L238">    }</span>

    public float getMinConfidence() {
<span class="fc" id="L241">        return minConfidence;</span>
    }
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>