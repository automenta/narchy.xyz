<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Evaluator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.op.software.scheme</a> &gt; <span class="el_source">Evaluator.java</span></div><h1>Evaluator.java</h1><pre class="source lang-java linenums">package nars.op.software.scheme;

import nars.op.software.scheme.cons.Cons;
import nars.op.software.scheme.expressions.*;
import org.jetbrains.annotations.NotNull;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import static nars.op.software.scheme.expressions.ListExpression.list;
import static nars.op.software.scheme.expressions.SymbolExpression.symbol;


<span class="pc" id="L15">public enum Evaluator {</span>
    ;

    public static Expression evaluate(@NotNull Expression exp, SchemeClosure env) {
<span class="fc" id="L19">        return analyze(exp).apply(env);</span>
    }

    @NotNull
    public static Function&lt;SchemeClosure, Expression&gt; analyze(@NotNull Expression exp) {
<span class="fc bfc" id="L24" title="All 2 branches covered.">        if (isSelfEvaluating(exp)) {</span>
<span class="fc" id="L25">            return e -&gt; exp;</span>
        }
<span class="fc bfc" id="L27" title="All 2 branches covered.">        if (exp.isSymbol()) {</span>
<span class="fc" id="L28">            return env -&gt; env.get(exp.symbol());</span>
        }
<span class="fc bfc" id="L30" title="All 2 branches covered.">        if (isSpecialForm(exp)) {</span>
<span class="fc" id="L31">            return analyzeSpecialForm(exp.list());</span>
        }
<span class="fc bfc" id="L33" title="All 2 branches covered.">        if (isFunctionCall(exp)) {</span>
<span class="fc" id="L34">            return analyzeFunctionCall(exp.list());</span>
        }

<span class="pc bpc" id="L37" title="1 of 2 branches missed.">        if (exp instanceof SymbolicProcedureExpression) {</span>
<span class="fc" id="L38">            return (c) -&gt; exp;</span>
        }


<span class="nc" id="L42">        throw new IllegalArgumentException(String.format(&quot;Unable to evaluate expression '%s'&quot;, exp + &quot; (&quot; + exp.getClass() + ')'));</span>
    }

    @NotNull
    private static Function&lt;SchemeClosure, Expression&gt; analyzeSpecialForm(@NotNull ListExpression exp) {
<span class="fc" id="L47">        Cons&lt;Expression&gt; exps = exp.value;</span>

        //TODO use an enum of these operators already decoded to byte[] so that symbols dont need to re-generate a String version
<span class="pc bpc" id="L50" title="13 of 34 branches missed.">        switch (exps.car().symbol().toString()) {</span>
            case &quot;quote&quot;:
<span class="fc" id="L52">                return analyzeQuote(exps);</span>
            case &quot;set!&quot;:
<span class="fc" id="L54">                return analyzeSet(exps);</span>
            case &quot;define&quot;:
<span class="fc bfc" id="L56" title="All 2 branches covered.">                return isVarDefinition(exps) ? analyzeVarDefinition(exps) : analyzeFunctionDefinition(exps);</span>
            case &quot;if&quot;:
<span class="fc" id="L58">                return analyzeIf(exps);</span>
            case &quot;lambda&quot;:
<span class="fc" id="L60">                return analyzeLambda(exps);</span>
            case &quot;begin&quot;:
<span class="fc" id="L62">                return analyzeBegin(exps);</span>
            case &quot;let&quot;:
<span class="fc" id="L64">                return analyzeLet(exps);</span>
            case &quot;cond&quot;:
<span class="nc" id="L66">                return analyzeCond(exps);</span>
        }

<span class="nc" id="L69">        throw new IllegalArgumentException(String.format(&quot;Invalid special form expression '%s'&quot;, exp));</span>

    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeQuote(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L74">        return env -&gt; exps.cadr();</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeLambda(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L78">        Cons&lt;SymbolExpression&gt; paramNames = exps.cadr().list().value.stream()</span>
<span class="fc" id="L79">                .map(Expression::symbol)</span>
<span class="fc" id="L80">                .collect(Cons.collector());</span>
<span class="fc" id="L81">        return analyzeProcedure(paramNames, exps);</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeSet(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L85">        SymbolExpression symbol = exps.cadr().symbol();</span>
<span class="fc" id="L86">        Function&lt;SchemeClosure, Expression&gt; valueProc = analyze(exps.cdr().cadr());</span>

<span class="fc" id="L88">        return env -&gt; {</span>
<span class="fc" id="L89">            env.set(symbol, valueProc.apply(env));</span>
<span class="fc" id="L90">            return Expression.none();</span>
        };
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeFunctionDefinition(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L95">        SymbolExpression name = exps.cadr().list().value.car().symbol();</span>
<span class="fc" id="L96">        Cons&lt;SymbolExpression&gt; paramNames = exps.cadr().list().value.cdr().stream()</span>
<span class="fc" id="L97">                .map(Expression::symbol)</span>
<span class="fc" id="L98">                .collect(Cons.collector());</span>
<span class="fc" id="L99">        Function&lt;SchemeClosure, Expression&gt; lambda = analyzeProcedure(paramNames, exps);</span>
<span class="fc" id="L100">        return env -&gt; {</span>
<span class="fc" id="L101">            env.define(name, lambda.apply(env));</span>
<span class="fc" id="L102">            return Expression.none();</span>
        };
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeVarDefinition(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L107">        SymbolExpression symbol = exps.cadr().symbol();</span>
<span class="fc" id="L108">        Function&lt;SchemeClosure, Expression&gt; valueProc = analyze(exps.cdr().cadr());</span>
<span class="fc" id="L109">        return env -&gt; {</span>
<span class="fc" id="L110">            env.define(symbol, valueProc.apply(env));</span>
<span class="fc" id="L111">            return Expression.none();</span>
        };
    }

    private static boolean isVarDefinition(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L116">        return exps.cadr().isSymbol();</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeFunctionCall(@NotNull ListExpression exp) {
<span class="fc" id="L120">        List&lt;Function&lt;SchemeClosure, Expression&gt;&gt; map = exp.value.stream()</span>
<span class="fc" id="L121">                .map(Evaluator::analyze)</span>
<span class="fc" id="L122">                .collect(Collectors.toList());</span>

<span class="fc" id="L124">        return env -&gt; {</span>
<span class="fc" id="L125">            Cons&lt;Expression&gt; list = map.stream()</span>
<span class="fc" id="L126">                    .map(e -&gt; e.apply(env))</span>
<span class="fc" id="L127">                    .collect(Cons.collector());</span>
<span class="fc" id="L128">            return list.car().procedure().apply(list.cdr());</span>
        };
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeLet(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L133">        List&lt;Function&lt;SchemeClosure, Expression&gt;&gt; letBindingValues = letBindingValues(exps);</span>
<span class="fc" id="L134">        Function&lt;SchemeClosure, Expression&gt; letBody = analyzeProcedure(letBindingSymbols(exps), exps);</span>

<span class="fc" id="L136">        return env -&gt; {</span>
<span class="fc" id="L137">            Cons&lt;Expression&gt; letParams = letBindingValues.stream()</span>
<span class="fc" id="L138">                    .map(a -&gt; a.apply(env))</span>
<span class="fc" id="L139">                    .collect(Cons.collector());</span>
<span class="fc" id="L140">            return letBody.apply(env).procedure().apply(letParams);</span>
        };
    }

    private static Cons&lt;SymbolExpression&gt; letBindingSymbols(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L145">        return exps.cadr().list().value.stream()</span>
<span class="fc" id="L146">                .map(e -&gt; e.list().value.car().symbol())</span>
<span class="fc" id="L147">                .collect(Cons.collector());</span>
    }

    private static List&lt;Function&lt;SchemeClosure, Expression&gt;&gt; letBindingValues(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L151">        return exps.cadr().list().value.stream()</span>
<span class="fc" id="L152">                .map(e -&gt; e.list().value.cadr())</span>
<span class="fc" id="L153">                .map(Evaluator::analyze)</span>
<span class="fc" id="L154">                .collect(Collectors.toList());</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeBegin(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L158">        return analyzeSequence(exps.cdr());</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeSequence(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L162">        List&lt;Function&lt;SchemeClosure, Expression&gt;&gt; seq = exps.stream()</span>
<span class="fc" id="L163">                .map(Evaluator::analyze)</span>
<span class="fc" id="L164">                .collect(Collectors.toList());</span>

<span class="fc" id="L166">        return env -&gt; seq.stream()</span>
<span class="fc" id="L167">                .collect(Collectors.reducing(Expression.none(), a -&gt; a.apply(env), (a, b) -&gt; b));</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeCond(@NotNull Cons&lt;Expression&gt; exps) {
<span class="nc" id="L171">        return condToIf(exps.cdr());</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; condToIf(@NotNull Cons&lt;Expression&gt; exps) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (exps.isEmpty()) {</span>
<span class="nc" id="L176">            return e -&gt; BooleanExpression.bool(false);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        } else if (exps.size() == 1) {</span>
<span class="nc" id="L178">            Function&lt;SchemeClosure, Expression&gt; condition = analyze(exps.car().list().value.car());</span>
<span class="nc" id="L179">            Function&lt;SchemeClosure, Expression&gt; consequent = analyze(exps.car().list().value.cadr());</span>
<span class="nc" id="L180">            Optional&lt;Function&lt;SchemeClosure, Expression&gt;&gt; alternative = Optional.empty();</span>

<span class="nc" id="L182">            return makeIf(condition, consequent, alternative);</span>
        } else {
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (exps.cadr().list().value.car().equals(symbol(&quot;else&quot;))) {</span>
<span class="nc" id="L185">                Function&lt;SchemeClosure, Expression&gt; condition = analyze(exps.car().list().value.car());</span>
<span class="nc" id="L186">                Function&lt;SchemeClosure, Expression&gt; consequent = analyze(exps.car().list().value.cadr());</span>
<span class="nc" id="L187">                Optional&lt;Function&lt;SchemeClosure, Expression&gt;&gt; alternative = Optional.of(analyze(exps.cadr().list().value.cadr()));</span>
<span class="nc" id="L188">                return makeIf(condition, consequent, alternative);</span>
            } else {
<span class="nc" id="L190">                Function&lt;SchemeClosure, Expression&gt; condition = analyze(exps.car().list().value.car());</span>
<span class="nc" id="L191">                Function&lt;SchemeClosure, Expression&gt; consequent = analyze(exps.car().list().value.cadr());</span>
<span class="nc" id="L192">                Optional&lt;Function&lt;SchemeClosure, Expression&gt;&gt; alternative = Optional.of(condToIf(exps.cdr()));</span>

<span class="nc" id="L194">                return makeIf(condition, consequent, alternative);</span>
            }
        }
    }

    private static Function&lt;SchemeClosure, Expression&gt; makeIf(@NotNull Function&lt;SchemeClosure, Expression&gt; condition, @NotNull Function&lt;SchemeClosure, Expression&gt; consequent, @NotNull Optional&lt;Function&lt;SchemeClosure, Expression&gt;&gt; alternative) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        return env -&gt; isTruthy(condition.apply(env)) ? consequent.apply(env) : alternative.map(a -&gt; a.apply(env)).orElse(Expression.none());</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeIf(@NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L204">        Function&lt;SchemeClosure, Expression&gt; condition = analyze(exps.cadr());</span>
<span class="fc" id="L205">        Function&lt;SchemeClosure, Expression&gt; consequent = analyze(exps.cdr().cadr());</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        Optional&lt;Function&lt;SchemeClosure, Expression&gt;&gt; alternative = exps.size() &gt; 3 ? Optional.of(analyze(exps.cdr().cdr().cadr())) : Optional.empty();</span>
<span class="fc" id="L207">        return makeIf(condition, consequent, alternative);</span>
    }

    private static Function&lt;SchemeClosure, Expression&gt; analyzeProcedure(@NotNull Cons&lt;SymbolExpression&gt; names, @NotNull Cons&lt;Expression&gt; exps) {
<span class="fc" id="L211">        Function&lt;SchemeClosure, Expression&gt; body = analyzeSequence(exps.cdr().cdr());</span>
<span class="fc" id="L212">        return env -&gt;</span>
<span class="fc" id="L213">                ProcedureExpression.procedure(names, exps, args -&gt;</span>
<span class="fc" id="L214">                        body.apply(env.extend(makeMap(names, args, new LinkedHashMap&lt;&gt;()))));</span>
    }

    @NotNull
    private static Map&lt;SymbolExpression, Expression&gt; makeMap(@NotNull Cons&lt;SymbolExpression&gt; names, @NotNull Cons&lt;Expression&gt; args, @NotNull Map&lt;SymbolExpression, Expression&gt; map) {
        while (true) {
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (names.isEmpty()) {</span>
<span class="fc" id="L221">                return map;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            } else if (names.car().equals(symbol(&quot;.&quot;))) {</span>
<span class="fc" id="L223">                map.put(names.cadr(), list(args));</span>
<span class="fc" id="L224">                return map;</span>
            } else {
<span class="fc" id="L226">                map.put(names.car(), args.car());</span>
<span class="fc" id="L227">                names = names.cdr();</span>
<span class="fc" id="L228">                args = args.cdr();</span>
            }
        }
    }

    private static boolean isSpecialForm(@NotNull Expression exp) {
<span class="fc bfc" id="L234" title="All 4 branches covered.">        return exp.isList() &amp;&amp; exp.list().value.car().isSymbol()</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                &amp;&amp; SPECIAL_FORMS.contains(exp.list().value.car().symbol());</span>
    }

    private static boolean isFunctionCall(@NotNull Expression exp) {
<span class="pc bpc" id="L239" title="1 of 4 branches missed.">        return exp.isList() &amp;&amp; !exp.list().value.isEmpty();</span>
    }

    private static boolean isSelfEvaluating(@NotNull Expression exp) {
<span class="pc bpc" id="L243" title="1 of 12 branches missed.">        return exp.isNumber() || exp.isBoolean() || exp.isString() || exp == Expression.none() || (exp.isList() &amp;&amp; exp.list().value.isEmpty());</span>
    }

    private static boolean isTruthy(@NotNull Expression exp) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        return !BooleanExpression.bool(false).equals(exp);</span>
    }

<span class="fc" id="L250">    private static final Set&lt;SymbolExpression&gt; SPECIAL_FORMS = Arrays.stream(new String[]{&quot;quote&quot;, &quot;set!&quot;, &quot;define&quot;, &quot;if&quot;, &quot;lambda&quot;, &quot;begin&quot;, &quot;let&quot;, &quot;cond&quot;})</span>
<span class="fc" id="L251">            .map(SymbolExpression::symbol)</span>
<span class="fc" id="L252">            .collect(Collectors.toSet());</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>