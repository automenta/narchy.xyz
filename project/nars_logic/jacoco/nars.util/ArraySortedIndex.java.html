<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ArraySortedIndex.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.util</a> &gt; <span class="el_source">ArraySortedIndex.java</span></div><h1>ArraySortedIndex.java</h1><pre class="source lang-java linenums">package nars.util;

import nars.Global;
import nars.util.data.sorted.SortedIndex;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;

//import org.apache.commons.collections.iterators.ReverseListIterator;


abstract public class ArraySortedIndex&lt;E&gt; extends SortedIndex&lt;E&gt; {

    protected int capacity;

    final List&lt;E&gt; list;


    @Override
    public final void forEach(@NotNull Consumer&lt;? super E&gt; consumer) {
<span class="fc" id="L25">        list.forEach(consumer);</span>
<span class="fc" id="L26">    }</span>

    @Override
    public final boolean equals(Object obj) {
<span class="nc bnc" id="L30" title="All 2 branches missed.">        if (this == obj) return true;</span>
<span class="nc bnc" id="L31" title="All 2 branches missed.">        if (!(obj instanceof ArraySortedIndex)) return false;</span>
<span class="nc" id="L32">        ArraySortedIndex o = (ArraySortedIndex) obj;</span>
<span class="nc" id="L33">        return list.equals(o.list);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L38">        return list.hashCode();</span>
    }

    @Override public final List&lt;E&gt; getList() {
<span class="fc" id="L42">        return list;</span>
    }

    public ArraySortedIndex(int capacity) {
<span class="fc" id="L46">        this(capacity, capacity);</span>
<span class="fc" id="L47">    }</span>

    public ArraySortedIndex(int initialCapacity, int maxCapacity) {
<span class="fc" id="L50">        this(Global.newArrayList(initialCapacity), maxCapacity);</span>
<span class="fc" id="L51">    }</span>
    
<span class="fc" id="L53">    public ArraySortedIndex(List&lt;E&gt; list, int capacity) {</span>
<span class="fc" id="L54">        this.list = list;</span>
<span class="fc" id="L55">        setCapacity(capacity);</span>
<span class="fc" id="L56">    }</span>

    /**
     * any scalar decomposition function of a budget value
     * can be used
     *  //MODE 0: priority only
     return b.getPriority();

     //MODE 1:
     //return b.getBudget().summary();

     //MODE 2:
     //this ensures that priority is the most significant ordering factor, even if zero
     /*return (1+b.getPriority())*
     (b.getDurability()*b.getQuality());
     */
//    @Override public float score(E b) {
//
//        return b.getPriority();
//
//    }

    @Override
    public boolean isSorted() {
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (size() &lt; 2) return true;</span>

<span class="fc" id="L82">        Iterator&lt;E&gt; ii = iterator();</span>
<span class="fc" id="L83">        float pp = Float.MAX_VALUE;</span>

<span class="fc bfc" id="L85" title="All 2 branches covered.">        while (ii.hasNext()) {</span>
<span class="fc" id="L86">            E c = ii.next();</span>
<span class="fc" id="L87">            float sc = score(c);</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">            if (sc &gt; pp)</span>
<span class="nc" id="L89">                return false;</span>
<span class="fc" id="L90">            pp = sc;</span>
<span class="fc" id="L91">        }</span>

<span class="fc" id="L93">        return true;</span>
    }

    @Override
    public final void setCapacity(int capacity) {

<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (this.capacity==capacity) {</span>
<span class="fc" id="L100">            return;</span>
        }

<span class="fc" id="L103">        this.capacity = capacity;</span>

<span class="fc" id="L105">        List&lt;E&gt; l = list;</span>

<span class="fc" id="L107">            int n = l.size();</span>
            //remove elements from end
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">            for (; n - capacity &gt; 0; n--) {</span>
<span class="nc" id="L110">                l.remove(n-1);</span>
            }


<span class="fc" id="L114">    }</span>


    @Override public final int pos(E o) {
<span class="fc" id="L118">        return pos(score(o));</span>
    }

    public final int pos(float score) {
<span class="fc" id="L122">        int upperBound = 0;</span>
<span class="fc" id="L123">        int lowerBound = size()-1;</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">        while (upperBound &lt;= lowerBound) {</span>
<span class="fc" id="L126">            int mid = (upperBound + lowerBound) /2; // &gt;&gt;&gt; 1;</span>
<span class="fc" id="L127">            float mp = score(get(mid));</span>


<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (mp &lt; score) //midpoint is new lowerBound, so we need to go to the upper half</span>
<span class="fc" id="L131">                lowerBound = mid - 1;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            else if (mp &gt; score) //midpoint is new upperBound so go to lowerBound half</span>
<span class="fc" id="L133">                upperBound = mid + 1;</span>
            else
<span class="fc" id="L135">                return mid; // key found</span>
<span class="fc" id="L136">        }</span>
<span class="fc" id="L137">        return lowerBound;</span>
    }

    @Override
    public final E get(int i) {
<span class="fc" id="L142">        return list.get(i);</span>
    }

    @Nullable
    @Override
    public E insert(E incoming) {

<span class="fc" id="L149">        E removed = null;</span>

<span class="fc" id="L151">        int s = size();</span>

        int insertPos;
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (s == 0) {</span>
            //first element in empty list, insert at beginning
<span class="fc" id="L156">            insertPos = 0;</span>
        } else {

<span class="fc" id="L159">            float incomingScore = score(incoming);</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (s &gt;= capacity) {</span>

<span class="fc" id="L163">                int lastIndex = size() - 1;</span>
<span class="fc" id="L164">                float lowestScore = score(get(lastIndex));</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (incomingScore &lt; lowestScore) {</span>
                    //priority too low to join this list, bounce
<span class="fc" id="L168">                    return incoming;</span>
                }

<span class="fc" id="L171">                removed = remove(lastIndex);</span>
<span class="fc" id="L172">            }</span>
            else {
<span class="fc" id="L174">                removed = null;</span>
            }

<span class="fc" id="L177">            insertPos = pos(incomingScore);</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (insertPos &lt; 0)</span>
<span class="fc" id="L180">                insertPos = 0;</span>
            else
<span class="fc" id="L182">                insertPos++;</span>

        }

<span class="fc" id="L186">        list.add(insertPos, incoming);</span>

<span class="fc" id="L188">        return removed;</span>
    }

    @Override public boolean remove(Object o) {
<span class="fc" id="L192">        int l = locate(o);</span>
<span class="pc bpc" id="L193" title="2 of 4 branches missed.">        if (l!=-1) return remove(l)==o;</span>
<span class="nc" id="L194">        return true;</span>
    }

    @Override public int locate(Object o) {

<span class="fc" id="L199">        int s = size();</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (s == 0) return -1;</span>


        //estimated position according to current priority,
        //which if it hasnt changed much has a chance of being
        //close to the index
<span class="fc" id="L206">        int p = pos((E)o);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (p &gt;= s) p = s-1;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (p &lt; 0)  p = 0;</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (attemptEqual(o, p))</span>
<span class="fc" id="L211">            return p;</span>

<span class="fc" id="L213">        int r = 0;</span>
<span class="fc" id="L214">        int maxDist = Math.max(s - p, p);</span>

<span class="fc" id="L216">        boolean phase = false;</span>

        //scan in an expanding radius around the point
        do {

<span class="fc bfc" id="L221" title="All 2 branches covered.">            phase = !phase;</span>

<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (phase)</span>
<span class="fc" id="L224">                r++;</span>

            int u;
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (phase) {</span>
<span class="fc" id="L228">                u = p + r;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                if (u &gt;= s) continue;</span>
            }
            else {
<span class="fc" id="L232">                u = p - r;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">                if (u &lt; 0) continue;</span>
            }

<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (attemptEqual(o, u))</span>
<span class="fc" id="L237">                return u;</span>

<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        } while ( r &lt;= maxDist );</span>

<span class="nc" id="L241">        return -1;</span>
    }

    private boolean attemptEqual(Object o, /*final Object oName, */ int i) {
<span class="fc" id="L245">        List&lt;E&gt; l = list;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        return o == l.get(i);</span>
    }


    @Override
    public final int capacity() {
<span class="fc" id="L252">        return capacity;</span>
    }

    public final int available() {
<span class="nc" id="L256">        return capacity - size();</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L261">        return list.toString();</span>
    }

    @NotNull
    @Override
    public final Iterator&lt;E&gt; descendingIterator() {
        //return new ReverseListIterator(list);
<span class="nc" id="L268">        throw new RuntimeException(&quot;unimpl yet&quot;);</span>
    }

    @Override public final E remove(int i) {
<span class="fc" id="L272">        return list.remove(i);</span>
    }

    @Override
    public final int size() {
<span class="fc" id="L277">        return list.size();</span>
    }

    @Override public final boolean isEmpty() {
<span class="nc" id="L281">        return list.isEmpty();</span>
    }

    /** this is a potentially very slow O(N) iteration,
      * shouldnt be any reason to use this */
    @Override public final boolean contains(Object o) {
<span class="nc" id="L287">        return list.contains(o);</span>
    }

    /** if possible, use the forEach visitor which wont
     * incur the cost of allocating an iterator */
    @Override public final Iterator&lt;E&gt; iterator() {
<span class="fc" id="L293">        return list.iterator();</span>
    }

    @Override public final void clear() {
<span class="fc" id="L297">        list.clear();</span>
<span class="fc" id="L298">    }</span>

    @NotNull
    @Override public Object[] toArray() {
<span class="nc" id="L302">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    @NotNull
    @Override
    public &lt;T&gt; T[] toArray(T[] a) {
<span class="nc" id="L308">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }


    @Override
    public boolean containsAll(Collection&lt;?&gt; c) {
<span class="nc" id="L314">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
<span class="nc" id="L319">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    @Override
    public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L324">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc" id="L329">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>