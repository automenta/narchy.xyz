<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TestNAR.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.util.meter</a> &gt; <span class="el_source">TestNAR.java</span></div><h1>TestNAR.java</h1><pre class="source lang-java linenums">package nars.util.meter;

import nars.Global;
import nars.NAR;
import nars.nal.Tense;
import nars.task.Task;
import nars.task.Tasked;
import nars.term.atom.Atom;
import nars.util.event.CycleReaction;
import nars.util.event.DefaultTopic;
import nars.util.event.Topic;
import nars.util.meter.condition.EternalTaskCondition;
import nars.util.meter.condition.ExecutionCondition;
import nars.util.meter.condition.NARCondition;
import nars.util.meter.condition.TemporalTaskCondition;
import nars.util.meter.event.HitMeter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.PrintStream;
import java.io.Serializable;
import java.io.StringWriter;
import java.util.*;


/**
* TODO use a countdown latch to provide early termination for successful tests
*/
<span class="pc bpc" id="L31" title="1 of 2 branches missed.">public class TestNAR  {</span>

    @NotNull
    public final Map&lt;Object, HitMeter&gt; eventMeters;
    @NotNull
    public final NAR nar;
<span class="fc" id="L37">    boolean showFail = true;</span>
<span class="fc" id="L38">    boolean showSuccess = false;</span>
<span class="fc" id="L39">    boolean showExplanations = false;</span>
<span class="fc" id="L40">    final boolean showOutput = false;</span>


<span class="fc" id="L43">    static final Logger logger = LoggerFactory.getLogger(TestNAR.class);</span>

    /** &quot;must&quot; requirement conditions specification */
<span class="fc" id="L46">    public final Collection&lt;NARCondition&gt; requires = new ArrayList();</span>
    //public final List&lt;ExplainableTask&gt; explanations = new ArrayList();
    @Nullable
    private Exception error;
    private static final transient boolean exitOnAllSuccess = true;
<span class="fc" id="L51">    @NotNull</span>
    public List&lt;Task&gt; inputs = new ArrayList();
    private static final int temporalTolerance = 0;
    protected static final float truthTolerance = Global.TESTS_TRUTH_ERROR_TOLERANCE;
    private StringWriter trace;

    /** enable this to print reports even if the test was successful.
     * it can cause a lot of output that can be noisy and slow down
     * the test running.
     * TODO separate way to generate a test report containing
     * both successful and unsuccessful tests
     *
     */
    static final boolean collectTrace = false;

<span class="fc" id="L66">    boolean finished = false;</span>
    @NotNull
    final Topic&lt;Task&gt; answerReceiver;

<span class="fc" id="L70">    public TestNAR(@NotNull NAR nar) {</span>

<span class="fc" id="L72">        answerReceiver = new DefaultTopic();</span>

<span class="fc" id="L74">        this.outputEvents = new Topic[] {</span>
            //nar.memory.eventDerived,
            //nar.memory.eventInput,
            nar.memory.eventTaskProcess,
            //nar.memory.eventTaskRemoved,
            nar.memory.eventRevision,
            answerReceiver
        };

<span class="fc" id="L83">        this.nar = nar;</span>

        //adapt 'answer' events (Twin&lt;Task&gt;) answer task component to the answerReceiver topic
<span class="fc" id="L86">        nar.memory.eventAnswer.on(tt -&gt; {</span>
<span class="fc" id="L87">            Task t = tt.getTwo();</span>
<span class="fc" id="L88">            t.log(&quot;Answers &quot; + tt.getOne());</span>
<span class="fc" id="L89">            answerReceiver.emit(t);</span>
<span class="fc" id="L90">        });</span>

        if (exitOnAllSuccess) {
<span class="fc" id="L93">            new EarlyExit(3);</span>
        }

<span class="fc" id="L96">        eventMeters = new EventCount(nar).eventMeters;</span>

<span class="fc" id="L98">    }</span>

//    /** returns the &quot;cost&quot;, which can be considered the inverse of a &quot;score&quot;.
//     * it is proportional to the effort (ex: # of cycles) expended by
//     * this reasoner in attempts to satisfy success conditions.
//     * If the conditions are not successful, the result will be INFINITE,
//     * though this can be normalized to a finite value in comparing multiple tests
//     * by replacing the INFINITE result with a maximum # of cycles limit,
//     * which will be smaller in cases where the success conditions are
//     * completed prior to the limit.
//     * */
//    public double getCost() {
//        return EternalTaskCondition.cost(requires);
//    }



    @NotNull
    public TestNAR debug() {
<span class="fc" id="L117">        Global.DEBUG = true;</span>
        //nar.stdout();
<span class="fc" id="L119">        return this;</span>
    }

//    /** asserts that (a snapshot of) the termlink graph is fully connected */
//    public TestNAR assertTermLinkGraphConnectivity() {
//        TermLinkGraph g = new TermLinkGraph(nar);
//        assert(&quot;termlinks form a fully connected graph:\n&quot; + g.toString(), g.isConnected());
//        return this;
//    }

    /** returns a new TestNAR continuing with the current nar */
    @NotNull
    public TestNAR next() {
<span class="nc" id="L132">        finished = false;</span>
<span class="nc" id="L133">        return new TestNAR(nar);</span>
    }

    @NotNull
    public TestNAR input(String s) {
<span class="fc" id="L138">        finished = false;</span>
<span class="fc" id="L139">        nar.input(s);</span>
<span class="fc" id="L140">        return this;</span>
    }

    @NotNull
    public TestNAR inputAt(long time, String s) {
<span class="fc" id="L145">        finished = false;</span>
<span class="fc" id="L146">        nar.inputAt(time, s);</span>
<span class="fc" id="L147">        return this;</span>
    }

    public void believe(String t, @NotNull Tense tense, float f, float c) {
<span class="nc" id="L151">        finished = false;</span>
<span class="nc" id="L152">        nar.believe(t, tense, f, c);</span>
<span class="nc" id="L153">    }</span>




    final class EarlyExit extends CycleReaction {

        final int checkResolution; //every # cycles to check for completion
<span class="fc" id="L161">        int cycle = 0;</span>

<span class="fc" id="L163">        public EarlyExit(int checkResolution) {</span>
<span class="fc" id="L164">            super(nar);</span>
<span class="fc" id="L165">            this.checkResolution = checkResolution;</span>
<span class="fc" id="L166">        }</span>

        @Override
        public void onCycle() {
<span class="fc" id="L170">            cycle++;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            if (cycle % checkResolution == 0) {</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">                if (requires.isEmpty())</span>
<span class="fc" id="L174">                    return;</span>

<span class="fc" id="L176">                boolean finished = true;</span>

<span class="fc" id="L178">                int nr = requires.size();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                for (NARCondition require : requires) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                    if (!require.isTrue()) {</span>
<span class="fc" id="L181">                        finished = false;</span>
<span class="fc" id="L182">                        break;</span>
                    }
<span class="fc" id="L184">                }</span>

<span class="fc bfc" id="L186" title="All 2 branches covered.">                if (finished) {</span>
<span class="fc" id="L187">                    stop();</span>

                }

            }
<span class="fc" id="L192">        }</span>
    }


    public void stop() {
<span class="fc" id="L197">        finished = true;</span>
<span class="fc" id="L198">    }</span>

    //TODO initialize this once in constructor
    @NotNull
    final Topic&lt;Tasked&gt;[] outputEvents;

    @NotNull
    public TestNAR mustOutput(long cycleStart, long cycleEnd, String sentenceTerm, char punc, float freqMin, float freqMax, float confMin, float confMax, long occTimeAbsolute)  {
<span class="fc" id="L206">        mustEmit(outputEvents, cycleStart, cycleEnd, sentenceTerm, punc, freqMin, freqMax, confMin, confMax, occTimeAbsolute);</span>
<span class="fc" id="L207">        return this;</span>
    }


    @NotNull
    public TestNAR mustOutput(long withinCycles, String task)  {
<span class="fc" id="L213">        return mustEmit(outputEvents, withinCycles, task);</span>
    }

//    public TestNAR onAnswer(String solution, AtomicBoolean solved /* for detecting outside of this */) throws InvalidInputException {
//
//        solved.set(false);
//
//        final Task expectedSolution = nar.task(solution);
//
//        nar.memory.eventAnswer.on(qa -&gt; {
//             if (!solved.get() &amp;&amp; qa.getTwo().equals(expectedSolution)) {
//                 solved.set(true);
//             }
//        });
//
//        return this;
//
//    }

//    public TestNAR mustOutput(Topic&lt;Tasked&gt; c, long cycleStart, long cycleEnd, String sentenceTerm, char punc, float freqMin, float freqMax, float confMin, float confMax, int ocRelative) throws InvalidInputException {
//        return mustEmit(c, cycleStart, cycleEnd, sentenceTerm, punc, freqMin, freqMax, confMin, confMax, ocRelative );
//    }

    @NotNull
    public TestNAR mustEmit(@NotNull Topic&lt;Tasked&gt;[] c, long cycleStart, long cycleEnd, String sentenceTerm, char punc, float freqMin, float freqMax, float confMin, float confMax)  {
<span class="fc" id="L238">        return mustEmit(c, cycleStart, cycleEnd, sentenceTerm, punc, freqMin, freqMax, confMin, confMax, Tense.ETERNAL );</span>
    }

    @NotNull
    public TestNAR mustEmit(@NotNull Topic&lt;Tasked&gt;[] c, long cycleStart, long cycleEnd, String sentenceTerm, char punc, float freqMin, float freqMax, float confMin, float confMax, @NotNull Tense t)  {
<span class="nc" id="L243">        return mustEmit(c, cycleStart, cycleEnd, sentenceTerm, punc, freqMin, freqMax, confMin, confMax, nar.time(t));</span>
    }

    @NotNull
    public TestNAR mustEmit(@NotNull Topic&lt;Tasked&gt;[] c, long cycleStart, long cycleEnd, String sentenceTerm, char punc, float freqMin, float freqMax, float confMin, float confMax, long occTimeAbsolute)  {

<span class="fc bfc" id="L249" title="All 2 branches covered.">        float h = (freqMin!=-1) ? truthTolerance / 2.0f : 0;</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (freqMin == -1) freqMin = freqMax;</span>

<span class="fc" id="L253">        int tt = getTemporalTolerance();</span>

<span class="fc" id="L255">        cycleStart -= tt;</span>
<span class="fc" id="L256">        cycleEnd += tt;</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">        EternalTaskCondition tc = occTimeAbsolute == Tense.ETERNAL ?</span>
<span class="fc" id="L259">                new EternalTaskCondition(nar,</span>
                        cycleStart, cycleEnd,
                        sentenceTerm, punc, freqMin - h, freqMax + h, confMin - h, confMax + h) :
<span class="fc" id="L262">                new TemporalTaskCondition(nar,</span>
                        cycleStart, cycleEnd,
                        occTimeAbsolute, occTimeAbsolute,
                        sentenceTerm, punc, freqMin - h, freqMax + h, confMin - h, confMax + h);

<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (Topic&lt;Tasked&gt; cc : c) {</span>
<span class="fc" id="L268">            cc.on(tc);</span>
        }

<span class="fc" id="L271">        finished = false;</span>
<span class="fc" id="L272">        requires.add(tc);</span>

<span class="fc" id="L274">        return this;</span>
//
//        ExplainableTask et = new ExplainableTask(tc);
//        if (showExplanations) {
//            explanations.add(et);
//        }
//        return et;
    }

    /** padding to add to specified time limitations to allow correct answers;
     *  default=0 having no effect  */
    public static int getTemporalTolerance() {
<span class="fc" id="L286">        return temporalTolerance;</span>
    }

//    public void setTemporalTolerance(int temporalTolerance) {
//        this.temporalTolerance = temporalTolerance;
//    }

    @Nullable
    public Exception getError() {
<span class="fc" id="L295">        return error;</span>
    }

//    public TestNAR mustInput(long withinCycles, String task) {
//        return mustEmit(
//                new Topic[] { nar.memory.eventInput },
//                withinCycles, task);
//    }


<span class="fc" id="L305">    public final long time() { return nar.time(); }</span>

    @NotNull
    public TestNAR mustEmit(@NotNull Topic&lt;Tasked&gt;[] c, long withinCycles, String task)  {
<span class="fc" id="L309">        Task t = nar.task(task);</span>
        //TODO avoid reparsing term from string

<span class="fc" id="L312">        long now = time();</span>
<span class="fc" id="L313">        String termString = t.term().toString();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (t.getTruth()!=null) {</span>
<span class="fc" id="L315">            float freq = t.getFrequency();</span>
<span class="fc" id="L316">            float conf = t.getConfidence();</span>
<span class="fc" id="L317">            long occurrence = t.getOccurrenceTime();</span>
<span class="fc" id="L318">            return mustEmit(c, now, now + withinCycles, termString, t.getPunctuation(), freq, freq, conf, conf, occurrence);</span>
        }
        else {
<span class="fc" id="L321">            return mustEmit(c, now, now + withinCycles, termString, t.getPunctuation(), -1, -1, -1, -1);</span>
        }
    }

    @NotNull
    public TestNAR mustOutput(long withinCycles, String term, char punc, float freq, float conf)  {
<span class="fc" id="L327">        long now = time();</span>
<span class="fc" id="L328">        return mustOutput(now, now + withinCycles, term, punc, freq, freq, conf, conf, nar.time(Tense.Eternal));</span>
    }

    @NotNull
    public TestNAR mustBelieve(long withinCycles, String term, float freqMin, float freqMax, float confMin, float confMax)  {
<span class="fc" id="L333">        return mustBelieve(withinCycles, term, freqMin, freqMax, confMin, confMax, Tense.ETERNAL);</span>
    }
    @NotNull
    public TestNAR mustBelieve(long withinCycles, String term, float freqMin, float freqMax, float confMin, float confMax, long tense)  {
<span class="fc" id="L337">        long now = time();</span>
<span class="fc" id="L338">        return mustOutput(now, now + withinCycles, term, '.', freqMin, freqMax, confMin, confMax, tense);</span>
    }
//    public TestNAR mustBelievePast(long withinCycles, String term, float freqMin, float freqMax, float confMin, float confMax, int maxPastWindow) throws InvalidInputException {
//        long now = time();
//        return mustOutput(now, now + withinCycles, term, '.', freqMin, freqMax, confMin, confMax);
//    }
//    public ExplainableTask mustBelieve(long cycleStart, long cycleStop, String term, float freq, float confidence) throws InvalidInputException {
//        long now = time();
//        return mustOutput(now + cycleStart, now + cycleStop, term, '.', freq, freq, confidence, confidence);
//    }
    @NotNull
    public TestNAR mustBelieve(long withinCycles, String term, float freq, float confidence, @NotNull Tense t)  {
<span class="fc" id="L350">        long ttt = nar.time();</span>
<span class="fc" id="L351">        return mustOutput(ttt, ttt + withinCycles, term, '.', freq, freq, confidence, confidence, nar.time(t));</span>
    }
    @NotNull
    public TestNAR mustAnswer(long withinCycles, String term, float freq, float confidence, @NotNull Tense t)  {
<span class="fc" id="L355">        long ttt = nar.time();</span>
<span class="fc" id="L356">        return mustEmit(new Topic[] { answerReceiver },</span>
<span class="fc" id="L357">                ttt, ttt + withinCycles, term, '.', freq, freq, confidence, confidence, nar.time(t));</span>
    }
    @NotNull
    public TestNAR mustBelieve(long withinCycles, String term, float freq, float confidence, long occTimeAbsolute)  {
<span class="fc" id="L361">        long t = nar.time();</span>
<span class="fc" id="L362">        return mustOutput(t, t + withinCycles, term, '.', freq, freq, confidence, confidence,occTimeAbsolute);</span>
    }

    @NotNull
    public TestNAR mustBelieve(long withinCycles, String term, float freq, float confidence)  {
<span class="fc" id="L367">        return mustBelieve(withinCycles, term, freq, confidence, Tense.Eternal);</span>
    }
    @NotNull
    public TestNAR mustBelieve(long withinCycles, String term, float confidence)  {
<span class="fc" id="L371">        return mustBelieve(withinCycles, term, 1.0f, confidence);</span>
    }

    @NotNull
    public TestNAR mustDesire(long withinCycles, String goalTerm, float freq, float conf) {
<span class="fc" id="L376">        return mustOutput(withinCycles, goalTerm, '!', freq, conf);</span>
    }

    @NotNull
    public TestNAR mustDesire(long withinCycles, String goalTerm, float freq, float conf, long occ) {
<span class="nc" id="L381">        long t = nar.time();</span>
<span class="nc" id="L382">        return mustOutput(t, t + withinCycles, goalTerm, '!', freq, freq, conf, conf, occ);</span>
    }


    @NotNull
    public TestNAR mustExecute(long start, long end, String term) {
<span class="fc" id="L388">        return mustExecute(start, end, term, 0, 1.0f);</span>
    }

    @NotNull
    public TestNAR mustExecute(long start, long end, String term, float minExpect, float maxExpect) {
<span class="fc" id="L393">        requires.add(new ExecutionCondition(nar, start, end, Atom.the(term), minExpect, maxExpect));</span>
<span class="fc" id="L394">        return this;</span>
    }

    @NotNull
    public TestNAR ask(String termString)  {
        //Override believe to input beliefs that have occurrenceTime set on input
        // &quot;lazy timing&quot; appropriate for test cases that can have delays
<span class="fc" id="L401">        Task t = nar.ask(termString);</span>

        //explainable(t);
<span class="fc" id="L404">        return this;</span>
    }
    public void askAt(int i, String term) {
<span class="nc" id="L407">        nar.inputAt(i, term + &quot;?&quot;);</span>
<span class="nc" id="L408">    }</span>


    @NotNull
    public TestNAR believe(@NotNull String... termString)  {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        for (String s : termString)</span>
<span class="fc" id="L414">            nar.believe(s);</span>
<span class="fc" id="L415">        return this;</span>
    }




    @NotNull
    public TestNAR believe(String termString, float freq, float conf)  {

<span class="fc" id="L424">        nar.believe(termString, freq, conf);</span>
<span class="fc" id="L425">        return this;</span>
    }



    public static class Report implements Serializable {

        public final long time;
        @NotNull
        public final HitMeter[] eventMeters;
<span class="fc" id="L435">        @Nullable</span>
        protected Serializable error = null;
        protected Task[] inputs;
<span class="fc" id="L438">        @NotNull</span>
<span class="fc" id="L439">        protected List&lt;NARCondition&gt; cond = Global.newArrayList(1);</span>
<span class="fc" id="L440">        final transient int stackElements = 4;</span>

<span class="fc" id="L442">        public Report(@NotNull TestNAR n) {</span>
<span class="fc" id="L443">            time = n.time();</span>

<span class="fc" id="L445">            inputs = n.inputs.toArray(new Task[n.inputs.size()]);</span>
<span class="fc" id="L446">            Collection&lt;HitMeter&gt; var = n.eventMeters.values();</span>
<span class="fc" id="L447">            eventMeters = var.toArray(new HitMeter[var.size()]);</span>
<span class="fc" id="L448">        }</span>

        public void setError(@Nullable Exception e) {
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">            if (e!=null) {</span>
<span class="nc" id="L452">                error = new Object[]{e.toString(), Arrays.copyOf(e.getStackTrace(), stackElements)};</span>
            }
<span class="fc" id="L454">        }</span>

        public void add(NARCondition o) {
<span class="fc" id="L457">            cond.add(o);</span>
<span class="fc" id="L458">        }</span>

        public boolean isSuccess() {
<span class="fc bfc" id="L461" title="All 2 branches covered.">            for (NARCondition t : cond)</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">                if (!t.isTrue())</span>
<span class="fc" id="L463">                    return false;</span>
<span class="fc" id="L464">            return true;</span>
        }

        public void toString(@NotNull PrintStream out) {

<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (error!=null) {</span>
<span class="nc" id="L470">                out.print(error);</span>
            }

<span class="nc" id="L473">            out.print(&quot;@&quot; + time + ' ');</span>
<span class="nc" id="L474">            out.print(Arrays.toString(eventMeters) + '\n');</span>

<span class="nc bnc" id="L476" title="All 2 branches missed.">            for (Task t : inputs) {</span>
<span class="nc" id="L477">                out.println(&quot;IN &quot; + t);</span>
            }

<span class="nc" id="L480">            cond.forEach(c -&gt;</span>
<span class="nc" id="L481">                c.toString(out)</span>
            );
<span class="nc" id="L483">        }</span>

        public void toLogger() {

<span class="pc bpc" id="L487" title="1 of 2 branches missed.">            if (error!=null) {</span>
<span class="nc" id="L488">                logger.error(error.toString());</span>
            }

<span class="fc" id="L491">            logger.info(&quot;@&quot; + time + ' ');</span>
<span class="fc" id="L492">            logger.debug(Arrays.toString(eventMeters) + '\n');</span>

<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            for (Task t : inputs) {</span>
<span class="nc" id="L495">                logger.info(&quot;IN &quot; + t);</span>
            }

<span class="fc" id="L498">            cond.forEach(c -&gt;</span>
<span class="fc" id="L499">                c.toLogger(logger)</span>
            );
<span class="fc" id="L501">        }</span>

    }

    @NotNull
    public TestNAR test() {
<span class="fc" id="L507">        return run(true);</span>
    }

    @NotNull
    public TestNAR run(boolean testAndPrintReport /* for use with JUnit */) {
<span class="fc" id="L512">        long finalCycle = 0;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        for (NARCondition oc : requires) {</span>
<span class="fc" id="L514">            long oce = oc.getFinalCycle();</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            if (oce &gt; finalCycle)</span>
<span class="fc" id="L516">                finalCycle = oce + 1;</span>
<span class="fc" id="L517">        }</span>

        if (collectTrace)
            nar.trace(trace = new StringWriter());

<span class="fc" id="L522">        runUntil(finalCycle);</span>


<span class="pc bpc" id="L525" title="1 of 2 branches missed.">        if (testAndPrintReport) {</span>

<span class="fc bfc" id="L527" title="All 2 branches covered.">            if (requires.isEmpty())</span>
<span class="fc" id="L528">                return this;</span>

            //assertTrue(&quot;No conditions tested&quot;, !requires.isEmpty());

            //assertTrue(&quot;No cycles elapsed&quot;, tester.nar.memory().time/*SinceLastCycle*/() &gt; 0);

<span class="fc" id="L534">            Report r = getReport();</span>

<span class="pc bpc" id="L536" title="1 of 2 branches missed.">            if (!r.isSuccess())</span>
<span class="nc" id="L537">                report(r, r.isSuccess());</span>

        }


<span class="fc" id="L542">        return this;</span>
    }

    @NotNull
    public Report getReport() {
<span class="fc" id="L547">        Report report = new Report(this);</span>

<span class="fc" id="L549">        report.setError(getError());</span>

<span class="fc" id="L551">        requires.forEach(report::add);</span>


<span class="fc" id="L554">        return report;</span>
    }

    protected void report(@NotNull Report report, boolean success) {

        //String s = //JSONOutput.stringFromFieldsPretty(report);
            //report.toString();

        //explain all validated conditions
//        if (requires!=null) {
//            requires.forEach(NARCondition::report);
//        }


<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if (success) {</span>
<span class="nc" id="L569">            report.toLogger();</span>
        }
        else  {

<span class="fc" id="L573">            report.toLogger();</span>
            if (collectTrace)
                logger.debug(trace.getBuffer().toString());

<span class="pc bpc" id="L577" title="1 of 2 branches missed.">            assert(false);</span>
        }

<span class="nc" id="L580">    }</span>

    @NotNull
    public TestNAR run(long extraCycles) {
<span class="fc" id="L584">        return runUntil(time() + extraCycles);</span>
    }

    @NotNull
    public TestNAR runUntil(long finalCycle) {

<span class="fc" id="L590">        error = null;</span>

        if (showOutput)
            nar.trace();


        //try {
<span class="fc" id="L597">        int frames = (int) (finalCycle - time());</span>
<span class="fc bfc" id="L598" title="All 4 branches covered.">        while (frames-- &gt; 0 &amp;&amp; !finished)</span>
<span class="fc" id="L599">            nar.frame();</span>

        /*}
        catch (Exception e) {
            error = e;
        }*/

<span class="fc" id="L606">        return this;</span>
    }


//    /** returns null if there is no error, or a non-null String containing report if error */
//    @Deprecated public String evaluate() {
//        //TODO use report(..)
//
//        int conditions = requires.size();
//        int failures = getError()!=null ? 1 : 0;
//
//        for (TaskCondition tc : requires) {
//            if (!tc.isTrue()) {
//                failures++;
//            }
//        }
//
//        int successes = conditions - failures;
//
//
//        if (error!=null || failures &gt; 0) {
//            String result = &quot;&quot;;
//
//            if (error!=null) {
//                result += error.toString() + &quot; &quot;;
//            }
//
//            if (failures &gt; 0) {
//                result += successes + &quot;/ &quot; + conditions + &quot; conditions passed&quot;;
//            }
//
//            return result;
//        }
//
//        return null;
//
//    }

//    public void report(PrintStream out, boolean showFail, boolean showSuccess, boolean showExplanations) {
//
//        boolean output = false;
//
//        if (showFail || showSuccess) {
//
//            for (TaskCondition tc : requires) {
//
//                if (!tc.isTrue()) {
//                    if (showFail) {
//                        out.println(tc.getFalseReason());
//                        output = true;
//                    }
//                } else {
//                    if (showSuccess) {
//                        out.println(tc.getTrueReasons());
//                        output = true;
//                    }
//                }
//            }
//
//        }
//
//        if (error!=null) {
//            error.printStackTrace();
//            output = true;
//        }
//
//        if (showExplanations) {
//            for (ExplainableTask x : explanations ) {
//                x.printMeaning(out);
//                output = true;
//            }
//        }
//
//        if (output)
//            out.println();
//    }
//
//
//    public void inputTest(String script) {
//
//        if (script == null)
//            throw new RuntimeException(&quot;null input&quot;);
//
//        nar.input( new TestInput(script) );
//
//    }

//    class TestInput extends TextInput {
//        public TestInput(String script) {
//            super(nar, script);
//        }
//
//        @Override
//        public void accept(Task task) {
//            super.accept(task);
//            inputs.add(task);
//        }
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>