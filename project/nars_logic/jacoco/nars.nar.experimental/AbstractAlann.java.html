<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractAlann.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.nar.experimental</a> &gt; <span class="el_source">AbstractAlann.java</span></div><h1>AbstractAlann.java</h1><pre class="source lang-java linenums">package nars.nar.experimental;

import nars.Memory;
import nars.nar.AbstractNAR;
import nars.op.app.Commander;
import nars.util.data.random.XorShift128PlusRandom;
import org.jetbrains.annotations.NotNull;

import java.util.Random;

/**
 * Base class for ALANN impls
 */
public abstract class AbstractAlann extends AbstractNAR {

<span class="nc" id="L16">	final Random rng = new XorShift128PlusRandom(1);</span>
	@NotNull
	final Commander commander;

	protected AbstractAlann(@NotNull Memory m, int commanderCapacity) {
<span class="nc" id="L21">		super(m);</span>

<span class="nc" id="L23">		commander = new Commander(this, commanderCapacity);</span>
<span class="nc" id="L24">	}</span>

	protected abstract void processConcepts();

	// final ItemAccumulator&lt;Task&gt; newTasks = new
	// ItemAccumulator&lt;&gt;(Budget.plus);

	// public float tlinkToConceptExchangeRatio = 0.1f;

	// final static Deriver deriver;

	// final static Procedure2&lt;Budget,Budget&gt; budgetMerge = Budget.plus;

	// @Deprecated
	// public final Default param = new NewDefault() {
	//
	// @Override
	// protected DerivationFilter[] getDerivationFilters() {
	// return new DerivationFilter[]{
	// new FilterBelowConfidence(0.01),
	// new FilterDuplicateExistingBelief(),
	// new LimitDerivationPriority()
	// //param.getDefaultDerivationFilters().add(new BeRational());
	// };
	// }
	//
	// }; // shadow defaults, will replace once refactored

	// protected final List&lt;Task&gt; sorted = Global.newArrayList();

	// protected void processNewTasks(int maxNewTaskHistory, int
	// maxNewTasksPerCycle) {
	// final int size = newTasks.size();
	// if (size!=0) {
	//
	// int toDiscard = Math.max(0, size - maxNewTaskHistory);
	// int remaining = newTasks.update(maxNewTaskHistory, sorted);
	//
	// if (size &gt; 0) {
	//
	// int toRun = Math.min( maxNewTasksPerCycle, remaining);
	//
	// TaskProcess.run(memory, sorted, toRun, toDiscard);
	//
	// //System.out.print(&quot;newTasks size=&quot; + size + &quot; run=&quot; + toRun + &quot;=(&quot; +
	// x.length + &quot;), discarded=&quot; + toDiscard + &quot;  &quot;);
	// }
	// }
	// }
	// protected void processNewTasks() {
	// final int size = newTasks.size();
	// if (size!=0) {
	// newTasks.forEach(t -&gt; process(t));
	// newTasks.clear();
	// }
	// }

	// @Override
	// public void cycle() {
	// processNewTasks();
	// processConcepts();
	// }

	// @Override final public boolean accept(final Task t) {
	// return newTasks.add(t);
	// }
	//
	// @Deprecated @Override public Concept nextConcept() {
	// throw new
	// RuntimeException(&quot;should not be called, this method will be deprecated&quot;);
	// }
	//

	// public Concept conceptualize(final Termed termed, final Budget budget,
	// final boolean createIfMissing) {
	// final Term term = termed.term();
	//
	// final float activationFactor;
	// // if ((termed instanceof TermLinkBuilder) ||
	// // (termed instanceof TaskLink) || (termed instanceof TermLinkTemplate))
	// {
	// //activationFactor = tlinkToConceptExchangeRatio;
	// // }
	// // else {
	// // //task seed
	// // activationFactor = 1f;
	// // }
	//
	// return null;
	//
	// // return
	// ((MapCacheBag&lt;Term,Concept,?&gt;)(memory.getConcepts())).data.compute(term,
	// (k, existing) -&gt; {
	// // if (existing!=null) {
	// // existing.getBudget().mergePlus(budget, activationFactor);
	// // return existing;
	// // }
	// // else {
	// // Concept c = newConcept(term, memory);
	// // c.getBudget().budget(budget).mulPriority(activationFactor);
	// // return c;
	// // }
	// // });
	// }

	// @Override
	// public boolean reprioritize(Term term, float newPriority) {
	// throw new RuntimeException(&quot;N/A&quot;);
	// }
	//
	// @Override
	// public Concept remove(Concept c) {
	// Itemized removed = memory().remove(c.getTerm());
	// if ((removed==null) || (removed!=c))
	// throw new RuntimeException(&quot;concept unknown&quot;);
	//
	// return c;
	// }

	// @Override
	// public Param getParam() {
	// param.the(Deriver.class, NewDefault.der);
	// param.setTermLinkBagSize(32);
	// return param;
	// }

	// @Override
	// public PremiseProcessor getPremiseProcessor(final Param p) {
	// return param.getPremiseProcessor(p);
	// }
	//
	// public Concept newConcept(Term t, Budget b, Bag&lt;Sentence, TaskLink&gt;
	// taskLinks, Bag&lt;TermLinkKey, TermLink&gt; termLinks) {
	//
	// final Concept c;
	// if (t instanceof Atom) {
	// c = new AtomConcept(t,
	// termLinks, taskLinks,
	// memory
	// );
	// }
	// else {
	// c = new DefaultConcept(t,
	// taskLinks, termLinks,
	// memory
	// );
	// }
	//
	//
	// return c;
	// }

	// public Concept newConcept(final Term t, final Memory m) {
	//
	// Bag&lt;Task, TaskLink&gt; taskLinks =
	// new CurveBag&lt;&gt;(rng, /*sentenceNodes,*/ getConceptTaskLinks());
	// taskLinks.mergePlus();
	//
	// Bag&lt;TermLinkKey, TermLink&gt; termLinks =
	// new CurveBag&lt;&gt;(rng, /*termlinkKeyNodes,*/ getConceptTermLinks());
	// termLinks.mergePlus();
	//
	// final Concept c;
	// if (t instanceof Atom) {
	// c = new AtomConcept(t, termLinks, taskLinks);
	// } else {
	// c = new DefaultConcept(t, taskLinks, termLinks, memory);
	// }
	//
	// return c;
	// }

	// private int getConceptTaskLinks() {
	// return -1;
	// }
	//
	// private int getConceptTermLinks() {
	// return -1;
	// }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>