<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Derivelet.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.nar.experimental</a> &gt; <span class="el_source">Derivelet.java</span></div><h1>Derivelet.java</h1><pre class="source lang-java linenums">package nars.nar.experimental;

import nars.Global;
import nars.NAR;
import nars.bag.BLink;
import nars.concept.Concept;
import nars.concept.ConceptProcess;
import nars.nal.meta.PremiseMatch;
import nars.task.Task;
import nars.term.Termed;
import nars.term.Terms;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * particle that travels through the graph,
 * responsible for deciding what to derive
 */
<span class="fc" id="L23">public class Derivelet {</span>


    /**
     * modulating the TTL (time-to-live) allows the system to control
     * the quality of attention it experiences.
     * a longer TTL will cause derivelets to restart
     * less frequently and continue exploring potentially &quot;yarny&quot;
     * paths of knowledge
     */
    int ttl;


    /**
     * current location
     */
    public BLink&lt;Concept&gt; concept;

    /**
     * utility context
     */
    public DeriveletContext context;

    PremiseMatch matcher;

    /**
     * temporary re-usable array for batch firing
     */
<span class="fc" id="L51">    private final Set&lt;BLink&lt;Termed&gt;&gt; terms = Global.newHashSet(1);</span>
    /**
     * temporary re-usable array for batch firing
     */
<span class="fc" id="L55">    private final Set&lt;BLink&lt;Task&gt;&gt; tasks = Global.newHashSet(1);</span>

<span class="fc" id="L57">    @NotNull</span>
    private BLink[] termsArray = new BLink[0];
<span class="fc" id="L59">    @NotNull</span>
    private BLink[] tasksArray = new BLink[0];

    public static int firePremises(BLink&lt;Concept&gt; conceptLink, @NotNull BLink&lt;Task&gt;[] tasks, @NotNull BLink&lt;Termed&gt;[] terms, @NotNull Consumer&lt;ConceptProcess&gt; proc, @NotNull NAR nar) {

<span class="fc" id="L64">        int total = 0;</span>

<span class="fc bfc" id="L66" title="All 2 branches covered.">        for (BLink&lt;Task&gt; taskLink : tasks) {</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">            if (taskLink == null) break;</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">            for (BLink&lt;Termed&gt; termLink : terms) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">                if (termLink == null) break;</span>

<span class="fc bfc" id="L72" title="All 2 branches covered.">                if (Terms.equalSubTermsInRespectToImageAndProduct(taskLink.get().term(), termLink.get().term()))</span>
<span class="fc" id="L73">                    continue;</span>

<span class="fc" id="L75">                total+= ConceptProcess.fireAll(</span>
                    nar, conceptLink, taskLink, termLink, proc);
            }
        }

<span class="fc" id="L80">        return total;</span>
    }


    /**
     * iteratively supplies a matrix of premises from the next N tasklinks and M termlinks
     * (recycles buffers, non-thread safe, one thread use this at a time)
     */
    public int firePremiseSquare(
            @NotNull NAR nar,
            @NotNull Consumer&lt;ConceptProcess&gt; proc,
            @NotNull BLink&lt;Concept&gt; conceptLink,
            int tasklinks, int termlinks,
            Predicate&lt;BLink&lt;Termed&gt;&gt; eachTermLink,
            Predicate&lt;BLink&lt;Task&gt;&gt; eachTaskLink) {

<span class="fc" id="L96">        Concept concept = conceptLink.get();</span>

<span class="fc" id="L98">        Set&lt;BLink&lt;Task&gt;&gt; tasksBuffer = this.tasks;</span>
<span class="fc" id="L99">        concept.getTaskLinks().sample(tasklinks, eachTaskLink, tasksBuffer).commit();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (tasksBuffer.isEmpty()) return 0;</span>

<span class="fc" id="L102">        Set&lt;BLink&lt;Termed&gt;&gt; termsBuffer = this.terms;</span>
<span class="fc" id="L103">        concept.getTermLinks().sample(termlinks, eachTermLink, termsBuffer).commit();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (termsBuffer.isEmpty()) return 0;</span>

        //convert to array for fast for-within-for iterations
<span class="fc" id="L107">        BLink[] tasksArray = this.tasksArray = tasksBuffer.toArray(this.tasksArray);</span>
<span class="fc" id="L108">        tasksBuffer.clear();</span>

<span class="fc" id="L110">        BLink[] termsArray = this.termsArray = termsBuffer.toArray(this.termsArray);</span>
<span class="fc" id="L111">        termsBuffer.clear();</span>

<span class="fc" id="L113">        return firePremises(conceptLink,</span>
                tasksArray, termsArray,
                proc, nar);

    }


    @NotNull
    private NAR nar() {
<span class="nc" id="L122">        return context.nar;</span>
    }

    /**
     * determines a next concept to move adjacent to
     * the concept it is currently at
     */
    @Nullable
    public Concept nextConcept() {

<span class="nc" id="L132">        final BLink&lt;Concept&gt; concept = this.concept;</span>

<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (concept == null) {</span>
<span class="nc" id="L135">            return null;</span>
        }

<span class="nc" id="L138">        final float x = context.nextFloat();</span>
<span class="nc" id="L139">        Concept c = concept.get();</span>

        //calculate probability it will stay at this concept
<span class="nc" id="L142">        final float stayProb = 0.5f;//(concept.getPriority()) * 0.5f;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (x &lt; stayProb) {</span>
            //stay here
<span class="nc" id="L145">            return c;</span>
        } else {
<span class="nc" id="L147">            float rem = 1.0f - stayProb;</span>


<span class="nc bnc" id="L150" title="All 2 branches missed.">            final BLink tl = ((x &gt; (stayProb + (rem / 2))) ?</span>
<span class="nc" id="L151">                    c.getTermLinks() :</span>
<span class="nc" id="L152">                    c.getTaskLinks())</span>
<span class="nc" id="L153">                    .sample();</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (tl != null) {</span>
<span class="nc" id="L156">                c = context.concept(((Termed) tl.get()));</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">                if (c != null) return c;</span>
            }
        }

<span class="nc" id="L161">        return null;</span>
    }

    /**
     * run next iteration; true if still alive by end, false if died and needs recycled
     */
    public final boolean cycle(final long now) {

<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (this.ttl-- == 0) {</span>
            //died
<span class="nc" id="L171">            return false;</span>
        }

        //TODO dont instantiate BagBudget
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if ((this.concept = new BLink(nextConcept(), 0, 0, 0)) == null) {</span>
            //dead-end
<span class="nc" id="L177">            return false;</span>
        }


<span class="nc" id="L181">        int tasklinks = 1;</span>
<span class="nc" id="L182">        int termlinks = 2;</span>

<span class="nc" id="L184">        int fired = firePremiseSquare(context.nar,</span>
                perPremise, this.concept,
                tasklinks, termlinks,
                null, //Default.simpleForgetDecay,
                null //Default.simpleForgetDecay
        );

<span class="nc bnc" id="L191" title="All 2 branches missed.">        return fired &gt; 0;</span>
    }

<span class="fc" id="L194">    @Nullable</span>
    final Consumer&lt;Task&gt; perDerivation = (derived) -&gt; {
<span class="nc" id="L196">        final NAR n = nar();</span>

<span class="nc" id="L198">        derived = n.validInput(derived);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (derived != null)</span>
<span class="nc" id="L200">            n.process(derived);</span>
<span class="nc" id="L201">    };</span>

<span class="fc" id="L203">    final Consumer&lt;ConceptProcess&gt; perPremise = p -&gt;</span>
<span class="nc" id="L204">            DeriveletContext.deriver.run(p, matcher, perDerivation);</span>


    public final void start(final Concept concept, int ttl, @NotNull final DeriveletContext context) {
<span class="nc" id="L208">        this.context = context;</span>
<span class="nc" id="L209">        this.concept = new BLink(concept, 0, 0, 0); //TODO</span>
<span class="nc" id="L210">        this.ttl = ttl;</span>
<span class="nc" id="L211">        this.matcher = new PremiseMatch(context.rng);</span>
<span class="nc" id="L212">    }</span>

    @NotNull
    @Override
    public String toString() {
<span class="nc" id="L217">        return getClass().getSimpleName() + '@' + concept;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>