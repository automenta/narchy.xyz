<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Anticipate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.op.mental</a> &gt; <span class="el_source">Anticipate.java</span></div><h1>Anticipate.java</h1><pre class="source lang-java linenums">/*
 * Believe.java
 *
 * Copyright (C) 2008  Pei Wang
 *
 * This file is part of Open-NARS.
 *
 * Open-NARS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Open-NARS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Open-NARS.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */


package nars.op.mental;

import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import nars.Global;
import nars.NAR;
import nars.Symbols;
import nars.budget.Budget;
import nars.task.MutableTask;
import nars.task.Task;
import nars.task.Temporal;
import nars.term.compound.Compound;
import org.jetbrains.annotations.NotNull;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 something expected did not happen
 anticipation will generate a negative event as consequence
 */
public final class Anticipate {

    public static final float TOLERANCE_DIV=5.0f;
<span class="nc" id="L48">    public float DEFAULT_CONFIRMATION_EXPECTATION = 0.51f;</span>


<span class="nc" id="L51">    final Multimap&lt;Compound,TaskTime&gt; anticipations = LinkedHashMultimap.create();</span>

    @NotNull
    private final NAR nar;

    private static final boolean debug = false;
    //private long nextUpdateTime = -1;

    /** called each cycle to update calculations of anticipations */
<span class="nc" id="L60">    int happeneds = 0, didnts = 0;</span>

//    public static boolean testing = false;
//    public static String teststring = &quot;&quot;;


<span class="nc" id="L66">    final List&lt;TaskTime&gt; toRemove = Global.newArrayList();</span>


<span class="nc" id="L69">    public Anticipate(@NotNull NAR nar) {</span>
<span class="nc" id="L70">        this.nar = nar;</span>

<span class="nc" id="L72">        nar.memory.eventCycleEnd.on(c -&gt; updateAnticipations());</span>
<span class="nc" id="L73">        nar.memory.eventInput.on(this::onInput);</span>
<span class="nc" id="L74">    }</span>

    public void onInput(@NotNull Task t) {
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (((Temporal)t).isAnticipated()) {</span>
<span class="nc" id="L78">            anticipate(t);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (t.isInput())</span>
<span class="nc" id="L80">                mayHaveHappenedAsExpected(t);</span>
        }
<span class="nc" id="L82">    }</span>

    public void anticipate(@NotNull Task t) {

<span class="nc bnc" id="L86" title="All 4 branches missed.">        if(t.getTruth().getExpectation() &lt; DEFAULT_CONFIRMATION_EXPECTATION || t.getPunctuation() != Symbols.JUDGMENT) {</span>
<span class="nc" id="L87">            return;</span>
        }

<span class="nc" id="L90">        Compound tt = t.term();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if(tt.op().isConjunctive()) { //not observable, TODO probably revise</span>
<span class="nc" id="L92">            return;</span>
        }

<span class="nc" id="L95">        long now = nar.time();</span>

<span class="nc bnc" id="L97" title="All 2 branches missed.">        if (now &gt; t.getOccurrenceTime()) //its about the past..</span>
<span class="nc" id="L98">            return;</span>

        if (debug)
            System.err.println(&quot;Anticipating &quot; + tt + &quot; in &quot; + (t.getOccurrenceTime() - now));

<span class="nc" id="L103">        TaskTime taskTime = new TaskTime(t, t.getCreationTime());</span>
//        if(testing) {
//            String s = &quot;anticipating: &quot;+taskTime.task.getTerm().toString();
//            System.out.println(s);
//            teststring += s + &quot;\n&quot;;
//        }
<span class="nc" id="L109">        anticipations.put(tt, taskTime);</span>

<span class="nc" id="L111">    }</span>

    protected void deriveDidntHappen(Compound prediction, @NotNull TaskTime tt) {

//        if(testing) {
//            String s = &quot;did not happen: &quot; + prediction.toString();
//            System.out.println(s);
//            teststring += s + &quot;\n&quot;;
//        }

<span class="nc" id="L121">        long expectedOccurrenceTime = tt.occurrTime;</span>

        //it did not happen, so the time of when it did not
        //happen is exactly the time it was expected

        if (debug)
            System.err.println(&quot;Anticipation Negated &quot; + tt.task);

<span class="nc" id="L129">        nar.input(new MutableTask(prediction)</span>
<span class="nc" id="L130">                .belief()</span>
<span class="nc" id="L131">                .truth(0.0f, nar.memory.getDefaultConfidence(Symbols.JUDGMENT))</span>
<span class="nc" id="L132">                .time(nar.time(), expectedOccurrenceTime)</span>
<span class="nc" id="L133">                .parent(tt.task, null)</span>
<span class="nc" id="L134">                .because(&quot;Absent Anticipated Event&quot;));</span>
<span class="nc" id="L135">    }</span>



    protected void mayHaveHappenedAsExpected(@NotNull Task c) {

<span class="nc bnc" id="L141" title="All 4 branches missed.">        if(!c.isInput() || c.isEternal()) {</span>
<span class="nc" id="L142">            return; //it's not a input task, the system is not allowed to convince itself about the state of affairs ^^</span>
        }

<span class="nc" id="L145">        toRemove.clear();</span>

<span class="nc" id="L147">        long cOccurr = c.getOccurrenceTime();</span>

<span class="nc bnc" id="L149" title="All 4 branches missed.">        anticipations.get(c.term()).stream().filter(tt -&gt; tt.inTime(cOccurr) &amp;&amp; !c.equals(tt.task) &amp;&amp;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                tt.task.getTruth().getExpectation() &gt; DEFAULT_CONFIRMATION_EXPECTATION).forEach(tt -&gt; {</span>
<span class="nc" id="L151">            toRemove.add(tt);</span>
<span class="nc" id="L152">            happeneds++;</span>
<span class="nc" id="L153">        });</span>

<span class="nc" id="L155">        toRemove.forEach(tt -&gt; anticipations.remove(c.term(),tt));</span>
<span class="nc" id="L156">    }</span>

    protected void updateAnticipations() {

<span class="nc" id="L160">        long now = nar.memory.time();</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (anticipations.isEmpty()) return;</span>

<span class="nc" id="L164">        Iterator&lt;Map.Entry&lt;Compound, TaskTime&gt;&gt; it = anticipations.entries().iterator();</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">        while (it.hasNext()) {</span>

<span class="nc" id="L168">            Map.Entry&lt;Compound, TaskTime&gt; t = it.next();</span>
<span class="nc" id="L169">            Compound term = t.getKey();</span>
<span class="nc" id="L170">            TaskTime tt = t.getValue();</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (tt.tooLate(now)) {</span>
<span class="nc" id="L173">                deriveDidntHappen(term, tt);</span>
<span class="nc" id="L174">                it.remove();</span>
<span class="nc" id="L175">                didnts++;</span>
            }
<span class="nc" id="L177">        }</span>

        if (debug)
            System.err.println(now + &quot;: Anticipations: pending=&quot; + anticipations.size() + &quot; happened=&quot; + happeneds + &quot; , didnts=&quot; + didnts);
<span class="nc" id="L181">    }</span>

    /** Prediction point vector / centroid of a group of Tasks
     *      time a prediction is made (creationTime), and
     *      tme it is expected (ocurrenceTime) */
    public static final class TaskTime {

        /** all data is from task */
        @NotNull
        public final Task task;

        /** cached locally, same value as in task */
        public final long occurrTime;
        public final long creationTime;

        /** cached locally, same value as in task */
        private final int hash;
<span class="nc" id="L198">        public float tolerance = 0;</span>

<span class="nc" id="L200">        public TaskTime(@NotNull Task task, long creationTime) {</span>
<span class="nc" id="L201">            this.task = task;</span>
<span class="nc" id="L202">            this.creationTime = task.getCreationTime();</span>
<span class="nc" id="L203">            occurrTime = task.getOccurrenceTime();</span>
<span class="nc" id="L204">            hash = (int)(31 * creationTime + occurrTime);</span>
            //expiredate in relation how long we predicted forward
<span class="nc" id="L206">            long prediction_time = occurrTime - this.creationTime;</span>
<span class="nc" id="L207">            tolerance = prediction_time/TOLERANCE_DIV;</span>
<span class="nc" id="L208">        }</span>

        public boolean tooLate(long occur) {
<span class="nc bnc" id="L211" title="All 2 branches missed.">            return occur &gt; occurrTime + TOLERANCE_DIV;</span>
        }

        public boolean inTime(long occur) {
<span class="nc bnc" id="L215" title="All 4 branches missed.">            return occur &gt; occurrTime - TOLERANCE_DIV &amp;&amp; occur &lt; occurrTime + TOLERANCE_DIV;</span>
        }

<span class="nc" id="L218">        public float getPriority() { return task.getPriority(); }</span>

        @Override
        public int hashCode() {
<span class="nc" id="L222">            return hash;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (obj == this) return true;</span>
<span class="nc" id="L228">            TaskTime t = (TaskTime)obj;</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">            return creationTime == t.creationTime  &amp;&amp;  occurrTime == t.occurrTime;</span>
        }

        public Budget getBudget() {
<span class="nc" id="L233">            return task.getBudget();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>