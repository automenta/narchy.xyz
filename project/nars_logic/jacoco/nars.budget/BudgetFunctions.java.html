<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BudgetFunctions.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.budget</a> &gt; <span class="el_source">BudgetFunctions.java</span></div><h1>BudgetFunctions.java</h1><pre class="source lang-java linenums">/*
 * BudgetFunctions.java
 *
 * Copyright (C) 2008  Pei Wang
 *
 * This file is part of Open-NARS.
 *
 * Open-NARS is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Open-NARS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Open-NARS.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package nars.budget;

import nars.NAR;
import nars.bag.BLink;
import nars.concept.ConceptProcess;
import nars.nal.UtilityFunctions;
import nars.task.Task;
import nars.term.Termed;
import nars.term.Termlike;
import nars.truth.Truth;
import org.jetbrains.annotations.NotNull;

/**
 * Budget functions for resources allocation
 */
<span class="nc" id="L36">public final class BudgetFunctions extends UtilityFunctions {</span>

	/* ----------------------- Belief evaluation ----------------------- */
	/**
	 * Determine the quality of a judgment by its truth value alone
	 * &lt;p&gt;
	 * Mainly decided by confidence, though binary judgment is also preferred
	 * 
	 * @param t
	 *            The truth value of a judgment
	 * @return The quality of the judgment, according to truth value only
	 */
	public static float truthToQuality(@NotNull Truth t) {
<span class="fc" id="L49">		float exp = t.getExpectation();</span>
<span class="fc" id="L50">		return Math.max(exp, (1.0f - exp) * 0.75f);</span>
	}

	/**
	 * Evaluate the quality of a revision, then de-prioritize the premises
	 * 
	 * @param tTruth
	 *            The truth value of the judgment in the task of the premise
	 * @param oldBelief
	 *            The truth value of the previously existing belief
	 * @param conclusion
	 *            The truth value of the conclusion of revision
	 * @return The budget for the new task
	 */
	@NotNull
	public static Budget revise(@NotNull Truth tTruth, @NotNull Task oldBelief, @NotNull Truth conclusion,
								@NotNull Budget tb) {

<span class="fc" id="L68">		Truth bTruth = oldBelief.getTruth();</span>
<span class="fc" id="L69">		float difT = conclusion.getExpDifAbs(tTruth);</span>

<span class="fc" id="L71">		tb.andPriority(1.0f - difT);</span>
<span class="fc" id="L72">		tb.andDurability(1.0f - difT);</span>

<span class="fc" id="L74">		oldBelief.onRevision(conclusion);</span>

<span class="fc" id="L76">		float dif = conclusion.getConfidence()</span>
<span class="fc" id="L77">				- Math.max(tTruth.getConfidence(), bTruth.getConfidence());</span>

<span class="pc bpc" id="L79" title="1 of 2 branches missed.">		if (dif &lt; 0) {</span>
			/*String msg = (&quot;Revision fault: previous belief &quot; + oldBelief
					+ &quot; more confident than revised: &quot; + conclusion);
			if (Global.DEBUG) {
				throw new RuntimeException(msg);
			} else {
				System.err.println(msg);
			}*/
		}

<span class="fc" id="L89">		float priority = or(dif, tb.getPriority());</span>
<span class="fc" id="L90">		float durability = aveAri(dif, tb.getDurability());</span>
<span class="fc" id="L91">		float quality = truthToQuality(conclusion);</span>

		/*
		 * if (priority &lt; 0) { memory.nar.output(ERR.class, new
		 * RuntimeException(
		 * &quot;BudgetValue.revise resulted in negative priority; set to 0&quot;));
		 * priority = 0; } if (durability &lt; 0) { memory.nar.output(ERR.class,
		 * new RuntimeException(
		 * &quot;BudgetValue.revise resulted in negative durability; set to 0; aveAri(dif=&quot;
		 * + dif + &quot;, task.getDurability=&quot; + task.getDurability() +&quot;) = &quot; +
		 * durability)); durability = 0; } if (quality &lt; 0) {
		 * memory.nar.output(ERR.class, new RuntimeException(
		 * &quot;BudgetValue.revise resulted in negative quality; set to 0&quot;));
		 * quality = 0; }
		 */

<span class="fc" id="L107">		return new UnitBudget(priority, durability, quality);</span>
	}

	// /**
	// * Update a belief
	// *
	// * @param task The task containing new belief
	// * @param bTruth Truth value of the previous belief
	// * @return Budget value of the updating task
	// */
	// static Budget update(final Task task, final Truth bTruth) {
	// final Truth tTruth = task.getTruth();
	// final float dif = tTruth.getExpDifAbs(bTruth);
	// final float priority = or(dif, task.getPriority());
	// final float durability = aveAri(dif, task.getDurability());
	// final float quality = truthToQuality(bTruth);
	// return new Budget(priority, durability, quality);
	// }

	// /* ----------------------- Links ----------------------- */
	// /**
	// * Distribute the budget of a task among the links to it
	// *
	// * @param b The original budget
	// * @param factor to scale dur and qua
	// * @return Budget value for each tlink
	// */
	// public static UnitBudget clonePriorityMultiplied(Budgeted b, float
	// factor) {
	// float newPriority = b.getPriority() * factor;
	// return new UnitBudget(newPriority, b.getDurability(), b.getQuality());
	// }

	// /**
	// */
	// public static void activate(final Budget receiver, final Budget amount,
	// Activating mode) {
	// activate(receiver, amount, mode, 1f);
	// }

	// /* ---------------- Bag functions, on all Items ------------------- */
	// /**
	// * Decrease Priority after an item is used, called in Bag.
	// * After a constant time, p should become d*p. Since in this period, the
	// * item is accessed c*p times, each time p-q should multiple d^(1/(c*p)).
	// * The intuitive meaning of the parameter &quot;forgetRate&quot; is: after this
	// number
	// * of times of access, priority 1 will become d, it is a system parameter
	// * adjustable in run time.
	// *
	// * @param budget The previous budget value
	// * @param forgetCycles The budget for the new item
	// * @param relativeThreshold The relative threshold of the bag
	// */
	// @Deprecated public static float forgetIterative(Budget budget, float
	// forgetCycles, float relativeThreshold) {
	// float newPri = budget.getQuality() * relativeThreshold; // re-scaled
	// quality
	// float dp = budget.getPriority() - newPri; // priority above quality
	// if (dp &gt; 0) {
	// newPri += (float) (dp * pow(budget.getDurability(), 1.0f / (forgetCycles
	// * dp)));
	// } // priority Durability
	// budget.setPriority(newPri);
	// return newPri;
	// }
	//
	//
	//
	// /** forgetting calculation for real-time timing */
	// public static float forgetPeriodic(Budget budget, float forgetPeriod /*
	// cycles */, float minPriorityForgettingCanAffect, long currentTime) {
	//
	// float currentPriority = budget.getPriority();
	// long forgetDelta = budget.setLastForgetTime(currentTime);
	// if (forgetDelta == 0) {
	// return currentPriority;
	// }
	//
	// minPriorityForgettingCanAffect *= budget.getQuality();
	//
	// if (currentPriority &lt; minPriorityForgettingCanAffect) {
	// //priority already below threshold, don't decrease any further
	// return currentPriority;
	// }
	//
	// float forgetProportion = forgetDelta / forgetPeriod;
	// if (forgetProportion &lt;= 0) return currentPriority;
	//
	// //more durability = slower forgetting; durability near 1.0 means
	// forgetting will happen slowly, near 0.0 means will happen at a max rate
	// forgetProportion *= (1.0f - budget.getDurability());
	//
	// float newPriority = forgetProportion &gt; 1.0f ?
	// minPriorityForgettingCanAffect : currentPriority * (1.0f -
	// forgetProportion) + minPriorityForgettingCanAffect * (forgetProportion);
	//
	//
	// budget.setPriority(newPriority);
	//
	// return newPriority;
	//
	//
	// /*if (forgetDelta &gt; 0)
	// System.out.println(&quot;  &quot; + currentPriority + &quot; -&gt; &quot; +
	// budget.getPriority());*/
	//
	// }

	/*
	 * public final static float abs(final float a, final float b) { float c =
	 * (a - b); return (c &gt;= 0) ? c : -c; }
	 */

	/* ----- Task derivation in LocalRules and SyllogisticRules ----- */
	/**
	 * Forward logic result and adjustment
	 * 
	 * @param truth
	 *            The truth value of the conclusion
	 * @return The budget value of the conclusion
	 */
	@NotNull
	public static Budget forward(@NotNull Truth truth, @NotNull ConceptProcess nal) {
<span class="nc" id="L231">		return budgetInference(truthToQuality(truth), 1, nal);</span>
	}

	/**
	 * Backward logic result and adjustment, stronger case
	 * 
	 * @param truth
	 *            The truth value of the belief deriving the conclusion
	 * @param nal
	 *            Reference to the memory
	 * @return The budget value of the conclusion
	 */
	@NotNull
	public static Budget backward(@NotNull Truth truth, @NotNull ConceptProcess nal) {
<span class="nc" id="L245">		return budgetInference(truthToQuality(truth), 1, nal);</span>
	}

	/**
	 * Backward logic result and adjustment, weaker case
	 * 
	 * @param truth
	 *            The truth value of the belief deriving the conclusion
	 * @param nal
	 *            Reference to the memory
	 * @return The budget value of the conclusion
	 */
	@NotNull
	public static Budget backwardWeak(@NotNull Truth truth, @NotNull ConceptProcess nal) {
<span class="nc" id="L259">		return budgetInference(w2c(1) * truthToQuality(truth), 1, nal);</span>
	}

	/* ----- Task derivation in CompositionalRules and StructuralRules ----- */

	@NotNull
	public static Budget compoundForward(@NotNull Budget target, @NotNull Truth truth,
										 @NotNull Termed content, @NotNull ConceptProcess nal) {
<span class="fc" id="L267">		int complexity = content.term().complexity();</span>
<span class="fc" id="L268">		return budgetInference(target, truthToQuality(truth), complexity, nal);</span>
	}

	/**
	 * Backward logic with CompoundTerm conclusion, stronger case
	 * 
	 * @param content
	 *            The content of the conclusion
	 * @return The budget of the conclusion
	 */
	@NotNull
	public static Budget compoundBackward(@NotNull Termed content, @NotNull ConceptProcess nal) {
<span class="fc" id="L280">		return budgetInference(1.0f, content.term().complexity(), nal);</span>
	}

	/**
	 * Backward logic with CompoundTerm conclusion, weaker case
	 * 
	 * @param content
	 *            The content of the conclusion
	 * @param nal
	 *            Reference to the memory
	 * @return The budget of the conclusion
	 */
	@NotNull
	public static Budget compoundBackwardWeak(@NotNull Termlike content,
											  @NotNull ConceptProcess nal) {
<span class="nc" id="L295">		return budgetInference(w2c(1), content.complexity(), nal);</span>
	}

	@NotNull
	static Budget budgetInference(float qual, int complexity, @NotNull ConceptProcess nal) {
<span class="fc" id="L300">		return budgetInference(new UnitBudget(), qual, complexity, nal);</span>
	}

	/**
	 * Common processing for all logic step
	 * 
	 * @param qual
	 *            Quality of the logic
	 * @param complexity
	 *            Syntactic complexity of the conclusion
	 * @param nal
	 *            Reference to the memory
	 * @return Budget of the conclusion task
	 */
	@NotNull
	static Budget budgetInference(@NotNull Budget target, float qual, int complexity,
								  @NotNull ConceptProcess nal) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">		float complexityFactor = complexity &gt; 1 ?</span>

		// sqrt factor (experimental)
		// (float) (1f / Math.sqrt(Math.max(1, complexity))) //experimental,
		// reduces dur and qua by sqrt of complexity (more slowly)

				// linear factor (original)
<span class="fc" id="L324">				(1.0f / Math.max(1, complexity))</span>

<span class="fc" id="L326">				: 1.0f;</span>

<span class="fc" id="L328">		return budgetInference(target, qual, complexityFactor, nal);</span>
	}

	@NotNull
	static Budget budgetInference(@NotNull Budget target, float qual, float complexityFactor, @NotNull ConceptProcess nal) {

<span class="fc" id="L334">        BLink&lt;Task&gt; taskLink = nal.taskLink;</span>

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        Budget t =</span>
<span class="pc" id="L337">            (taskLink !=null) ? taskLink :  nal.getTask().getBudget();</span>


<span class="fc" id="L340">        float priority = t.getPriority();</span>
<span class="fc" id="L341">        float durability = t.getDurability() * complexityFactor;</span>
<span class="fc" id="L342">        final float quality = qual * complexityFactor;</span>

<span class="fc" id="L344">        BLink&lt;Termed&gt; termLink = nal.termLink;</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (termLink!=null) {</span>
<span class="fc" id="L346">            priority = or(priority, termLink.getPriority());</span>
<span class="fc" id="L347">            durability = and(durability, termLink.getDurability()); //originaly was 'AND'</span>

<span class="fc" id="L349">            NAR nar = nal.nar;</span>
<span class="fc" id="L350">            final float targetActivation = nar.conceptPriority(termLink.get(), 0);</span>
<span class="fc" id="L351">            float sourceActivation = 1.0f;</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            if(taskLink!=null) {</span>
<span class="fc" id="L353">                sourceActivation = nar.conceptPriority(taskLink.get().term(), 0);</span>
            }
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">            if (targetActivation &gt;= 0) {</span>
                //https://groups.google.com/forum/#!topic/open-nars/KnUA43B6iYs
<span class="fc" id="L357">                termLink.orPriority(or(quality, and(sourceActivation,targetActivation)));</span>
                //was
                //termLink.orPriority(or(quality, targetActivation));
<span class="fc" id="L360">                termLink.orDurability(quality);</span>
            }
        }

<span class="fc" id="L364">        return target.budget(priority, durability, quality);</span>


        /* ORIGINAL: https://code.google.com/p/open-nars/source/browse/trunk/nars_core_java/nars/inference/BudgetFunctions.java
            Item t = memory.currentTaskLink;
            if (t == null) {
                t = memory.currentTask;
            }
            float priority = t.getPriority();
            float durability = t.getDurability() / complexity;
            float quality = qual / complexity;
            TermLink termLink = memory.currentBeliefLink;
            if (termLink != null) {
                priority = or(priority, termLink.getPriority());
                durability = and(durability, termLink.getDurability());
                float targetActivation = memory.getConceptActivation(termLink.getTarget());
                termLink.incPriority(or(quality, targetActivation));
                termLink.incDurability(quality);
            }
            return new BudgetValue(priority, durability, quality);
         */
    }
	// may be more efficient than the for-loop version above, for 2 params
	public static float aveAri(float a, float b) {
<span class="fc" id="L388">		return (a + b) / 2.0f;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>