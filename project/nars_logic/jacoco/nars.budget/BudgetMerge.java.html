<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BudgetMerge.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.budget</a> &gt; <span class="el_source">BudgetMerge.java</span></div><h1>BudgetMerge.java</h1><pre class="source lang-java linenums">package nars.budget;

/**
 * Budget merge function, with input scale factor
 */
@FunctionalInterface
public interface BudgetMerge {

    /** merge 'incoming' budget (scaled by incomingScale) into 'existing' */
    void merge(Budget existing, Budget incoming, float incomingScale);


<span class="fc" id="L13">    BudgetMerge plusDQDominated = (tgt, src, srcScale) -&gt; {</span>
<span class="fc" id="L14">        float nextPriority = src.getPriority() * srcScale;</span>

<span class="fc" id="L16">        float currentPriority = tgt.getPriorityIfNaNThenZero();</span>

<span class="fc" id="L18">        float sumPriority = currentPriority + nextPriority;</span>
<span class="fc bfc" id="L19" title="All 2 branches covered.">        if (sumPriority &gt; 1) sumPriority = 1f;</span>

<span class="fc bfc" id="L21" title="All 2 branches covered.">        boolean currentWins = currentPriority &gt; nextPriority;</span>

<span class="fc bfc" id="L23" title="All 2 branches covered.">        tgt.budget( sumPriority,</span>
<span class="fc bfc" id="L24" title="All 2 branches covered.">                (currentWins ? tgt.getDurability() : src.getDurability()),</span>
<span class="fc" id="L25">                (currentWins ? tgt.getQuality() : src.getQuality()));</span>
<span class="fc" id="L26">    };</span>
    /** add priority, interpolate durability and quality according to the relative change in priority
     *  WARNING untested
     * */
<span class="fc" id="L30">    BudgetMerge plusDQInterp = (tgt, src, srcScale) -&gt; {</span>
<span class="nc" id="L31">        float dp = src.getPriority() * srcScale;</span>

<span class="nc" id="L33">        float currentPriority = tgt.getPriorityIfNaNThenZero();</span>

<span class="nc" id="L35">        float nextPri = currentPriority + dp;</span>
<span class="nc bnc" id="L36" title="All 2 branches missed.">        if (nextPri &gt; 1) nextPri = 1f;</span>

<span class="nc" id="L38">        float currentNextPrioritySum = (currentPriority + nextPri);</span>

        /* current proportion */
<span class="nc bnc" id="L41" title="All 2 branches missed.">        final float cp = currentNextPrioritySum != 0 ? currentPriority / currentNextPrioritySum : 0.5f;</span>

        /* next proportion = 1 - cp */
<span class="nc" id="L44">        float np = 1.0f - cp;</span>


<span class="nc" id="L47">        float nextDur = (cp * tgt.getDurability()) + (np * src.getDurability());</span>
<span class="nc" id="L48">        float nextQua = (cp * tgt.getQuality()) + (np * src.getQuality());</span>

<span class="nc bnc" id="L50" title="All 2 branches missed.">        if (!Float.isFinite(nextDur))</span>
<span class="nc" id="L51">            throw new RuntimeException(&quot;NaN dur: &quot; + src + ' ' + tgt.getDurability());</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">        if (!Float.isFinite(nextQua))</span>
<span class="nc" id="L53">            throw new RuntimeException(&quot;NaN quality&quot;);</span>

<span class="nc" id="L55">        tgt.budget( nextPri, nextDur, nextQua );</span>
<span class="nc" id="L56">    };</span>

//    /** the max priority, durability, and quality of two tasks */
//    default Budget mergeMax(Budget b) {
//        return budget(
//                Util.max(getPriority(), b.getPriority()),
//                Util.max(getDurability(), b.getDurability()),
//                Util.max(getQuality(), b.getQuality())
//        );
//    }

//    /**
//     * merges another budget into this one, averaging each component
//     */
//    default void mergeAverageLERP(Budget that) {
//        if (this == that) return;
//
//        float currentPriority = getPriority();
//
//        float otherPriority = that.getPriority();
//
//        float prisum = (currentPriority + otherPriority);
//
//        /* current proportion */
//        float cp = (Util.equal(prisum, 0, BUDGET_EPSILON)) ?
//                0.5f : /* both are zero so they have equal infleunce */
//                (currentPriority / prisum);
//
//        /* next proportion */
//        float np = 1.0f - cp;
//
//        budget(
//                cp * getPriority() + np * that.getPriority(),
//                cp * getDurability() + np * that.getDurability(),
//                cp * getQuality() + np * that.getQuality()
//        );
//    }

//    /* ----------------------- Concept ----------------------- */
//    /**
//     * Activate a concept by an incoming TaskLink
//     *
//     *
//     * @param factor linear interpolation factor; 1.0: values are applied fully,  0: values are not applied at all
//     * @param receiver The budget receiving the activation
//     * @param amount The budget for the new item
//     */
//    public static void activate(final Budget receiver, final Budget amount, final Activating mode, final float factor) {
//        switch (mode) {
//            /*case Max:
//                receiver.max(amount);
//                break;*/
//
//            case Accum:
//                receiver.accumulate(amount);
//                break;
//
//            case Classic:
//                float priority = or(receiver.getPriority(), amount.getPriority());
//                float durability = aveAri(receiver.getDurability(), amount.getDurability());
//                receiver.setPriority(priority);
//                receiver.setDurability(durability);
//                break;
//
//            case WTF:
//
//                final float currentPriority = receiver.getPriority();
//                final float targetPriority = amount.getPriority();
//                /*receiver.setPriority(
//                        lerp(or(currentPriority, targetPriority),
//                                currentPriority,
//                                factor) );*/
//                float op = or(currentPriority, targetPriority);
//                if (op &gt; currentPriority) op = lerp(op, currentPriority, factor);
//                receiver.setPriority( op );
//
//                final float currentDurability = receiver.getDurability();
//                final float targetDurability = amount.getDurability();
//                receiver.setDurability(
//                        lerp(aveAri(currentDurability, targetDurability),
//                                currentDurability,
//                                factor) );
//
//                //doesnt really change it:
//                //receiver.setQuality( receiver.getQuality() );
//
//                break;
//        }
//
//    }
//
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>