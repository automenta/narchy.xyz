<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BeliefFunction.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenNARS Logic Reasoner</a> &gt; <a href="index.source.html" class="el_package">nars.truth</a> &gt; <span class="el_source">BeliefFunction.java</span></div><h1>BeliefFunction.java</h1><pre class="source lang-java linenums">package nars.truth;

import nars.Global;
import nars.Memory;
import nars.Symbols;
import nars.nal.meta.TruthOperator;
import nars.term.Term;
import nars.term.atom.Atom;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Map;

/**
 * http://aleph.sagemath.org/?q=qwssnn
 &lt;patham9&gt; only strong rules are allowing overlap
 &lt;patham9&gt; except union and revision
 &lt;patham9&gt; if you look at the graph you see why
 &lt;patham9&gt; its both rules which allow the conclusion to be stronger than the premises
 */
<span class="pc" id="L21">public enum BeliefFunction implements TruthOperator {</span>

<span class="fc" id="L23">    Revision() {</span>
        @NotNull
        @Override public Truth apply(@NotNull final Truth T, @NotNull final Truth B, Memory m) {
            //if (B == null) return null;
<span class="nc" id="L27">            return TruthFunctions.revision(T, B);</span>
        }
    },
<span class="fc" id="L30">    StructuralIntersection() {</span>
        @Nullable
        @Override public Truth apply(final Truth T, @Nullable final Truth B, @NotNull Memory m) {
<span class="fc bfc" id="L33" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L34">            return TruthFunctions.intersection(B, newDefaultTruth(m));</span>
        }
    },
<span class="fc" id="L37">    StructuralDeduction() {</span>
        @NotNull
        @Override public Truth apply(@NotNull final Truth T, final Truth B, @NotNull Memory m) {
            //if (B == null) return null;
<span class="fc" id="L41">            return TruthFunctions.deduction1(T, defaultConfidence(m));</span>
        }
    },
<span class="fc" id="L44">    StructuralAbduction() {</span>
        @Nullable
        @Override public Truth apply(final Truth T, @Nullable final Truth B, @NotNull Memory m) {
<span class="fc bfc" id="L47" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L48">            return TruthFunctions.abduction(B, newDefaultTruth(m));</span>
        }
    },
<span class="fc" id="L51">    Deduction(true) {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L54" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L55">            return TruthFunctions.deduction(T, B);</span>
        }
    },
<span class="fc" id="L58">    Induction() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L61" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L62">            return TruthFunctions.induction(T, B);</span>
        }
    },
<span class="fc" id="L65">    Abduction() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L69">            return TruthFunctions.abduction(T, B);</span>
        }
    },
<span class="fc" id="L72">    Comparison() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L76">            return TruthFunctions.comparison(T, B);</span>
        }
    },
<span class="fc" id="L79">    Conversion() {</span>
        @Nullable
        @Override public Truth apply(final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L82" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L83">            return TruthFunctions.conversion(B);</span>
        }
    },
<span class="fc" id="L86">    Negation() {</span>
        @NotNull
        @Override public Truth apply(@NotNull final Truth T, /* nullable */ final Truth B, Memory m) {
<span class="fc" id="L89">            return TruthFunctions.negation(T);</span>
        }
    },
<span class="fc" id="L92">    Contraposition() {</span>
        @NotNull
        @Override public Truth apply(@NotNull final Truth T, /* nullable */ final Truth B, Memory m) {
<span class="fc" id="L95">            return TruthFunctions.contraposition(T);</span>
        }
    },
<span class="fc" id="L98">    Resemblance(true) {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L102">            return TruthFunctions.resemblance(T,B);</span>
        }
    },
<span class="fc" id="L105">    Union() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L109">            return TruthFunctions.union(T,B);</span>
        }
    },
<span class="fc" id="L112">    Intersection(true) {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L116">            return TruthFunctions.intersection(T,B);</span>
        }
    },
<span class="fc" id="L119">    Difference(true) {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L123">            return TruthFunctions.difference(T,B);</span>
        }
    },
<span class="fc" id="L126">    Analogy(true) {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L130">            return TruthFunctions.analogy(T,B);</span>
        }
    },
<span class="fc" id="L133">    ReduceConjunction() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L137">            return TruthFunctions.reduceConjunction(T,B);</span>
        }
    },
<span class="fc" id="L140">    ReduceDisjunction() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">            if (B == null) return null;</span>
<span class="nc" id="L144">            return TruthFunctions.reduceDisjunction(T, B);</span>
        }
    },
<span class="fc" id="L147">    ReduceConjunctionNeg() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (B == null) return null;</span>
<span class="nc" id="L151">            return TruthFunctions.reduceConjunctionNeg(T, B);</span>
        }
    },
<span class="fc" id="L154">    AnonymousAnalogy() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (B==null) return null;</span>
<span class="fc" id="L158">            return TruthFunctions.anonymousAnalogy(T,B);</span>
        }
    },
<span class="fc" id="L161">    Exemplification() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (B==null) return null;</span>
<span class="fc" id="L165">            return TruthFunctions.exemplification(T,B);</span>
        }
    },
<span class="fc" id="L168">    DecomposeNegativeNegativeNegative() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">            if (B==null) return null;</span>
<span class="fc" id="L172">            return TruthFunctions.decomposeNegativeNegativeNegative(T,B);</span>
        }
    },
<span class="fc" id="L175">    DecomposePositiveNegativePositive() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L178" title="All 2 branches covered.">            if (B==null) return null;</span>
<span class="fc" id="L179">            return TruthFunctions.decomposePositiveNegativePositive(T,B);</span>
        }
    },
<span class="fc" id="L182">    DecomposeNegativePositivePositive() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (B==null) return null;</span>
<span class="fc" id="L186">            return TruthFunctions.decomposeNegativePositivePositive(T,B);</span>
        }
    },
<span class="fc" id="L189">    DecomposePositivePositivePositive() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (B==null) return null;</span>
<span class="nc" id="L193">            return TruthFunctions.decomposeNegativePositivePositive(TruthFunctions.negation(T), B);</span>
        }
    },
<span class="fc" id="L196">    DecomposePositiveNegativeNegative() {</span>
        @Nullable
        @Override public Truth apply(@NotNull final Truth T, @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L199" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L200">            return TruthFunctions.decomposePositiveNegativeNegative(T,B);</span>
        }
    },
<span class="fc" id="L203">    Identity() {</span>
        @NotNull
        @Override public Truth apply(@NotNull final Truth T, /* nullable*/ final Truth B, Memory m) {
<span class="fc" id="L206">            return new DefaultTruth(T.getFrequency(), T.getConfidence());</span>
        }
    },
<span class="fc" id="L209">    BeliefIdentity() {</span>
        @Nullable
        @Override public Truth apply(final Truth T, /* nullable*/ @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L213">            return new DefaultTruth(B.getFrequency(), B.getConfidence());</span>
        }
    },
<span class="fc" id="L216">    BeliefStructuralDeduction() {</span>
        @Nullable
        @Override public Truth apply(final Truth T, /* nullable*/ @Nullable final Truth B, @NotNull Memory m) {
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L220">            return TruthFunctions.deduction1(B, defaultConfidence(m));</span>
        }
    },
<span class="fc" id="L223">    BeliefStructuralDifference() {</span>
        @Nullable
        @Override public Truth apply(final Truth T, /* nullable*/ @Nullable final Truth B, @NotNull Memory m) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L227">            Truth res =  TruthFunctions.deduction1(B, defaultConfidence(m));</span>
<span class="fc" id="L228">            return new DefaultTruth(1.0f-res.getFrequency(), res.getConfidence());</span>
        }
    },
<span class="fc" id="L231">    BeliefNegation() {</span>
        @Nullable
        @Override public Truth apply(final Truth T, /* nullable*/ @Nullable final Truth B, Memory m) {
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (B == null) return null;</span>
<span class="fc" id="L235">            return TruthFunctions.negation(B);</span>
        }
    };

    @Nullable
    public static Truth newDefaultTruth(@NotNull Memory m) {
<span class="fc" id="L241">        return m.newDefaultTruth(Symbols.JUDGMENT);</span>
    }

    public static float defaultConfidence(@NotNull Memory m) {
<span class="fc" id="L245">        return m.getDefaultConfidence(Symbols.JUDGMENT);</span>
    }


    public final boolean allowOverlap;


//    /**
//     * @param T taskTruth
//     * @param B beliefTruth (possibly null)
//     * @return
//     */
//    @Override
//    abstract public Truth apply(Truth T, Truth B, Memory m);



<span class="fc" id="L262">    static final Map&lt;Term, BeliefFunction&gt; atomToTruthModifier = Global.newHashMap(BeliefFunction.values().length);</span>

    static {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        for (BeliefFunction tm : BeliefFunction.values())</span>
<span class="fc" id="L266">            atomToTruthModifier.put(Atom.the(tm.toString()), tm);</span>
<span class="fc" id="L267">    }</span>

    public static BeliefFunction get(Term a) {
<span class="fc" id="L270">        return atomToTruthModifier.get(a);</span>
    }

    BeliefFunction() {
<span class="fc" id="L274">        this(false);</span>
<span class="fc" id="L275">    }</span>

<span class="fc" id="L277">    BeliefFunction(boolean allowOverlap) {</span>
<span class="fc" id="L278">        this.allowOverlap = allowOverlap;</span>
<span class="fc" id="L279">    }</span>


    @Override
    public final boolean allowOverlap() {
<span class="fc" id="L284">        return allowOverlap;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>